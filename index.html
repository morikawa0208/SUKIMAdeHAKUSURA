<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>White Dungeon - Professional Build System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap');
        
        html, body {
            margin: 0;
            padding: 0;
            touch-action: manipulation;
            overscroll-behavior: none;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            align-items: center;
        }

        .app-shell {
            width: clamp(0px, 100%, 460px);
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        .page { display: none; height: 100%; min-height: 0; flex-direction: column; overflow-y: auto; }
        .page.active { display: flex; }

        /* Status Bars */
        .bar-container { position: relative; background-color: #e2e8f0; border-radius: 6px; overflow: hidden; height: 20px; border: 1px solid #cbd5e1; width: 100%; }
        .bar-fill { height: 100%; transition: width 0.3s ease; }
        .hp-fill { background-color: #ef4444; }
        .mp-fill { background-color: #3b82f6; }
        .exp-fill { background-color: #fbbf24; }
        .bar-text { position: absolute; inset: 0; display: flex; items-center; justify-content: center; font-size: 10px; font-weight: 800; color: #fff; text-shadow: 1px 1px 0 rgba(0,0,0,0.5); pointer-events: none; }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-40px); }
        }
        .damage-text {
            position: absolute;
            font-weight: 900;
            font-size: 1.5rem;
            animation: floatUp 0.8s forwards;
            pointer-events: none;
            z-index: 100;
            text-shadow: 2px 2px 0 #fff;
        }

        .mini-log {
            font-size: 10px;
            line-height: 1.2;
            mask-image: linear-gradient(to top, black 70%, transparent 100%);
        }

        .rarity-normal { color: #334155; font-weight: bold; }
        .rarity-magic { color: #3b82f6; font-weight: bold; }
        .rarity-rare { color: #facc15; font-weight: bold; }
        .rarity-epic { color: #a855f7; font-weight: bold; }
        .rarity-legendary { color: #a16207; font-weight: bold; text-shadow: 0 0 8px rgba(161, 98, 7, 0.35); }

        .drop-log-box {
            font-size: 10px;
            line-height: 1.2;
            mask-image: linear-gradient(to top, black 70%, transparent 100%);
        }
        .drop-log-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            line-height: 1.2;
        }
        .drop-log-item i {
            color: #94a3b8;
        }

        .shake { animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        nav button.active { color: #0f172a; border-top: 3px solid #0f172a; background-color: #fff; }
        .job-tab.active { background-color: #0f172a; color: white; }
        .type-tab.active { border-bottom: 3px solid #0f172a; color: #0f172a; font-weight: bold; }

        .no-scrollbar::-webkit-scrollbar { display: none; }

        .boss-visual {
            color: #f59e0b;
            text-shadow: 0 0 12px rgba(245, 158, 11, 0.6);
            animation: bossPulse 1.8s ease-in-out infinite;
        }
        .boss-name {
            color: #b45309;
            text-shadow: 0 0 6px rgba(245, 158, 11, 0.35);
        }
        .boss-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            font-weight: 900;
            letter-spacing: 0.2em;
            padding: 4px 10px;
            border-radius: 9999px;
            background: linear-gradient(135deg, #f59e0b, #f97316);
            color: #fff7ed;
            box-shadow: 0 0 10px rgba(249, 115, 22, 0.4);
        }
        @keyframes bossPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.06); }
        }

        .item-name-shrink {
            font-size: 0.72rem;
            line-height: 1.1;
        }

        .item-stat-categories {
            display: flex;
            gap: 8px;
            align-items: flex-start;
            flex-wrap: nowrap;
        }

        .item-stat-group {
            min-width: 0;
            flex: 1;
        }

        .item-stat-group-title {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            font-weight: 900;
            color: #94a3b8;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .item-unique-block {
            margin-top: 6px;
            padding: 6px 8px;
            border-radius: 8px;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.35);
        }

        .enhance-label {
            font-size: 0.7rem;
            font-weight: 900;
            letter-spacing: 0.02em;
        }
        .enhance-green { color: #22c55e; }
        .enhance-yellow { color: #facc15; }
        .enhance-blue { color: #38bdf8; }
        .enhance-pink { color: #f472b6; }
        .enhance-orange { color: #fb923c; }
        .enhance-gold { color: #f59e0b; text-shadow: 0 0 6px rgba(245, 158, 11, 0.55); }
        .enhance-white { color: #f8fafc; text-shadow: 0 0 4px rgba(15, 23, 42, 0.8); }
        .enhance-broken { color: #ef4444; font-size: 0.6rem; font-weight: 900; letter-spacing: 0.08em; }
        .enhance-rattle { animation: shake 0.35s cubic-bezier(.36,.07,.19,.97) infinite; }
        .enhance-glow-success { animation: enhanceGlow 1.2s ease-in-out infinite; }
        .enhance-glow-fail { animation: enhanceFade 1.2s ease-in-out infinite; }
        @keyframes enhanceGlow {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 rgba(34, 197, 94, 0.4); }
            50% { transform: scale(1.04); box-shadow: 0 0 20px rgba(34, 197, 94, 0.5); }
        }
        @keyframes enhanceFade {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(0.98); opacity: 0.6; }
        }

        .drop-log-item.rarity-legendary {
            background: linear-gradient(120deg, rgba(251, 191, 36, 0.24), rgba(30, 41, 59, 0.2));
            border: 1px solid rgba(251, 191, 36, 0.6);
            border-radius: 9999px;
            padding: 2px 8px;
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.35);
            animation: legendaryLogGlow 2.4s ease-in-out infinite;
        }
        .drop-log-item.rarity-legendary i {
            color: #fbbf24;
        }
        @keyframes legendaryLogGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(251, 191, 36, 0.3); }
            50% { box-shadow: 0 0 18px rgba(251, 191, 36, 0.55); }
        }

        .feedback-embed {
            width: 100%;
            height: clamp(420px, 70dvh, 760px);
            border: 0;
        }
    </style>
</head>
<body class="flex flex-col">
    <div class="app-shell">

    <!-- TOP BAR -->
    <header class="h-12 border-b flex items-center justify-between px-4 shrink-0 bg-white z-50 shadow-sm">
        <div class="font-bold flex items-center gap-2">
            <span class="text-slate-400 text-xs">FLOOR</span>
            <span id="floor-display" class="text-xl font-black">1</span>
        </div>
        <div class="flex items-center gap-3">
            <span class="text-[10px] bg-amber-100 text-amber-700 px-2 py-0.5 rounded-full font-bold">SP: <span id="header-sp">0</span></span>
            <span class="text-[10px] bg-emerald-100 text-emerald-700 px-2 py-0.5 rounded-full font-bold"><i class="fas fa-coins"></i> <span id="header-gold">0</span>G</span>
            <div class="bg-slate-800 text-white text-[10px] px-2 py-1 rounded font-bold">Lv.<span id="header-lvl">1</span></div>
        </div>
    </header>

    <!-- CONTENT PAGES -->
    <main class="flex-1 overflow-hidden relative min-h-0">
        
        <!-- BATTLE PAGE -->
        <section id="page-battle" class="page active p-4" style="padding-top: 4px">
            <div class="flex-1 flex flex-col items-center justify-center relative min-h-[200px]">
                <div class="absolute right-2 top-2 z-10 flex items-center gap-2">
                    <label class="flex items-center gap-1.5 bg-white/90 text-slate-600 text-[12px] font-bold px-3 py-2 rounded-full shadow border border-slate-200">
                        <input id="rematch-toggle" type="checkbox" class="accent-slate-800">
                        å†æˆ¦
                    </label>
                    <button id="warp-btn" class="bg-slate-800 text-white text-xs font-black px-3 py-2 rounded-full shadow flex items-center gap-2 hover:bg-slate-700 active:scale-95 transition">
                        <i class="fas fa-location-arrow"></i>
                        ãƒ¯ãƒ¼ãƒ—
                    </button>
                </div>
                <div id="enemy-container" class="text-center transition-all duration-300">
                    <div id="enemy-visual" class="text-8xl mb-4 text-slate-700"><i class="fas fa-ghost"></i></div>
                <div id="enemy-bossrush-buffs" class="flex flex-wrap justify-center gap-1 mb-1 text-[10px]"></div>
                <div id="enemy-name" class="font-bold text-lg mb-1">ã‚¹ãƒ©ã‚¤ãƒ </div>
                <div id="enemy-boss-badge" class="hidden justify-center mb-2">
                    <span class="boss-badge"><i class="fas fa-crown"></i> BOSS</span>
                </div>
                <div class="w-48 bar-container mx-auto mb-1 border-0 bg-slate-200">
                    <div id="enemy-hp-bar" class="bar-fill hp-fill"></div>
                    <div class="bar-text">HP: <span id="enemy-hp-text">30/30</span></div>
                </div>
                <div id="enemy-status-effects" class="flex flex-wrap justify-center gap-1 mt-1 text-[10px]"></div>
            </div>
                <div id="damage-layer" class="absolute inset-0 pointer-events-none"></div>
                <div class="absolute left-0 bottom-4 w-1/2 drop-log-box pointer-events-none text-left pl-2 text-slate-500 italic">
                    <div id="drop-log-list" class="flex flex-col-reverse gap-1"></div>
                </div>
                <div class="absolute right-0 bottom-4 w-1/2 mini-log pointer-events-none text-right pr-2 text-slate-500 italic space-y-1">
                    <div id="mini-log-9"></div>
                    <div id="mini-log-8"></div>
                    <div id="mini-log-7"></div>
                    <div id="mini-log-6"></div>
                    <div id="mini-log-5"></div>
                    <div id="mini-log-4"></div>
                    <div id="mini-log-3"></div>
                    <div id="mini-log-2"></div>
                    <div id="mini-log-1"></div>
                    <div id="mini-log-0" class="text-slate-800 font-bold"></div>
                </div>
            </div>

            <!-- Player Status Section -->
            <div class="bg-white border rounded-2xl p-4 shadow-sm space-y-3 mb-2">
                <div class="space-y-1.5">
                    <div class="bar-container">
                        <div id="player-hp-bar" class="bar-fill hp-fill"></div>
                        <div class="bar-text">HP: <span id="player-hp-text">100/100</span></div>
                    </div>
                    <div class="bar-container">
                        <div id="player-mp-bar" class="bar-fill mp-fill"></div>
                        <div class="bar-text">MP: <span id="player-mp-text">30/30</span></div>
                    </div>
                    <div class="bar-container">
                        <div id="player-exp-bar-battle" class="bar-fill exp-fill"></div>
                        <div class="bar-text">EXP: <span id="player-exp-text-battle">0/100</span></div>
                    </div>
                    <div>
                        <div id="player-status-effects" class="flex flex-wrap gap-1 mt-1 text-[10px] h-[21.5px]"></div>
                    </div>
                </div>

                <div class="space-y-2">
                    <div id="battle-skill-slots"></div>
                </div>
                <div id="battle-potion-slots" class="grid grid-cols-2 gap-2"></div>
                <button id="action-btn" class="w-full bg-slate-800 text-white font-black py-4 rounded-2xl shadow-lg active:scale-95 transition-transform text-lg flex items-center justify-center gap-2">
                    <i class="fas fa-sword"></i> <span>æ”»æ’ƒ</span>
                </button>
            </div>
            
            <div id="death-overlay" class="absolute inset-0 bg-red-900/40 backdrop-blur-[2px] hidden items-center justify-center z-50">
                <div class="bg-white p-8 rounded-3xl shadow-2xl text-center border-2 border-red-500 mx-4">
                    <div class="text-6xl mb-4">ğŸ’€</div>
                    <h2 class="text-2xl font-black text-red-600 mb-2">YOU DIED</h2>
                    <p class="text-sm text-slate-500 mb-2">ãƒšãƒŠãƒ«ãƒ†ã‚£ãŒç™ºç”Ÿã—ã¾ã—ãŸï¼š</p>
                    <div class="text-xs text-red-600 font-bold mb-6 bg-red-50 p-3 rounded-xl">
                        éšå±¤: -20<br>
                        çµŒé¨“å€¤ãƒ­ã‚¹ãƒˆ: <span id="lost-exp-val">0</span>
                    </div>
                    <button onclick="revive()" class="w-full bg-red-600 text-white font-bold px-8 py-4 rounded-xl shadow-lg active:scale-95">è¡—ã«æˆ»ã‚‹</button>
                </div>
            </div>
        </section>

        <!-- SAVE PAGE -->
        <section id="page-save" class="page p-4 bg-slate-50">
            <div class="flex items-center justify-between mb-4 px-2">
                <h2 class="text-xl font-black flex items-center gap-2"><i class="fas fa-floppy-disk"></i> ã‚»ãƒ¼ãƒ–</h2>
            </div>
            <div id="save-section" class="bg-white rounded-3xl p-6 shadow-sm mb-6">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-black text-slate-700 flex items-center gap-2"><i class="fas fa-floppy-disk"></i> ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰</h3>
                    <span id="autosave-indicator" class="text-[10px] text-emerald-600 font-bold">ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–: ã‚¹ãƒ­ãƒƒãƒˆ1</span>
                </div>
                <p class="text-[10px] text-slate-500 mb-3">30ç§’ã”ã¨ã«é¸æŠã—ãŸã‚¹ãƒ­ãƒƒãƒˆã¸è‡ªå‹•ä¿å­˜ã—ã¾ã™ã€‚</p>
                <div id="save-status" class="text-[10px] text-slate-400 mb-3">æœªä¿å­˜</div>
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <button id="switch-save-slot-btn" class="py-2 rounded-xl bg-slate-100 text-slate-600 text-[10px] font-black flex items-center justify-center gap-2">
                        <i class="fas fa-right-left"></i> ã‚¹ãƒ­ãƒƒãƒˆåˆ‡æ›¿
                    </button>
                    <button id="new-save-btn" class="py-2 rounded-xl bg-rose-50 text-rose-600 text-[10px] font-black flex items-center justify-center gap-2">
                        <i class="fas fa-trash-can"></i> æ–°ã—ãå§‹ã‚ã‚‹
                    </button>
                </div>
                <div class="space-y-3">
                    <div class="rounded-2xl border border-slate-200 bg-slate-50 p-3">
                        <div class="flex items-center justify-between gap-2">
                            <div>
                                <div class="text-xs font-black text-slate-700">ã‚¹ãƒ­ãƒƒãƒˆ1</div>
                                <div id="save-slot-info-1" class="text-[10px] text-slate-400">ç©º</div>
                            </div>
                            <label class="text-[9px] font-bold text-slate-500 flex items-center gap-1">
                                <input type="radio" name="autosave-slot" value="1" class="accent-slate-800">
                                ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–
                            </label>
                        </div>
                        <div class="flex gap-2 mt-2">
                            <button data-save-slot="1" class="flex-1 py-2 rounded-xl bg-slate-800 text-white text-[10px] font-black flex items-center justify-center gap-1">
                                <i class="fas fa-floppy-disk"></i> ã‚»ãƒ¼ãƒ–
                            </button>
                            <button data-load-slot="1" class="flex-1 py-2 rounded-xl bg-slate-200 text-slate-700 text-[10px] font-black flex items-center justify-center gap-1">
                                <i class="fas fa-download"></i> ãƒ­ãƒ¼ãƒ‰
                            </button>
                        </div>
                    </div>
                    <div class="rounded-2xl border border-slate-200 bg-slate-50 p-3">
                        <div class="flex items-center justify-between gap-2">
                            <div>
                                <div class="text-xs font-black text-slate-700">ã‚¹ãƒ­ãƒƒãƒˆ2</div>
                                <div id="save-slot-info-2" class="text-[10px] text-slate-400">ç©º</div>
                            </div>
                            <label class="text-[9px] font-bold text-slate-500 flex items-center gap-1">
                                <input type="radio" name="autosave-slot" value="2" class="accent-slate-800">
                                ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–
                            </label>
                        </div>
                        <div class="flex gap-2 mt-2">
                            <button data-save-slot="2" class="flex-1 py-2 rounded-xl bg-slate-800 text-white text-[10px] font-black flex items-center justify-center gap-1">
                                <i class="fas fa-floppy-disk"></i> ã‚»ãƒ¼ãƒ–
                            </button>
                            <button data-load-slot="2" class="flex-1 py-2 rounded-xl bg-slate-200 text-slate-700 text-[10px] font-black flex items-center justify-center gap-1">
                                <i class="fas fa-download"></i> ãƒ­ãƒ¼ãƒ‰
                            </button>
                        </div>
                    </div>
                    <div class="rounded-2xl border border-slate-200 bg-slate-50 p-3">
                        <div class="flex items-center justify-between gap-2">
                            <div>
                                <div class="text-xs font-black text-slate-700">ã‚¹ãƒ­ãƒƒãƒˆ3</div>
                                <div id="save-slot-info-3" class="text-[10px] text-slate-400">ç©º</div>
                            </div>
                            <label class="text-[9px] font-bold text-slate-500 flex items-center gap-1">
                                <input type="radio" name="autosave-slot" value="3" class="accent-slate-800">
                                ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–
                            </label>
                        </div>
                        <div class="flex gap-2 mt-2">
                            <button data-save-slot="3" class="flex-1 py-2 rounded-xl bg-slate-800 text-white text-[10px] font-black flex items-center justify-center gap-1">
                                <i class="fas fa-floppy-disk"></i> ã‚»ãƒ¼ãƒ–
                            </button>
                            <button data-load-slot="3" class="flex-1 py-2 rounded-xl bg-slate-200 text-slate-700 text-[10px] font-black flex items-center justify-center gap-1">
                                <i class="fas fa-download"></i> ãƒ­ãƒ¼ãƒ‰
                            </button>
                        </div>
                    </div>
                </div>

                <div class="mt-4 rounded-2xl border border-slate-200 bg-white p-4">
                    <div class="flex items-center justify-between gap-2 mb-2">
                        <h4 class="text-[11px] font-black text-slate-700 flex items-center gap-2">
                            <i class="fas fa-file-export"></i> ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ / ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                        </h4>
                        <span class="text-[9px] text-slate-400">ç¾åœ¨ã®ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚¹ãƒ­ãƒƒãƒˆã‚’å¯¾è±¡</span>
                    </div>
                    <p class="text-[10px] text-slate-500 mb-3">
                        æ–‡å­—åˆ—ã‚³ãƒ”ãƒ¼ã§ä»–ç«¯æœ«ã¸å¼•ãç¶™ã’ã¾ã™ã€‚
                    </p>
                    <div class="grid grid-cols-1 gap-3">
                        <div class="rounded-xl border border-slate-200 bg-slate-50 p-3 space-y-2">
                            <div class="flex items-center justify-between gap-2">
                                <span class="text-[10px] font-black text-slate-600 flex items-center gap-1">
                                    <i class="fas fa-copy"></i> ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ–‡å­—åˆ—
                                </span>
                                <button id="export-refresh-btn" class="text-[9px] font-black px-2 py-1 rounded-full bg-slate-800 text-white">
                                    å¼•ãç¶™ãã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
                                </button>
                            </div>
                            <textarea id="export-text" class="w-full h-20 rounded-lg border border-slate-200 bg-white p-2 text-[9px] text-slate-600" readonly></textarea>
                            <div id="export-copy-message" class="text-[9px] text-emerald-600 font-bold hidden">ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ</div>
                            <div class="flex items-center gap-2">
                                <button id="export-copy-btn" class="flex-1 py-2 rounded-xl bg-slate-800 text-white text-[10px] font-black flex items-center justify-center gap-1">
                                    <i class="fas fa-copy"></i> ã‚³ãƒ”ãƒ¼
                                </button>
                                <button id="export-clear-btn" class="flex-1 py-2 rounded-xl bg-slate-200 text-slate-700 text-[10px] font-black flex items-center justify-center gap-1">
                                    <i class="fas fa-eraser"></i> ã‚¯ãƒªã‚¢
                                </button>
                            </div>
                        </div>

                        <div class="rounded-xl border border-slate-200 bg-slate-50 p-3 space-y-2">
                            <span class="text-[10px] font-black text-slate-600 flex items-center gap-1">
                                <i class="fas fa-file-import"></i> ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡å­—åˆ—
                            </span>
                            <div class="flex items-center justify-between gap-2 text-[9px] text-slate-500">
                                <span class="font-bold flex items-center gap-1">
                                    <i class="fas fa-bullseye"></i> å–ã‚Šè¾¼ã¿å…ˆã‚¹ãƒ­ãƒƒãƒˆ
                                </span>
                                <select id="import-slot-select" class="rounded-lg border border-slate-200 bg-white px-2 py-1 text-[9px] text-slate-600">
                                    <option value="auto">ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–</option>
                                    <option value="1">ã‚¹ãƒ­ãƒƒãƒˆ1</option>
                                    <option value="2">ã‚¹ãƒ­ãƒƒãƒˆ2</option>
                                    <option value="3">ã‚¹ãƒ­ãƒƒãƒˆ3</option>
                                </select>
                            </div>
                            <textarea id="import-text" class="w-full h-20 rounded-lg border border-slate-200 bg-white p-2 text-[9px] text-slate-600" placeholder="ã“ã“ã«è²¼ã‚Šä»˜ã‘"></textarea>
                            <div class="flex items-center gap-2">
                                <button id="import-apply-btn" class="flex-1 py-2 rounded-xl bg-emerald-600 text-white text-[10px] font-black flex items-center justify-center gap-1">
                                    <i class="fas fa-upload"></i> å–ã‚Šè¾¼ã¿
                                </button>
                                <button id="import-clear-btn" class="flex-1 py-2 rounded-xl bg-slate-200 text-slate-700 text-[10px] font-black flex items-center justify-center gap-1">
                                    <i class="fas fa-eraser"></i> ã‚¯ãƒªã‚¢
                                </button>
                            </div>
                            <div id="import-tamper-message" class="text-[9px] text-rose-500 font-bold hidden">
                                æ”¹ã–ã‚“ãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚å–ã‚Šè¾¼ã¿ã‚’æ‹’å¦ã—ã¾ã—ãŸã€‚
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <!-- STATUS PAGE -->
        <section id="page-status" class="page p-4 bg-slate-50">
            <h2 class="text-xl font-black mb-4 flex items-center gap-2 px-2"><i class="fas fa-user-circle"></i> ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</h2>
            
            <!-- Summary Card -->
            <div class="bg-white rounded-3xl p-6 shadow-sm mb-4">
                <div class="flex items-center justify-between border-b pb-4 mb-4">
                    <div>
                        <div class="text-[10px] text-slate-400 font-bold uppercase tracking-widest">Level</div>
                        <div class="text-4xl font-black" id="status-lvl">1</div>
                    </div>
                    <div class="text-right">
                        <div class="text-[10px] text-slate-400 font-bold uppercase tracking-widest">Experience</div>
                        <div class="text-sm font-bold"><span id="status-exp">0</span> / <span id="status-next">100</span></div>
                        <div class="w-32 bar-container h-2 mt-1 border-0 bg-slate-100"><div id="status-exp-bar" class="bar-fill exp-fill"></div></div>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-y-6 gap-x-4">
                    <div class="flex flex-col">
                        <span class="text-[10px] text-slate-400 font-bold uppercase">STR (ç‰©ç†æ”»æ’ƒ)</span>
                        <span class="text-2xl font-black text-slate-700" id="status-atk">10</span>
                    </div>
                    <div class="flex flex-col">
                        <span class="text-[10px] text-slate-400 font-bold uppercase">VIT (ç‰©ç†é˜²å¾¡)</span>
                        <span class="text-2xl font-black text-slate-700" id="status-def">5</span>
                    </div>
                    <div class="flex flex-col">
                        <span class="text-[10px] text-slate-400 font-bold uppercase">INT (é­”æ³•å¨åŠ›)</span>
                        <span class="text-2xl font-black text-blue-600" id="status-int">5</span>
                    </div>
                    <div class="flex flex-col">
                        <span class="text-[10px] text-slate-400 font-bold uppercase">DEX (å™¨ç”¨ã•)</span>
                        <span class="text-2xl font-black text-green-600" id="status-dex">5</span>
                    </div>
                    <div class="flex flex-col">
                        <span class="text-[10px] text-slate-400 font-bold uppercase">LUK (é‹)</span>
                        <span class="text-2xl font-black text-amber-600" id="status-luk">5</span>
                    </div>
                </div>
            </div>

            <!-- Detailed Stats -->
            <div class="bg-slate-800 rounded-3xl p-6 text-white mb-6">
                <div class="flex items-center justify-between mb-4 border-b border-slate-700 pb-2">
                    <h3 class="text-xs font-bold text-slate-400 uppercase tracking-tighter">Secondary Attributes</h3>
                    <button id="secondary-info-btn" class="text-slate-400 hover:text-white transition-colors text-xs font-bold flex items-center gap-1">
                        <i class="fas fa-circle-info"></i> Info
                    </button>
                </div>
                <div class="grid grid-cols-2 gap-4 text-xs">
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>æœ€å¤§HP</span><span id="stat-max-hp">0</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>æœ€å¤§MP</span><span id="stat-max-mp">0</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>HPè‡ªå‹•å›å¾©</span><span id="stat-hp-regen">0</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>MPè‡ªå‹•å›å¾©</span><span id="stat-mp-regen">0</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>æ”»æ’ƒåŠ›</span><span id="stat-atk-flat">0</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>é˜²å¾¡åŠ›</span><span id="stat-def-flat">0</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>å‘½ä¸­ç‡</span><span id="stat-accuracy">95%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>ä¼šå¿ƒç‡</span><span id="stat-crit">5%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸</span><span id="stat-crit-dmg">200%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>ä¸ãƒ€ãƒ¡å¢—åŠ </span><span id="stat-dmg-boost">0%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>è¢«ãƒ€ãƒ¡è»½æ¸›</span><span id="stat-dmg-reduction">0%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>å›é¿ç‡</span><span id="stat-eva">3%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>å¸è¡€ç‡</span><span id="stat-leech">0%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>é­”æ³•è²«é€š</span><span id="stat-m-pen">0%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>è¿½åŠ çµŒé¨“å€¤</span><span id="stat-exp-boost">0%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>ãƒ‰ãƒ­ãƒƒãƒ—ç‡</span><span id="stat-luck">0%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>ãƒ¬ã‚¢ãƒ‰ãƒ­ç‡</span><span id="stat-rare-find">0%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>Affixç‡</span><span id="stat-affix-find">0%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>ã‚¨ãƒªãƒ¼ãƒˆé­é‡ç‡</span><span id="stat-elite-encounter">0%</span></div>
                    <div class="flex justify-between border-b border-slate-700 pb-1"><span>ã‚´ãƒ¼ãƒ«ãƒ‰å¢—åŠ ç‡</span><span id="stat-gold-boost">0%</span></div>
                </div>
            </div>

            <!-- Equipment -->
            <div class="space-y-3 mb-12">
                <div class="bg-white p-4 rounded-2xl border shadow-sm">
                    <div class="text-[9px] text-slate-400 font-black uppercase tracking-widest mb-1 flex items-center gap-1">
                        <i class="fas fa-khanda text-slate-300"></i>
                        <span>Weapon Slot</span>
                    </div>
                    <div id="equip-weapon" class="font-black text-[11px] leading-tight whitespace-normal break-words">ãªã—</div>
                    <div id="weapon-val" class="mt-1"></div>
                </div>
                <div class="bg-white p-4 rounded-2xl border shadow-sm">
                    <div class="text-[9px] text-slate-400 font-black uppercase tracking-widest mb-1 flex items-center gap-1">
                        <i class="fas fa-shield-halved text-slate-300"></i>
                        <span>Armor Slot</span>
                    </div>
                    <div id="equip-armor" class="font-black text-[11px] leading-tight whitespace-normal break-words">ãªã—</div>
                    <div id="armor-val" class="mt-1"></div>
                </div>
                <div class="bg-white p-4 rounded-2xl border shadow-sm">
                    <div class="text-[9px] text-slate-400 font-black uppercase tracking-widest mb-1 flex items-center gap-1">
                        <i class="fas fa-helmet-safety text-slate-300"></i>
                        <span>Helm Slot</span>
                    </div>
                    <div id="equip-head" class="font-black text-[11px] leading-tight whitespace-normal break-words">ãªã—</div>
                    <div id="head-val" class="mt-1"></div>
                </div>
                <div class="bg-white p-4 rounded-2xl border shadow-sm">
                    <div class="text-[9px] text-slate-400 font-black uppercase tracking-widest mb-1 flex items-center gap-1">
                        <i class="fas fa-hand text-slate-300"></i>
                        <span>Hand Slot</span>
                    </div>
                    <div id="equip-hands" class="font-black text-[11px] leading-tight whitespace-normal break-words">ãªã—</div>
                    <div id="hands-val" class="mt-1"></div>
                </div>
                <div class="bg-white p-4 rounded-2xl border shadow-sm">
                    <div class="text-[9px] text-slate-400 font-black uppercase tracking-widest mb-1 flex items-center gap-1">
                        <i class="fas fa-shoe-prints text-slate-300"></i>
                        <span>Foot Slot</span>
                    </div>
                    <div id="equip-feet" class="font-black text-[11px] leading-tight whitespace-normal break-words">ãªã—</div>
                    <div id="feet-val" class="mt-1"></div>
                </div>
                <div class="bg-white p-4 rounded-2xl border shadow-sm">
                    <div class="text-[9px] text-slate-400 font-black uppercase tracking-widest mb-1 flex items-center gap-1">
                        <i class="fas fa-gem text-slate-300"></i>
                        <span>Accessory Slot 1</span>
                    </div>
                    <div id="equip-accessory1" class="font-black text-[11px] leading-tight whitespace-normal break-words">ãªã—</div>
                    <div id="accessory1-val" class="mt-1"></div>
                </div>
                <div class="bg-white p-4 rounded-2xl border shadow-sm">
                    <div class="text-[9px] text-slate-400 font-black uppercase tracking-widest mb-1 flex items-center gap-1">
                        <i class="fas fa-gem text-slate-300"></i>
                        <span>Accessory Slot 2</span>
                    </div>
                    <div id="equip-accessory2" class="font-black text-[11px] leading-tight whitespace-normal break-words">ãªã—</div>
                    <div id="accessory2-val" class="mt-1"></div>
                </div>
            </div>
        </section>

        <!-- SKILL PAGE -->
        <section id="page-skill" class="page bg-slate-50 flex-col h-full min-h-0">
            <div class="p-4 bg-white border-b shrink-0">
                <div class="flex justify-between items-center mb-4 px-1">
                    <div class="flex items-center gap-2 flex-wrap">
                        <h2 class="text-xl font-black">ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼</h2>
                        <button id="skill-reset-btn" class="px-3 py-2 rounded-xl border border-rose-200 bg-rose-50 text-rose-600 text-[10px] font-black flex items-center gap-2">
                            <i class="fas fa-rotate-left"></i>
                            ãƒªã‚»ãƒƒãƒˆ
                        </button>
                        <button id="skill-point-mode" class="px-2 py-2 rounded-xl border border-slate-200 bg-slate-50 text-slate-600 text-[10px] font-black flex items-center gap-2">
                            <i class="fas fa-sliders"></i>
                            +1
                        </button>
                    </div>
                    <div class="text-sm font-bold bg-amber-100 text-amber-700 px-3 py-1 rounded-full">SP: <span id="skill-sp-display">0</span></div>
                </div>
                <!-- Job Select -->
                <div class="flex items-center gap-2">
                    <div class="text-slate-400 text-sm"><i class="fas fa-briefcase"></i></div>
                    <select id="job-select" onchange="switchJob(this.value)" class="flex-1 border border-slate-200 rounded-xl px-3 py-2 text-sm font-bold text-slate-700 bg-slate-50">
                        <option value="warrior">æˆ¦å£«</option>
                        <option value="mage">é­”è¡“å¸«</option>
                        <option value="thief">ç›—è³Š</option>
                        <option value="ranger">ãƒ¬ãƒ³ã‚¸ãƒ£ãƒ¼</option>
                        <option value="paladin">è–é¨å£«</option>
                        <option value="monk">æ‹³é—˜å£«</option>
                    </select>
                </div>
            </div>
            <div class="flex bg-white shrink-0 shadow-sm">
                <button onclick="switchSkillType('active')" id="tab-active" class="type-tab flex-1 py-3 text-sm text-slate-400 transition-all">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–</button>
                <button onclick="switchSkillType('passive')" id="tab-passive" class="type-tab flex-1 py-3 text-sm text-slate-400 transition-all">ãƒ‘ãƒƒã‚·ãƒ–</button>
            </div>
            <div class="px-4 py-3 bg-white border-b shrink-0">
                <div class="flex items-center justify-between mb-1">
                    <div class="text-xs font-black">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¹ãƒ­ãƒƒãƒˆ</div>
                    <div class="text-[9px] text-slate-400">ã‚¿ãƒƒãƒ—ã§ã‚¹ãƒ­ãƒƒãƒˆé¸æŠ</div>
                </div>
                <div id="skill-slot-settings" class="grid grid-cols-2 gap-1.5"></div>
            </div>
            <div id="skill-list" class="flex-1 overflow-y-auto p-4 space-y-3 pb-8 min-h-0"></div>
        </section>

        <!-- INVENTORY PAGE -->
        <section id="page-inventory" class="page p-4 bg-slate-50">
            <div class="flex items-center justify-between mb-4 px-2">
                <h2 class="text-xl font-black flex items-center gap-2"><i class="fas fa-box-open"></i> æŒã¡ç‰©</h2>
                <span class="text-[10px] font-bold text-slate-400 bg-slate-200 px-2 py-0.5 rounded-full"><span id="inv-count">0</span> / âˆ</span>
            </div>
            <div id="inventory-list" class="flex-1 overflow-y-auto space-y-2 pb-12"></div>
            <div class="bg-white rounded-2xl border p-3 mt-3 shadow-sm">
                <div class="flex items-center justify-between mb-2">
                    <div class="text-[10px] font-black text-slate-400">ä¸¦ã³æ›¿ãˆ</div>
                    <div class="flex items-center gap-2">
                        <button id="inv-sort-toggle" onclick="toggleInventorySort()" class="px-3 py-2 rounded-xl border text-[10px] font-black flex items-center gap-2 bg-slate-50 text-slate-500 border-slate-200">
                            <i class="fas fa-clock"></i>
                            <span id="inv-sort-label">å…¥æ‰‹é †</span>
                        </button>
                        <button id="loot-filter-open" class="px-3 py-2 rounded-xl border text-[10px] font-black flex items-center gap-2 bg-slate-50 text-slate-500 border-slate-200">
                            <i class="fas fa-filter"></i>
                            <span>å–å¾—è¨­å®š</span>
                        </button>
                        <button id="bulk-sell-open" class="px-3 py-2 rounded-xl border text-[10px] font-black flex items-center gap-2 bg-slate-50 text-slate-500 border-slate-200">
                            <i class="fas fa-sack-dollar"></i>
                            <span>ä¸€æ‹¬å£²å´</span>
                        </button>
                    </div>
                </div>
                <div class="grid grid-cols-8 gap-2 text-[10px] font-bold">
                    <button data-inv-filter="all" onclick="setInventoryFilter('all')" class="inv-filter-btn py-2 rounded-xl border">å…¨ã¦</button>
                    <button data-inv-filter="weapon" onclick="setInventoryFilter('weapon')" class="inv-filter-btn py-2 rounded-xl border">æ­¦å™¨</button>
                    <button data-inv-filter="armor" onclick="setInventoryFilter('armor')" class="inv-filter-btn py-2 rounded-xl border">é§</button>
                    <button data-inv-filter="head" onclick="setInventoryFilter('head')" class="inv-filter-btn py-2 rounded-xl border">å…œ</button>
                    <button data-inv-filter="hands" onclick="setInventoryFilter('hands')" class="inv-filter-btn py-2 rounded-xl border">æ‰‹</button>
                    <button data-inv-filter="feet" onclick="setInventoryFilter('feet')" class="inv-filter-btn py-2 rounded-xl border">è¶³</button>
                    <button data-inv-filter="accessory" onclick="setInventoryFilter('accessory')" class="inv-filter-btn py-2 rounded-xl border col-span-3">è£…é£¾å“</button>
                    <button data-inv-filter="potion" onclick="setInventoryFilter('potion')" class="inv-filter-btn py-2 rounded-xl border col-span-3">è–¬</button>
                </div>
            </div>
        </section>

        <!-- LOG PAGE -->
        <section id="page-log" class="page p-4 bg-slate-900 text-slate-300 font-mono text-[10px]">
            <h2 class="text-slate-500 border-b border-slate-800 pb-2 mb-2 uppercase tracking-widest font-black">System History Log</h2>
            <div id="full-log-container" class="flex-1 overflow-y-auto space-y-1"></div>
        </section>

        <!-- HELP PAGE -->
        <section id="page-help" class="page p-4 bg-slate-50">
            <div class="flex items-start justify-between mb-4 px-2">
                <h2 class="text-xl font-black flex items-center gap-2"><i class="fas fa-circle-question"></i> ãƒ˜ãƒ«ãƒ—</h2>
            </div>
            <div class="bg-white rounded-3xl p-6 shadow-sm space-y-4">
                <div>

            <p class="text-[10px] text-slate-500 mt-2">
              ã„ã¤ã‚‚éŠã‚“ã§ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚
            </p>
         </div>
               
                <div class="space-y-4 text-sm">

                    <div class="rounded-2xl border border-slate-100 bg-slate-50 p-4 space-y-2">
                        <div class="text-[10px] font-black text-slate-400 uppercase tracking-widest">è£…å‚™å¼·åŒ–</div>
                        <ul class="text-xs text-slate-500 space-y-1">
                            <li>å¯¾è±¡: ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»¥å¤–ã®è£…å‚™å“ï¼ˆæ­¦å™¨/é˜²å…·/è£…é£¾å“ï¼‰ã€‚</li>
                            <li>æˆåŠŸæ™‚ã¯åŸºç¤ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒå¼·åŒ–å€¤1ã”ã¨ã«+3%å¢—åŠ ï¼ˆæ¬¡ã®å¼·åŒ–å€¤åˆ†ã ã‘åæ˜ ï¼‰ã€‚</li>
                            <li>å¼·åŒ–è²»ç”¨ã¯å¼·åŒ–å€¤ãŒé«˜ã„ã»ã©ä¸Šæ˜‡ã€‚</li>
                            <li>å¤±æ•—ãƒšãƒŠãƒ«ãƒ†ã‚£: +5ã¾ã§å¤‰åŒ–ãªã— / +6ã€œ+9ã¯1ä½ä¸‹ / +10ä»¥ä¸Šã¯ç ´æã—ã¦ä¿®ç†ãŒå¿…è¦ã€‚</li>
                        </ul>
                    </div>
                    
                    <div class="rounded-2xl border border-slate-100 bg-slate-50 p-4 space-y-3">
                        <div class="grid gap-3">
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-emerald-500"><i class="fas fa-arrow-up-long"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">é—˜å¿—</div>
                                    <div class="text-xs text-slate-500">æ”»æ’ƒåŠ›+10%/ã‚¹ã‚¿ãƒƒã‚¯ã€‚æœ€å¤§5ã‚¹ã‚¿ãƒƒã‚¯ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-rose-500"><i class="fas fa-arrow-down-long"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">è¡°å¼±</div>
                                    <div class="text-xs text-slate-500">æ”»æ’ƒåŠ›-10%/ã‚¹ã‚¿ãƒƒã‚¯ã€‚æœ€å¤§5ã‚¹ã‚¿ãƒƒã‚¯ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-sky-500"><i class="fas fa-shield-halved"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">å®ˆå‹¢</div>
                                    <div class="text-xs text-slate-500">é˜²å¾¡åŠ›+12%/ã‚¹ã‚¿ãƒƒã‚¯ã€‚æœ€å¤§4ã‚¹ã‚¿ãƒƒã‚¯ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-amber-500"><i class="fas fa-shield"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">è„†ç”²</div>
                                    <div class="text-xs text-slate-500">é˜²å¾¡åŠ›-12%/ã‚¹ã‚¿ãƒƒã‚¯ã€‚æœ€å¤§4ã‚¹ã‚¿ãƒƒã‚¯ã€‚</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="rounded-2xl border border-slate-100 bg-slate-50 p-4 space-y-3">
                        <div class="grid gap-3">
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-skull-crossbones"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">æ¯’</div>
                                    <div class="text-xs text-slate-500">ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«æœ€å¤§HPä¾å­˜ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-droplet"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">å‡ºè¡€</div>
                                    <div class="text-xs text-slate-500">ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«STRä¾å­˜ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-down-long"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">å¼±ä½“</div>
                                    <div class="text-xs text-slate-500">ä¸ãƒ€ãƒ¡ãƒ¼ã‚¸ä½ä¸‹ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-shield-halved"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">è„†å¼±</div>
                                    <div class="text-xs text-slate-500">è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-arrow-up-long"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">å¼·åŒ–</div>
                                    <div class="text-xs text-slate-500">ä¸ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-snowflake"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">å‡çµ</div>
                                    <div class="text-xs text-slate-500">è¡Œå‹•ä¸èƒ½ã€‚è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã§è§£é™¤ã€‚é€£ç¶šä»˜ä¸ã¯ç¢ºç‡ãŒä¿‚æ•°ã§æ¸›è¡°ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-eye-slash"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">æš—é—‡</div>
                                    <div class="text-xs text-slate-500">å‘½ä¸­ç‡ãƒ»ä¼šå¿ƒç‡ä½ä¸‹ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-hand-sparkles"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">æ²ˆé»™</div>
                                    <div class="text-xs text-slate-500">ã‚¹ã‚­ãƒ«ä½¿ç”¨ä¸å¯ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-person-running"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">è¿…é€Ÿ</div>
                                    <div class="text-xs text-slate-500">å‘½ä¸­ç‡ãƒ»å›é¿ç‡ä¸Šæ˜‡ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-layer-group"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">ãƒãƒªã‚¢</div>
                                    <div class="text-xs text-slate-500">ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸€å®šé‡å¸åã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-retweet"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">åå°„</div>
                                    <div class="text-xs text-slate-500">è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã®ä¸€éƒ¨ã‚’åå°„ã€‚</div>
                                </div>
                            </div>
                            <div class="flex items-start gap-3 rounded-xl border border-slate-100 bg-white p-3">
                                <div class="w-9 h-9 rounded-xl bg-slate-50 flex items-center justify-center text-slate-500"><i class="fas fa-user-slash"></i></div>
                                <div>
                                    <div class="font-black text-slate-700">æŒ‘ç™º</div>
                                    <div class="text-xs text-slate-500">è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ ãƒ»å›é¿ç‡ä½ä¸‹ã€‚</div>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </section>

        <!-- FEEDBACK PAGE -->
        <section id="page-feedback" class="page p-4 bg-slate-50 flex-col gap-3">
            <div class="flex items-start justify-between px-2">
                <h2 class="text-xl font-black flex items-center gap-2"><i class="fas fa-comment-dots"></i> æ„Ÿæƒ³ãƒ»è¦æœ›</h2>
            </div>
            <div class="bg-white rounded-3xl p-3 shadow-sm flex-1 min-h-0">
                <iframe class="feedback-embed" src="https://docs.google.com/forms/d/e/1FAIpQLSehb6HL2A69toW9cmKpbNiUYmkd8FCZRXImFKVzzcPbPwu2sw/viewform?embedded=true" frameborder="0" marginheight="0" marginwidth="0">èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™â€¦</iframe>
            </div>
        </section>

    </main>

    <!-- BOTTOM NAV -->
    <div id="bottom-menu-backdrop" class="fixed inset-0 z-[45] hidden" aria-hidden="true"></div>
    <div id="bottom-menu-panel" class="fixed left-1/2 -translate-x-1/2 bottom-20 z-[60] hidden" style="width: min(420px, calc(100% - 2rem));">
        <div class="bg-white border border-slate-200 rounded-2xl shadow-2xl px-3 py-3">
            <div class="grid grid-cols-5 gap-2 text-[10px] font-black text-slate-700">
                <button onclick="openBottomMenuDonate()" class="flex flex-col items-center justify-center gap-1 rounded-xl border border-slate-200 bg-slate-50 py-2 active:scale-95 transition-transform">
                    <i class="fas fa-mug-hot text-base text-slate-500"></i>
                    å¿œæ´
                </button>
                <button onclick="openBottomMenuSave()" class="flex flex-col items-center justify-center gap-1 rounded-xl border border-slate-200 bg-slate-50 py-2 active:scale-95 transition-transform">
                    <i class="fas fa-floppy-disk text-base text-slate-500"></i>
                    ã‚»ãƒ¼ãƒ–
                </button>
                <button onclick="openBottomMenuHelp()" class="flex flex-col items-center justify-center gap-1 rounded-xl border border-slate-200 bg-slate-50 py-2 active:scale-95 transition-transform">
                    <i class="fas fa-circle-question text-base text-slate-500"></i>
                    ãƒ˜ãƒ«ãƒ—
                </button>
                <button onclick="openBottomMenuTweet(event)" class="flex flex-col items-center justify-center gap-1 rounded-xl border border-slate-200 bg-slate-50 py-2 active:scale-95 transition-transform">
                    <i class="fa-brands fa-twitter text-base text-slate-500"></i>
                    ãƒ„ã‚¤ãƒ¼ãƒˆ
                </button>
                <button onclick="openBottomMenuFeedback()" class="flex flex-col items-center justify-center gap-1 rounded-xl border border-slate-200 bg-slate-50 py-2 active:scale-95 transition-transform">
                    <i class="fas fa-comment-dots text-base text-slate-500"></i>
                    æ„Ÿæƒ³ãƒ»è¦æœ›
                </button>
            </div>
        </div>
    </div>
    <nav class="h-16 border-t bg-white grid grid-cols-6 shrink-0 items-center pb-1 z-50 relative shadow-[0_-2px_10px_rgba(0,0,0,0.05)]">
        <button onclick="switchPage('battle')" id="nav-battle" class="flex-1 h-full flex flex-col items-center justify-center gap-1 text-slate-300 transition-all">
            <i class="fas fa-hand-fist text-xl"></i><span class="text-[9px] font-black">æˆ¦é—˜</span>
        </button>
        <button onclick="switchPage('status')" id="nav-status" class="flex-1 h-full flex flex-col items-center justify-center gap-1 text-slate-300 transition-all">
            <i class="fas fa-user-circle text-xl"></i><span class="text-[9px] font-black">èƒ½åŠ›</span>
        </button>
        <button onclick="switchPage('skill')" id="nav-skill" class="flex-1 h-full flex flex-col items-center justify-center gap-1 text-slate-300 transition-all relative">
            <i class="fas fa-star text-xl"></i><span class="text-[9px] font-black">ã‚¹ã‚­ãƒ«</span>
            <div id="nav-sp-dot" class="absolute top-3 right-6 w-2 h-2 bg-amber-500 rounded-full border-2 border-white hidden"></div>
        </button>
        <button onclick="switchPage('inventory')" id="nav-inventory" class="flex-1 h-full flex flex-col items-center justify-center gap-1 text-slate-300 transition-all relative">
            <i class="fas fa-box-open text-xl"></i><span class="text-[9px] font-black">è£…å‚™</span>
        </button>
        <button onclick="switchPage('log')" id="nav-log" class="flex-1 h-full flex flex-col items-center justify-center gap-1 text-slate-300 transition-all">
            <i class="fas fa-scroll text-xl"></i><span class="text-[9px] font-black">å±¥æ­´</span>
        </button>
        <button onclick="toggleBottomMenu()" id="nav-help" aria-controls="bottom-menu-panel" aria-expanded="false" class="flex-1 h-full flex flex-col items-center justify-center gap-1 text-slate-300 transition-all">
            <i class="fas fa-bars text-xl"></i><span class="text-[9px] font-black">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</span>
        </button>
        <button id="nav-save" class="hidden" aria-hidden="true" tabindex="-1"></button>
    </nav>

    <!-- LOOT MODAL -->
    <div id="loot-modal" class="fixed inset-0 bg-slate-900/80 z-[100] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-xs rounded-[2rem] overflow-hidden shadow-2xl transform scale-100 p-8 text-center border-b-8 border-slate-200">
            <div class="text-6xl mb-6">ğŸ“¦</div>
            <h3 class="font-black text-xl mb-2">æˆ¦åˆ©å“ã‚’ç™ºè¦‹ï¼</h3>
            <div id="loot-display" class="bg-slate-50 rounded-2xl p-6 my-4 border border-slate-100"></div>
            <div class="flex gap-3">
                <button onclick="closeLoot(false)" class="flex-1 py-4 text-sm font-bold text-slate-400 bg-slate-100 rounded-2xl">æ¨ã¦ã‚‹</button>
                <button onclick="closeLoot(true)" class="flex-1 py-4 text-sm font-bold text-white bg-slate-800 rounded-2xl shadow-lg">æ‹¾ã†</button>
            </div>
        </div>
    </div>

    <!-- LOOT FILTER MODAL -->
    <div id="loot-filter-modal" class="fixed inset-0 bg-slate-900/80 z-[105] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-slate-200">
            <div class="flex items-center justify-between mb-4">
                <h3 class="font-black text-lg text-slate-800 flex items-center gap-2">
                    <i class="fas fa-filter text-slate-500"></i> å–å¾—ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                </h3>
                <button id="loot-filter-close" class="text-slate-400 hover:text-slate-700 text-lg"><i class="fas fa-xmark"></i></button>
            </div>
            <p class="text-xs text-slate-500 mb-4">ãƒã‚§ãƒƒã‚¯ã—ãŸãƒ¬ã‚¢åº¦ã¯æ‹¾ã‚ãšã€å‰Šé™¤æ‰±ã„ã«ã—ã¾ã™ã€‚</p>
            <div class="space-y-2 text-sm">
                <label class="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-xl px-3 py-2">
                    <span class="flex items-center gap-2 font-bold rarity-normal">
                        <input type="checkbox" class="loot-filter-checkbox accent-slate-800" data-rarity="normal">
                        ãƒãƒ¼ãƒãƒ«
                    </span>
                    <span class="text-[10px] text-slate-400 font-bold">æ‹¾ã‚ãªã„</span>
                </label>
                <label class="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-xl px-3 py-2">
                    <span class="flex items-center gap-2 font-bold rarity-magic">
                        <input type="checkbox" class="loot-filter-checkbox accent-slate-800" data-rarity="magic">
                        ãƒã‚¸ãƒƒã‚¯
                    </span>
                    <span class="text-[10px] text-slate-400 font-bold">æ‹¾ã‚ãªã„</span>
                </label>
                <label class="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-xl px-3 py-2">
                    <span class="flex items-center gap-2 font-bold rarity-rare">
                        <input type="checkbox" class="loot-filter-checkbox accent-slate-800" data-rarity="rare">
                        ãƒ¬ã‚¢
                    </span>
                    <span class="text-[10px] text-slate-400 font-bold">æ‹¾ã‚ãªã„</span>
                </label>
                <label class="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-xl px-3 py-2">
                    <span class="flex items-center gap-2 font-bold rarity-epic">
                        <input type="checkbox" class="loot-filter-checkbox accent-slate-800" data-rarity="epic">
                        ã‚¨ãƒ”ãƒƒã‚¯
                    </span>
                    <span class="text-[10px] text-slate-400 font-bold">æ‹¾ã‚ãªã„</span>
                </label>
                <label class="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-xl px-3 py-2">
                    <span class="flex items-center gap-2 font-bold rarity-legendary">
                        <input type="checkbox" class="loot-filter-checkbox accent-slate-800" data-rarity="legendary">
                        ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼
                    </span>
                    <span class="text-[10px] text-slate-400 font-bold">æ‹¾ã‚ãªã„</span>
                </label>
            </div>
            <button id="loot-filter-close-bottom" class="mt-5 w-full bg-slate-800 text-white font-black py-3 rounded-2xl shadow-lg">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <!-- BULK SELL MODAL -->
    <div id="bulk-sell-modal" class="fixed inset-0 bg-slate-900/80 z-[106] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-amber-100">
            <div class="flex items-center justify-between mb-4">
                <h3 class="font-black text-lg text-slate-800 flex items-center gap-2">
                    <i class="fas fa-sack-dollar text-amber-500"></i> ä¸€æ‹¬å£²å´
                </h3>
                <button id="bulk-sell-close" class="text-slate-400 hover:text-slate-700 text-lg"><i class="fas fa-xmark"></i></button>
            </div>
            <p class="text-xs text-slate-500 mb-4">å£²ã‚ŠãŸã„ãƒ¬ã‚¢åº¦ã‚’è¤‡æ•°é¸æŠã—ã¦ã€ä¸€æ‹¬ã§å£²å´ã—ã¾ã™ã€‚</p>
            <div class="space-y-2 text-sm">
                <label class="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-xl px-3 py-2">
                    <span class="flex items-center gap-2 font-bold rarity-normal">
                        <input type="checkbox" class="bulk-sell-checkbox accent-amber-500" data-rarity="normal">
                        ãƒãƒ¼ãƒãƒ«
                    </span>
                </label>
                <label class="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-xl px-3 py-2">
                    <span class="flex items-center gap-2 font-bold rarity-magic">
                        <input type="checkbox" class="bulk-sell-checkbox accent-amber-500" data-rarity="magic">
                        ãƒã‚¸ãƒƒã‚¯
                    </span>
                </label>
                <label class="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-xl px-3 py-2">
                    <span class="flex items-center gap-2 font-bold rarity-rare">
                        <input type="checkbox" class="bulk-sell-checkbox accent-amber-500" data-rarity="rare">
                        ãƒ¬ã‚¢
                    </span>
                </label>
                <label class="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-xl px-3 py-2">
                    <span class="flex items-center gap-2 font-bold rarity-epic">
                        <input type="checkbox" class="bulk-sell-checkbox accent-amber-500" data-rarity="epic">
                        ã‚¨ãƒ”ãƒƒã‚¯
                    </span>
                </label>
                <label class="flex items-center justify-between bg-slate-50 border border-slate-100 rounded-xl px-3 py-2">
                    <span class="flex items-center gap-2 font-bold rarity-legendary">
                        <input type="checkbox" class="bulk-sell-checkbox accent-amber-500" data-rarity="legendary">
                        ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼
                    </span>
                </label>
            </div>
            <div class="mt-5 space-y-2">
                <button id="bulk-sell-confirm" class="w-full bg-amber-500 text-white font-black py-3 rounded-2xl shadow-lg">å£²å´ï¼</button>
                <button id="bulk-sell-close-bottom" class="w-full bg-slate-100 text-slate-500 font-black py-3 rounded-2xl shadow">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>

    <!-- EQUIP SLOT MODAL -->
    <div id="equip-slot-modal" class="fixed inset-0 bg-slate-900/80 z-[108] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-slate-200">
            <div class="flex items-center justify-between mb-4">
                <h3 id="equip-slot-title" class="font-black text-lg text-slate-800 flex items-center gap-2"></h3>
                <button id="equip-slot-close" class="text-slate-400 hover:text-slate-700 text-lg"><i class="fas fa-xmark"></i></button>
            </div>
            <div class="space-y-3">
                <div class="rounded-2xl border border-slate-200 bg-slate-50 p-3 space-y-2">
                    <div id="equip-slot-1-label" class="flex items-center justify-between text-[11px] font-black text-slate-600"></div>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="equip-slot-1" class="w-full bg-slate-800 text-white font-black py-2 rounded-2xl shadow-lg text-[11px] flex items-center justify-center gap-2">
                            <i class="fas fa-shield"></i>è£…å‚™
                        </button>
                        <button id="equip-slot-1-compare" class="w-full bg-white border border-slate-200 text-slate-600 font-black py-2 rounded-2xl shadow text-[11px] flex items-center justify-center gap-2">
                            <i class="fas fa-scale-balanced"></i>æ¯”è¼ƒ
                        </button>
                    </div>
                </div>
                <div class="rounded-2xl border border-slate-200 bg-slate-50 p-3 space-y-2">
                    <div id="equip-slot-2-label" class="flex items-center justify-between text-[11px] font-black text-slate-600"></div>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="equip-slot-2" class="w-full bg-slate-800 text-white font-black py-2 rounded-2xl shadow-lg text-[11px] flex items-center justify-center gap-2">
                            <i class="fas fa-shield"></i>è£…å‚™
                        </button>
                        <button id="equip-slot-2-compare" class="w-full bg-white border border-slate-200 text-slate-600 font-black py-2 rounded-2xl shadow text-[11px] flex items-center justify-center gap-2">
                            <i class="fas fa-scale-balanced"></i>æ¯”è¼ƒ
                        </button>
                    </div>
                </div>
            </div>
            <button id="equip-slot-close-bottom" class="mt-5 w-full bg-slate-100 text-slate-500 font-black py-3 rounded-2xl shadow">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
    </div>

    <!-- COMPARE MODAL -->
    <div id="compare-modal" class="fixed inset-0 bg-slate-900/80 z-[112] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-emerald-100">
            <div class="flex items-center justify-between mb-3">
                <h3 class="font-black text-lg text-slate-800 flex items-center gap-2"><i class="fas fa-scale-balanced"></i> è£…å‚™æ¯”è¼ƒ</h3>
                <button id="compare-modal-close" class="text-slate-400 hover:text-slate-700 text-lg"><i class="fas fa-xmark"></i></button>
            </div>
            <div class="text-[11px] text-slate-500 font-bold flex items-center justify-between gap-2">
                <div class="flex-1 min-w-0">
                    <div class="text-[9px] text-slate-400 uppercase tracking-widest">ç¾åœ¨è£…å‚™</div>
                    <div id="compare-modal-equipped" class="text-slate-700 font-black truncate"></div>
                </div>
                <div class="flex-1 min-w-0 text-right">
                    <div class="text-[9px] text-slate-400 uppercase tracking-widest">å€™è£œè£…å‚™</div>
                    <div id="compare-modal-candidate" class="text-slate-800 font-black truncate"></div>
                </div>
            </div>
            <div class="mt-4 space-y-3">
                <div>
                    <div class="text-[10px] font-black text-emerald-500 uppercase tracking-widest">å¢—åŠ </div>
                    <div id="compare-modal-increase" class="mt-1 space-y-1"></div>
                </div>
                <div>
                    <div class="text-[10px] font-black text-rose-500 uppercase tracking-widest">æ¸›å°‘</div>
                    <div id="compare-modal-decrease" class="mt-1 space-y-1"></div>
                </div>
            </div>
            <div class="mt-4 space-y-2">
                <button id="compare-modal-equip" class="w-full bg-slate-800 text-white font-black py-3 rounded-2xl shadow-lg flex items-center justify-center gap-2">
                    <i class="fas fa-shield"></i>è£…å‚™ã™ã‚‹
                </button>
                <button id="compare-modal-close-bottom" class="w-full bg-slate-100 text-slate-500 font-black py-3 rounded-2xl shadow">é–‰ã˜ã‚‹</button>
            </div>
        </div>
    </div>

    <!-- BOSS RUSH MODAL -->
    <div id="bossrush-modal" class="fixed inset-0 bg-slate-900/80 z-[120] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-slate-200">
            <div class="flex items-center justify-between mb-4">
                <h3 class="font-black text-lg text-slate-800 flex items-center gap-2"><i class="fas fa-flag-checkered"></i> ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥è§£æ”¾</h3>
                <button id="bossrush-modal-close" class="text-slate-400 hover:text-slate-700 text-lg"><i class="fas fa-xmark"></i></button>
            </div>
            <div class="space-y-3 text-xs text-slate-600 leading-relaxed">
                <p class="font-bold text-slate-700">5001éšã‹ã‚‰ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥ãŒé–‹å§‹ã•ã‚Œã¾ã™ã€‚ãƒ‡ã‚¸ãƒ£ãƒ´ã¨ãƒ‘ãƒ©ãƒ¬ãƒ«ãŒäº¤å·®ã™ã‚‹éšå±¤ã§ã€5000éšã®æ§‹æˆãŒåˆ¥ã®å¯èƒ½æ€§ã¨ã—ã¦å†ç¾ã•ã‚Œã¾ã™ã€‚</p>
                <ul class="space-y-2">
                    <li>ãƒ»å‡ºç¾ãƒœã‚¹ã¯ã“ã‚Œã¾ã§ã®ãƒœã‚¹ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ æŠ½é¸</li>
                    <li>ãƒ»ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¯å¤§å¹…ã«å¼·åŒ–ã€éšæ•°ã‚’é€²ã‚€ã»ã©å¼·ããªã‚Šã¾ã™</li>
                    <li>ãƒ»ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥ä¸­ã¯ãƒãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœãŒåŠæ¸›ã—ã¾ã™</li>
                    <li>ãƒ»ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥é–‹å§‹å¾Œã¯50éšã”ã¨ã«å¼·åŒ–ãƒãƒ•ãŒè¿½åŠ ã•ã‚Œã¾ã™</li>
                    <li>ãƒ»ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥ä¸­ã¯ãƒ‰ãƒ­ãƒƒãƒ—ãªã—ã®ã‚¨ãƒ³ãƒ‰ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã§ã™</li>
                </ul>
            </div>
            <button id="bossrush-modal-ok" class="mt-4 w-full bg-slate-800 text-white font-black py-3 rounded-2xl shadow-lg">äº†è§£</button>
        </div>
    </div>

    <!-- CONFIRM MODAL -->
    <div id="confirm-modal" class="fixed inset-0 bg-slate-900/80 z-[125] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-rose-100 text-center space-y-4">
            <div class="text-rose-500 text-3xl"><i class="fas fa-triangle-exclamation"></i></div>
            <h3 class="text-base font-black text-slate-800">ç¢ºèª</h3>
            <p id="confirm-modal-message" class="text-xs text-slate-500"></p>
            <div class="grid grid-cols-2 gap-3 pt-2">
                <button id="confirm-modal-cancel" class="py-2 rounded-xl bg-slate-100 text-slate-600 text-[10px] font-black">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button id="confirm-modal-ok" class="py-2 rounded-xl bg-rose-500 text-white text-[10px] font-black hover:bg-rose-600 transition">å®Ÿè¡Œ</button>
            </div>
        </div>
    </div>

    <!-- ENHANCE MODAL -->
    <div id="enhance-modal" class="fixed inset-0 bg-slate-900/80 z-[130] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-slate-200">
            <div class="flex items-center justify-between mb-4">
                <h3 id="enhance-modal-title" class="font-black text-lg text-slate-800 flex items-center gap-2"></h3>
                <button id="enhance-modal-close" class="text-slate-400 hover:text-slate-700 text-lg"><i class="fas fa-xmark"></i></button>
            </div>
            <div id="enhance-modal-info" class="space-y-2 text-xs text-slate-600">
                <div class="flex items-center justify-between">
                    <span class="font-bold text-slate-500">ç¾åœ¨ã®å¼·åŒ–å€¤</span>
                    <span id="enhance-modal-level" class="font-black text-slate-700"></span>
                </div>
                <div class="flex items-center justify-between">
                    <span class="font-bold text-slate-500">å¼·åŒ–è²»ç”¨</span>
                    <span id="enhance-modal-cost" class="font-black text-slate-700"></span>
                </div>
                <div class="flex items-center justify-between">
                    <span class="font-bold text-slate-500">æˆåŠŸæ™‚ã‚¢ãƒƒãƒ—è¦‹è¾¼ã¿</span>
                    <span id="enhance-modal-preview" class="font-black text-emerald-600"></span>
                </div>
                <div id="enhance-modal-warning" class="text-[10px] text-rose-500 font-bold"></div>
            </div>
            <button id="enhance-modal-start" class="mt-4 w-full bg-slate-800 text-white font-black py-3 rounded-2xl shadow-lg">å¼·åŒ–</button>
            <div id="enhance-modal-progress" class="hidden mt-6 text-center space-y-3">
                <div class="w-16 h-16 mx-auto rounded-2xl bg-slate-100 flex items-center justify-center text-slate-600 enhance-rattle">
                    <i class="fas fa-hammer text-2xl"></i>
                </div>
                <div class="font-black text-slate-700">é›å†¶ä¸­...</div>
                <div class="text-[10px] text-slate-400">ã‚¿ãƒƒãƒ—ã§ã‚¹ã‚­ãƒƒãƒ—</div>
            </div>
            <div id="enhance-modal-result" class="hidden mt-6 text-center space-y-3">
                <div id="enhance-modal-result-icon" class="w-16 h-16 mx-auto rounded-2xl bg-slate-100 flex items-center justify-center text-2xl"></div>
                <div id="enhance-modal-result-title" class="font-black text-lg"></div>
                <div id="enhance-modal-result-detail" class="text-xs font-bold text-slate-600"></div>
                <div id="enhance-modal-result-extra" class="text-[10px] text-slate-400"></div>
                <button id="enhance-modal-repeat" class="w-full bg-slate-800 text-white font-black py-2.5 rounded-xl shadow flex items-center justify-center gap-2">
                    <i class="fas fa-hammer"></i>
                    <span>å¼·åŒ–ã™ã‚‹</span>
                </button>
                <div class="text-[10px] text-slate-400">ã‚¿ãƒƒãƒ—ã§é–‰ã˜ã‚‹</div>
            </div>
        </div>
    </div>

    <!-- STATUS INFO MODAL -->
    <div id="status-info-modal" class="fixed inset-0 bg-slate-900/80 z-[110] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-md rounded-[2rem] overflow-x-hidden overflow-y-auto max-h-[calc(100dvh-3rem)] no-scrollbar shadow-2xl p-6 border-b-8 border-slate-200">
            <div class="flex items-center justify-between mb-4">
                <h3 class="font-black text-lg text-slate-800 flex items-center gap-2">
                    <i class="fas fa-circle-info text-slate-500"></i> ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒ¢
                </h3>
                <button id="status-info-close" class="text-slate-400 hover:text-slate-700 text-lg"><i class="fas fa-xmark"></i></button>
            </div>
            <div class="space-y-4 text-xs text-slate-600">
                <div>
                    <div class="text-[10px] font-black text-slate-400 uppercase">Primary</div>
                    <ul class="mt-2 space-y-1">
                        <li><span class="font-bold text-slate-700">STR</span>ï¼šç‰©ç†æ”»æ’ƒã®åŸºç¤å€¤ã€‚æ­¦å™¨ã®ATKã¨åˆç®—ã•ã‚Œã¾ã™ã€‚</li>
                        <li><span class="font-bold text-slate-700">VIT</span>ï¼šè¢«ãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›ã®åŸºç¤å€¤ã€‚é˜²å…·DEFã¨åˆç®—ã•ã‚Œã¾ã™ã€‚</li>
                        <li><span class="font-bold text-slate-700">INT</span>ï¼šé­”æ³•æ”»æ’ƒã®åŸºç¤å€¤ã€‚å›å¾©é‡ã«ã‚‚å½±éŸ¿ã€‚</li>
                        <li><span class="font-bold text-slate-700">DEX</span>ï¼šå™¨ç”¨ã•ã®åŸºç¤å€¤ã€‚è£…å‚™å³é¸ã®ç›®å®‰ã«åˆ©ç”¨ã€‚</li>
                        <li><span class="font-bold text-slate-700">LUK</span>ï¼šé‹ã®åŸºç¤å€¤ã€‚è¿½åŠ çµŒé¨“å€¤ãƒ»ãƒ‰ãƒ­ãƒƒãƒ—ç‡ãƒ»ãƒ¬ã‚¢ãƒ‰ãƒ­ç‡ãƒ»Affixç‡ãƒ»ã‚¨ãƒªãƒ¼ãƒˆé­é‡ç‡ãƒ»ã‚´ãƒ¼ãƒ«ãƒ‰å¢—åŠ ç‡ã«å½±éŸ¿ã€‚</li>
                    </ul>
                </div>
                <div>
                    <div class="text-[10px] font-black text-slate-400 uppercase">Secondary</div>
                    <ul class="mt-2 space-y-1">
                        <li>æœ€å¤§HPï¼šHPã‚’å›ºå®šå€¤ã§å¢—åŠ ã€‚</li>
                        <li>æœ€å¤§MPï¼šMPã‚’å›ºå®šå€¤ã§å¢—åŠ ã€‚</li>
                        <li>HPè‡ªå‹•å›å¾©ï¼šã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã«HPãŒå›å¾©ã€‚</li>
                        <li>MPè‡ªå‹•å›å¾©ï¼šã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã«MPãŒå›å¾©ã€‚</li>
                        <li>æ”»æ’ƒåŠ›ï¼šç‰©ç†æ”»æ’ƒã®å›ºå®šå¢—åŠ ã€‚</li>
                        <li>é˜²å¾¡åŠ›ï¼šé˜²å¾¡ã®å›ºå®šå¢—åŠ ã€‚</li>
                        <li>å‘½ä¸­ç‡ï¼šæ”»æ’ƒãŒå‘½ä¸­ã™ã‚‹ç¢ºç‡ã€‚</li>
                        <li>ä¼šå¿ƒç‡ï¼šã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãŒç™ºç”Ÿã™ã‚‹ç¢ºç‡ã€‚</li>
                        <li>ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸ï¼šä¼šå¿ƒæ™‚ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å€ç‡ã€‚</li>
                        <li>ä¸ãƒ€ãƒ¡å¢—åŠ ï¼šé€šå¸¸æ”»æ’ƒãƒ»ã‚¹ã‚­ãƒ«å…¨ä½“ã®ä¸ãƒ€ãƒ¡è£œæ­£ã€‚</li>
                        <li>è¢«ãƒ€ãƒ¡è»½æ¸›ï¼šæ•µæ”»æ’ƒã®æœ€çµ‚ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è»½æ¸›ã€‚</li>
                        <li>å›é¿ç‡ï¼šæ•µã®æ”»æ’ƒã‚’å›é¿ã™ã‚‹ç¢ºç‡ã€‚</li>
                        <li>å¸è¡€ç‡ï¼šä¸ãˆãŸãƒ€ãƒ¡ãƒ¼ã‚¸ã®ä¸€éƒ¨ã‚’HPå›å¾©ã€‚</li>
                        <li>é­”æ³•è²«é€šï¼šæ•µã®é˜²å¾¡ã‚’ç„¡è¦–ã™ã‚‹å‰²åˆï¼ˆé­”æ³•ç³»ã‚¹ã‚­ãƒ«å‘ã‘ï¼‰ã€‚</li>
                        <li>è¿½åŠ çµŒé¨“å€¤ï¼šç²å¾—çµŒé¨“å€¤ã®å¢—åŠ ç‡ã€‚</li>
                        <li>ãƒ‰ãƒ­ãƒƒãƒ—ç‡ï¼šæˆ¦åˆ©å“ãŒå‡ºã‚‹ç¢ºç‡ã®ä¸Šæ˜‡ã€‚</li>
                        <li>ãƒ¬ã‚¢ãƒ‰ãƒ­ç‡ï¼šãƒ‰ãƒ­ãƒƒãƒ—å“ã®ãƒ¬ã‚¢åº¦ä¸Šæ˜‡ç¢ºç‡ã€‚</li>
                        <li>Affixç‡ï¼šè£…å‚™ã«AffixãŒä»˜ä¸ã•ã‚Œã‚‹ç¢ºç‡ã¨ãƒ©ãƒ³ã‚¯ä¸Šæ˜‡ç‡ã€‚</li>
                        <li>ã‚¨ãƒªãƒ¼ãƒˆé­é‡ç‡ï¼šã‚¨ãƒªãƒ¼ãƒˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®å‡ºç¾ç‡ãŒä¸Šæ˜‡ã€‚</li>
                        <li>ã‚´ãƒ¼ãƒ«ãƒ‰å¢—åŠ ç‡ï¼šç²å¾—ã‚´ãƒ¼ãƒ«ãƒ‰ã®å¢—åŠ ç‡ã€‚</li>
                    </ul>
                </div>
            </div>
            <button id="status-info-close-bottom" class="mt-5 w-full bg-slate-800 text-white font-black py-3 rounded-2xl shadow-lg">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <!-- STATUS EFFECT MODAL -->
    <div id="status-effect-modal" class="fixed inset-0 bg-slate-900/80 z-[120] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-slate-200">
            <div class="flex items-center justify-between mb-4">
                <h3 id="status-effect-title" class="font-black text-lg text-slate-800 flex items-center gap-2"></h3>
                <button id="status-effect-close" class="text-slate-400 hover:text-slate-700 text-lg"><i class="fas fa-xmark"></i></button>
            </div>
            <p id="status-effect-desc" class="text-xs text-slate-600"></p>
            <div class="mt-4 flex items-center justify-between text-xs text-slate-500">
                <span id="status-effect-stacks"></span>
                <span id="status-effect-turns"></span>
            </div>
            <button id="status-effect-close-bottom" class="mt-5 w-full bg-slate-800 text-white font-black py-3 rounded-2xl shadow-lg">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <!-- SKILL DETAIL MODAL -->
    <div id="skill-detail-modal" class="fixed inset-0 bg-slate-900/80 z-[120] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-slate-200">
            <div class="flex items-center justify-between mb-4">
                <h3 id="skill-detail-title" class="font-black text-lg text-slate-800 flex items-center gap-2"></h3>
                <button id="skill-detail-close" class="text-slate-400 hover:text-slate-700 text-lg"><i class="fas fa-xmark"></i></button>
            </div>
            <div id="skill-detail-meta" class="text-[10px] text-slate-500 font-bold mb-2"></div>
            <p id="skill-detail-desc" class="text-xs text-slate-600"></p>
            <div id="skill-detail-stats" class="mt-4 space-y-1 text-[10px] text-slate-500 font-bold"></div>
            <div class="mt-4">
                <div class="text-[10px] text-slate-400 font-black mb-1">è¿½åŠ åŠ¹æœ</div>
                <div id="skill-detail-effects" class="space-y-1 text-[10px] text-slate-500 font-bold"></div>
            </div>
            <div class="mt-4">
                <div class="text-[10px] text-slate-400 font-black mb-1">ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³</div>
                <div id="skill-detail-milestones" class="space-y-1 text-[10px] text-slate-500 font-bold"></div>
            </div>
            <button id="skill-detail-close-bottom" class="mt-5 w-full bg-slate-800 text-white font-black py-3 rounded-2xl shadow-lg">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <!-- WARP MODAL -->
    <div id="warp-modal" class="fixed inset-0 bg-slate-900/80 z-[115] hidden items-center justify-center p-6 backdrop-blur-sm">
        <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-slate-200">
            <div class="flex items-center justify-between mb-4">
                <h3 class="font-black text-lg text-slate-800 flex items-center gap-2"><i class="fas fa-location-arrow"></i> ãƒ¯ãƒ¼ãƒ—</h3>
                <button id="warp-close" class="text-slate-400 hover:text-slate-700 text-lg"><i class="fas fa-xmark"></i></button>
            </div>
            <div class="text-[10px] text-slate-400 font-bold">æœ€é«˜åˆ°é”éšæ•°: <span id="warp-max-floor">1</span>F</div>
            <div class="mt-3 flex items-center gap-2">
                <input id="warp-input" type="number" min="1" inputmode="numeric" class="flex-1 border border-slate-200 rounded-xl px-3 py-2 text-sm font-bold text-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-400" placeholder="éšæ•°">
                <button id="warp-confirm" class="bg-slate-800 text-white text-xs font-black px-4 py-2 rounded-xl shadow hover:bg-slate-700 active:scale-95 transition">
                    ãƒ¯ãƒ¼ãƒ—
                </button>
            </div>

            <button id="warp-bossrush-enter" class="mt-3 w-full bg-rose-600 text-white text-xs font-black py-2 rounded-xl hover:bg-rose-500 transition flex items-center justify-center gap-2">
                <i class="fas fa-flag-checkered"></i> ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥å…¥å ´
            </button>
            <button id="warp-bossrush-info" class="mt-3 hidden w-full bg-amber-100 text-amber-700 text-xs font-black py-2 rounded-xl hover:bg-amber-200 transition">
                ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥ä»•æ§˜ã‚’è¦‹ã‚‹
            </button>
            <div class="mt-4">
                <div class="text-[10px] text-slate-400 font-black mb-2">è¨ä¼æ¸ˆã¿ãƒœã‚¹</div>
                <div id="warp-boss-empty" class="text-[10px] text-slate-400 hidden">è¨ä¼ã—ãŸãƒœã‚¹ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>
                <div id="warp-boss-buttons" class="grid grid-cols-3 gap-2"></div>
            </div>
            <div class="mt-4">
                <div class="text-[10px] text-slate-400 font-black mb-2">ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥ãƒ»ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³</div>
                <div id="warp-bossrush-empty" class="text-[10px] text-slate-400 hidden">ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã®ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>
                <div id="warp-bossrush-buttons" class="grid grid-cols-3 gap-2"></div>
            </div>
        </div>
    </div>

    <!-- DONATE MODAL -->
    <div id="donate-modal" class="fixed inset-0 bg-slate-900/80 z-[120] hidden items-center justify-center p-6 backdrop-blur-sm">
      <div class="bg-white w-full max-w-sm rounded-[2rem] overflow-hidden shadow-2xl p-6 border-b-8 border-amber-200">
        <div class="flex items-center justify-between mb-4">
          <h3 class="font-black text-lg text-slate-800 flex items-center gap-2">
            <i class="fas fa-heart text-rose-500"></i> å¿œæ´
          </h3>
          <button class="text-slate-400 hover:text-slate-700 text-lg" onclick="closeDonateModal()">
            <i class="fas fa-xmark"></i>
          </button>
        </div>
    
        <div class="text-[11px] text-slate-600 font-bold mb-4">
          æ°—ãŒå‘ã„ãŸã‚‰ã§å¤§ä¸ˆå¤«ã§ã™ã€‚é–‹ç™ºã®åŠ±ã¿ã«ãªã‚Šã¾ã™ã€‚
        </div>
    
        <div class="space-y-3">
          <button class="w-full bg-white text-slate-900 border border-slate-900 font-black py-3 rounded-2xl shadow-sm flex items-center justify-center gap-2 hover:bg-slate-100 transition"
            onclick="purchaseTip('tip_100',event)">
            â˜•ï¸ 100å††ï¼ˆã‚³ãƒ¼ãƒ’ãƒ¼ï¼‰
          </button>
    
          <button class="w-full bg-white text-slate-900 border border-slate-900 font-black py-3 rounded-2xl shadow-sm flex items-center justify-center gap-2 hover:bg-slate-100 transition"
            onclick="purchaseTip('tip_300',event)">
            â˜•ï¸ğŸª 300å††ï¼ˆã‚³ãƒ¼ãƒ’ãƒ¼ï¼‹ãŠè“å­ï¼‰
          </button>
    
          <button class="w-full bg-white text-slate-900 font-black rounded-2xl flex items-center justify-center"
            >
            ğŸ”¥ æœ¬å½“ã«å¿œæ´ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™
          </button>
        </div>
    
        <button class="mt-5 w-full bg-slate-100 text-slate-500 font-black py-3 rounded-2xl shadow"
          onclick="closeDonateModal()">
          ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        </button>
      </div>
    </div>
    
    <!-- DONATE TOAST -->
    <div id="donate-toast" class="fixed left-1/2 -translate-x-1/2 bottom-24 z-[130] hidden">
      <div class="bg-white/95 border border-slate-200 shadow-xl rounded-2xl px-4 py-3 text-[12px] font-black text-slate-800">
        <span id="donate-toast-text"></span>
      </div>
    </div>


    <script>
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (e) {
            const now = Date.now();
            const interactiveTarget = e.target.closest('button, a, input, select, textarea, label');
            if (!interactiveTarget && now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });

        // --- DATA STRUCTURE ---
        const Game = {
            floor: 1,
            maxFloor: 1,
            defeatedBossFloors: [],
            defeatedBossRushMilestones: [],
            state: 'idle',
            stayOnFloor: false,
            endMessageShown: false,
            enhanceModal: {
                index: null,
                stage: 'confirm',
                timer: null,
                result: null
            },
            player: {
                level: 1,
                hp: 300, maxHp: 300, baseMaxHp: 300, mp: 40, maxMp: 40, baseMaxMp: 40,
                // Primary Stats
                str: 50, vit: 50, int: 50, dex: 50, luk: 0,
                levelStr: 0, levelVit: 0, levelInt: 0, levelDex: 0,
                // Secondary Stats (calculated)
                maxHpFlat: 0, maxMpFlat: 0,
                attackFlat: 0, defenseFlat: 0,
                hpRegen: 0, mpRegen: 0, goldBoost: 0,
                critRate: 5, evasionRate: 3, leechRate: 0, expBoost: 0, mPen: 0, luck: 50, accuracy: 100,
                critDamage: 200, damageBoost: 0, damageReduction: 0, rareFind: 0, affixFind: 0, eliteEncounter: 0,
                skillPowerBoost: 0, statusEffectStackBonus: 0, statusEffectTurnBonus: 0,
                poisonMaxStacksBonus: 0, poisonMinPctBonus: 0,
                skillMpDiscount: 0, strMultiplier: 0, intMultiplier: 0, vitMultiplier: 0, dexMultiplier: 0, lukMultiplier: 0,
                exp: 0, next: 100, sp: 1,
                gold: 0,
                weapon: null, armor: null, head: null, hands: null, feet: null, accessory1: null, accessory2: null, potion1: null, potion2: null, inventory: [],
                skillSlots: [null, null, null, null],
                skillSlotIndex: 0,
                skillSlotTarget: 0,
                statusEffects: [],
                bossUniqueState: {
                    martyrLight: 0,
                    overkillBank: 0,
                    killOverflowCharge: 0,
                    damageReturnCharge: 0,
                    damageBufferCharge: 0,
                    guardianReturnCharge: 0,
                    defenseLayers: 0,
                    ironWallUsed: false,
                    shadowFirstStrikeUsed: false,
                    lastSkill: null
                },
                skills: {
                    warrior: { active: [0,0,0,0,0,0], passive: [0,0,0,0,0,0] },
                    mage: { active: [0,0,0,0,0,0,0,0,0,0,0,0], passive: [0,0,0,0,0,0] },
                    thief: { active: [0,0,0,0,0,0], passive: [0,0,0,0,0,0] },
                    ranger: { active: [0,0,0,0,0,0,0,0,0,0,0,0], passive: [0,0,0,0,0,0] },
                    paladin: { active: [0,0,0,0,0,0,0,0,0,0,0,0], passive: [0,0,0,0,0,0] },
                    monk: { active: [0,0,0,0,0,0], passive: [0,0,0,0,0,0] }
                }
            },
            currentJobTab: 'warrior',
            currentSkillType: 'active',
            skillPointModeIndex: 0,
            inventoryFilter: 'all',
            inventorySort: 'acquired',
            inventoryCounter: 0,
            lootFilter: { normal: false, magic: false, rare: false, epic: false, legendary: false },
            bulkSellFilter: { normal: false, magic: false, rare: false, epic: false, legendary: false },
            lootQueue: [],
            pendingEquip: null,
            compareModal: null,
            bossRushCarryoverDamage: 0,
            isBossRush: false,
            maxBossRushFloor: 0,
            enemy: null, logs: [], dropLogs: []
        };

        const MAX_LEVEL = Number.MAX_SAFE_INTEGER;
        const LEVEL_UP_SKILL_POINTS = 1;
        const MAX_SKILL_POINTS = Number.MAX_SAFE_INTEGER;
        const FreezeDecayConfig = {
            multiplier: 0.6,
            windowTurns: 3
        };

        const getNextExpRequirement = (level) => {
            const base = 120;
            const linear = level * 180;
            const quadratic = level * level * 3.2;
            const cubic = Math.pow(level, 3) * 0.01;
            return Math.floor(base + linear + quadratic + cubic);
        };

        const getLevelStatBonus = (level) => {
            const safeLevel = Math.max(1, level);
            const scale = safeLevel - 1;
            return Math.floor(1.8 * scale + 0.03 * scale * scale);
        };

        const applyLevelStatBonuses = () => {
            const bonus = getLevelStatBonus(Game.player.level);
            Game.player.levelStr = bonus;
            Game.player.levelVit = bonus;
            Game.player.levelInt = bonus;
            Game.player.levelDex = bonus;
        };

        const calcMaxHpByLevel = (lv, baseHp) => {
            const safeLv = Math.max(1, lv);
            const safeBaseHp = Math.max(1, baseHp);
            const scale = safeLv - 1;
            const linear = 26 * scale;
            const quadratic = 0.6 * scale * scale;
            return Math.floor(safeBaseHp + linear + quadratic);
        };

        const calcMaxMpByLevel = (lv, baseMp) => {
            const safeLv = Math.max(1, lv);
            const safeBaseMp = Math.max(0, baseMp);
            const scale = safeLv - 1;
            const linear = 8 * scale;
            const quadratic = 0.3 * scale * scale;
            return Math.floor(safeBaseMp + linear + quadratic);
        };

        const applyLevelUps = ({ log = true } = {}) => {
            let leveledUp = false;
            if (!Number.isFinite(Game.player.baseMaxHp)) {
                Game.player.baseMaxHp = Game.player.maxHp || 1;
            }
            if (!Number.isFinite(Game.player.baseMaxMp)) {
                Game.player.baseMaxMp = Game.player.maxMp || 1;
            }
            applyLevelStatBonuses();
            while (Game.player.exp >= Game.player.next && Game.player.level < MAX_LEVEL) {
                Game.player.level++;
                Game.player.exp -= Game.player.next;
                Game.player.next = getNextExpRequirement(Game.player.level);
                applyLevelStatBonuses();
                Game.player.maxHp = calcMaxHpByLevel(Game.player.level, Game.player.baseMaxHp);
                Game.player.maxMp = calcMaxMpByLevel(Game.player.level, Game.player.baseMaxMp);
                const derived = getDerivedStats();
                Game.player.hp = derived.maxHp;
                Game.player.mp = derived.maxMp;
                Game.player.sp = Math.min(MAX_SKILL_POINTS, Game.player.sp + LEVEL_UP_SKILL_POINTS);
                if (log) {
                    addLog(`LEVEL UP! [${Game.player.level}]`, "text-blue-400 font-black");
                }
                leveledUp = true;
            }
            if (leveledUp) {
                const spDot = document.getElementById('nav-sp-dot');
                if (spDot) {
                    spDot.classList.remove('hidden');
                }
            }
            if (Game.player.level >= MAX_LEVEL) {
                Game.player.exp = Math.min(Game.player.exp, Game.player.next - 1);
            }
        };

        Game.player.next = getNextExpRequirement(Game.player.level);

        const DefaultGameState = JSON.parse(JSON.stringify(Game));
        const buildInitialSnapshot = () => JSON.parse(JSON.stringify(DefaultGameState));

        const JobKeys = ['warrior', 'mage', 'thief', 'ranger', 'paladin', 'monk'];

        const SaveConfig = {
            prefix: 'kurukue_save_slot_',
            autosaveKey: 'kurukue_autosave_slot',
            autosaveIntervalMs: 30000
        };

        const getSaveKey = (slot) => `${SaveConfig.prefix}${slot}`;

        const formatSaveTimestamp = (isoString) => {
            if (!isoString) return 'æ—¥æ™‚ä¸æ˜';
            const date = new Date(isoString);
            if (Number.isNaN(date.getTime())) return 'æ—¥æ™‚ä¸æ˜';
            const year = date.getFullYear();
            const month = `${date.getMonth() + 1}`.padStart(2, '0');
            const day = `${date.getDate()}`.padStart(2, '0');
            const hours = `${date.getHours()}`.padStart(2, '0');
            const minutes = `${date.getMinutes()}`.padStart(2, '0');
            return `${year}/${month}/${day} ${hours}:${minutes}`;
        };

        const getAutosaveSlot = () => {
            const raw = localStorage.getItem(SaveConfig.autosaveKey);
            const slot = Number.parseInt(raw, 10);
            return Number.isNaN(slot) ? 1 : Math.min(3, Math.max(1, slot));
        };

        const setAutosaveSlot = (slot) => {
            localStorage.setItem(SaveConfig.autosaveKey, String(slot));
            renderSaveSlots();
        };

        const setSaveStatus = (message, tone = 'text-slate-400') => {
            const statusEl = document.getElementById('save-status');
            if (!statusEl) return;
            statusEl.textContent = message;
            statusEl.className = `text-[10px] ${tone} mb-3`;
        };

        const buildSaveSnapshot = () => JSON.parse(JSON.stringify(Game));

        const mergeSaveData = (target, source) => {
            if (!source || typeof source !== 'object') return;
            Object.keys(source).forEach((key) => {
                const value = source[key];
                if (Array.isArray(value)) {
                    target[key] = value;
                } else if (value && typeof value === 'object') {
                    if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key])) {
                        target[key] = {};
                    }
                    mergeSaveData(target[key], value);
                } else {
                    target[key] = value;
                }
            });
        };

        const applySaveData = (snapshot) => {
            if (!snapshot || typeof snapshot !== 'object') return;
            mergeSaveData(Game, snapshot);
            if (Array.isArray(Game.defeatedBossFloors)) {
                const legacyBossFloorMap = {
                    10: 50,
                    50: 100,
                    100: 500,
                    200: 1000,
                    300: 1500,
                    400: 2000,
                    500: 2500,
                    600: 3000,
                    700: 3500,
                    800: 4000,
                    900: 4500,
                    1000: 5000
                };
                const legacyOnlyFloors = new Set([10, 200, 300, 400, 600, 700, 800, 900]);
                const hasLegacy = Game.defeatedBossFloors.some((floor) => legacyOnlyFloors.has(floor));
                if (hasLegacy) {
                    const remapped = Game.defeatedBossFloors.map((floor) => legacyBossFloorMap[floor] ?? floor);
                    Game.defeatedBossFloors = Array.from(new Set(remapped));
                }
            }
            if (Game.player) {
                Game.player.level = Math.min(MAX_LEVEL, Game.player.level || 1);
                if (!Number.isFinite(Game.player.baseMaxHp)) {
                    Game.player.baseMaxHp = Game.player.maxHp || 1;
                }
                if (!Number.isFinite(Game.player.baseMaxMp)) {
                    Game.player.baseMaxMp = Game.player.maxMp || 1;
                }
                Game.player.maxHp = calcMaxHpByLevel(Game.player.level, Game.player.baseMaxHp);
                Game.player.maxMp = calcMaxMpByLevel(Game.player.level, Game.player.baseMaxMp);
                Game.player.sp = Math.min(MAX_SKILL_POINTS, Game.player.sp ?? 1);
                Game.player.next = getNextExpRequirement(Game.player.level);
                applyLevelUps({ log: false });
                normalizeEquipmentBaseStatsForPlayer();
            }
            if (!Number.isFinite(Game.maxBossRushFloor)) {
                Game.maxBossRushFloor = 0;
            }
            Game.isBossRush = Boolean(Game.isBossRush);
        };

        const renderSaveSlots = () => {
            const autosaveSlot = getAutosaveSlot();
            const indicator = document.getElementById('autosave-indicator');
            if (indicator) {
                indicator.textContent = `ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–: ã‚¹ãƒ­ãƒƒãƒˆ${autosaveSlot}`;
            }
            for (let slot = 1; slot <= 3; slot += 1) {
                const infoEl = document.getElementById(`save-slot-info-${slot}`);
                const raw = localStorage.getItem(getSaveKey(slot));
                if (!infoEl) continue;
                if (!raw) {
                    infoEl.textContent = 'ç©º';
                    continue;
                }
                const payload = JSON.parse(raw);
                const timestamp = formatSaveTimestamp(payload?.savedAt);
                const savedFloor = payload?.data?.floor ?? '-';
                const savedLevel = payload?.data?.player?.level ?? '-';
                infoEl.textContent = `${timestamp} / Lv.${savedLevel} / F${savedFloor}`;
            }
            document.querySelectorAll('input[name="autosave-slot"]').forEach((input) => {
                const slotValue = Number.parseInt(input.value, 10);
                input.checked = slotValue === autosaveSlot;
            });
        };

        const saveToSlot = (slot, isAuto = false) => {
            const payload = {
                savedAt: new Date().toISOString(),
                data: buildSaveSnapshot()
            };
            localStorage.setItem(getSaveKey(slot), JSON.stringify(payload));
            const modeLabel = isAuto ? 'ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–' : 'æ‰‹å‹•ã‚»ãƒ¼ãƒ–';
            setSaveStatus(`${modeLabel}: ã‚¹ãƒ­ãƒƒãƒˆ${slot}ã«ä¿å­˜ã—ã¾ã—ãŸã€‚`, 'text-emerald-600');
            renderSaveSlots();
            refreshExportPanel();
        };

        const triggerAutosave = () => {
            const slot = getAutosaveSlot();
            saveToSlot(slot, true);
        };

        const loadFromSlot = (slot) => {
            const raw = localStorage.getItem(getSaveKey(slot));
            if (!raw) {
                resetGameForSlot(slot, `ã‚¹ãƒ­ãƒƒãƒˆ${slot}ã¯ç©ºã®ãŸã‚æ–°è¦é–‹å§‹ã—ã¾ã—ãŸã€‚`, 'text-amber-600');
                return;
            }
            const payload = JSON.parse(raw);
            if (!payload?.data) {
                setSaveStatus(`ã‚¹ãƒ­ãƒƒãƒˆ${slot}ã®ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã‚ã¾ã›ã‚“ã€‚`, 'text-rose-500');
                return;
            }
            applySaveData(payload.data);
            ensureWarpState();
            initializeStarterPotions();
            if (Game.player?.hp <= 0) {
                const derived = getDerivedStats();
                Game.player.hp = Math.max(1, derived.maxHp);
                Game.player.mp = Math.max(0, Math.min(Game.player.mp ?? 0, derived.maxMp));
                if (Game.state === 'dead') Game.state = 'idle';
                const deathOverlay = document.getElementById('death-overlay');
                if (deathOverlay) deathOverlay.style.display = 'none';
            }
            if (!Game.enemy) {
                spawn();
            }
            switchJob(Game.currentJobTab || 'warrior');
            switchSkillType(Game.currentSkillType || 'active');
            updateUI();
            setSaveStatus(`ã‚¹ãƒ­ãƒƒãƒˆ${slot}ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚`, 'text-blue-600');
            renderSaveSlots();
            refreshExportPanel();
        };

        const resetGameForSlot = (slot, message = `ã‚¹ãƒ­ãƒƒãƒˆ${slot}ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦æ–°è¦é–‹å§‹ã—ã¾ã—ãŸã€‚`, tone = 'text-amber-600') => {
            localStorage.removeItem(getSaveKey(slot));
            applySaveData(buildInitialSnapshot());
            ensureWarpState();
            initializeStarterPotions();
            Game.enemy = null;
            spawn();
            switchJob('warrior');
            switchSkillType('active');
            updateUI();
            setSaveStatus(message, tone);
            renderSaveSlots();
            refreshExportPanel();
        };

        const changeSaveSlot = (slot) => {
            setAutosaveSlot(slot);
            const raw = localStorage.getItem(getSaveKey(slot));
            if (raw) {
                loadFromSlot(slot);
                return;
            }
            resetGameForSlot(slot, `ã‚¹ãƒ­ãƒƒãƒˆ${slot}ã¯ç©ºã®ãŸã‚æ–°è¦é–‹å§‹ã—ã¾ã—ãŸã€‚`, 'text-amber-600');
        };

        const switchSaveSlot = () => {
            const current = getAutosaveSlot();
            const next = (current % 3) + 1;
            changeSaveSlot(next);
        };

        const setupSaveControls = () => {
            document.querySelectorAll('[data-save-slot]').forEach((button) => {
                button.addEventListener('click', () => {
                    const slot = Number.parseInt(button.dataset.saveSlot, 10);
                    if (!Number.isNaN(slot)) saveToSlot(slot);
                });
            });
            document.querySelectorAll('[data-load-slot]').forEach((button) => {
                button.addEventListener('click', () => {
                    const slot = Number.parseInt(button.dataset.loadSlot, 10);
                    if (!Number.isNaN(slot)) loadFromSlot(slot);
                });
            });
            document.querySelectorAll('input[name="autosave-slot"]').forEach((input) => {
                input.addEventListener('change', () => {
                    const slot = Number.parseInt(input.value, 10);
                    if (!Number.isNaN(slot)) changeSaveSlot(slot);
                });
            });
            const switchSlotButton = document.getElementById('switch-save-slot-btn');
            if (switchSlotButton) {
                switchSlotButton.addEventListener('click', () => {
                    switchSaveSlot();
                });
            }
            const newSaveButton = document.getElementById('new-save-btn');
            if (newSaveButton) {
                newSaveButton.addEventListener('click', () => {
                    const slot = getAutosaveSlot();
                    openConfirmModal(`ã‚¹ãƒ­ãƒƒãƒˆ${slot}ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦æ–°ã—ãå§‹ã‚ã¾ã™ã‹ï¼Ÿ`, () => {
                        resetGameForSlot(slot);
                    });
                });
            }
            renderSaveSlots();
        };

        const normalizeLegacyPayload = (parsed) => {
            if (!parsed || typeof parsed !== 'object') return null;
            if (parsed.data && typeof parsed.data === 'object') {
                return {
                    savedAt: parsed.savedAt || new Date().toISOString(),
                    data: parsed.data
                };
            }
            return {
                savedAt: new Date().toISOString(),
                data: parsed
            };
        };

        const computeSha256Hex = async (text) => {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const hash = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hash))
                .map((byte) => byte.toString(16).padStart(2, '0'))
                .join('');
        };

        const buildExportText = async () => {
            const slot = getAutosaveSlot();
            const raw = localStorage.getItem(getSaveKey(slot));
            if (!raw) return '';
            const checksum = await computeSha256Hex(raw);
            return JSON.stringify({ v: 1, payload: raw, checksum });
        };

        const refreshExportPanel = async (shouldGenerate = false) => {
            const exportTextArea = document.getElementById('export-text');
            if (!exportTextArea) return;
            const text = shouldGenerate ? await buildExportText() : '';
            exportTextArea.value = text;
        };

        const normalizeImportedPayload = async (rawText) => {
            const trimmed = rawText.trim();
            if (!trimmed) return { payload: null, error: 'empty' };
            const parsed = JSON.parse(trimmed);
            if (parsed && typeof parsed === 'object' && parsed.payload && parsed.checksum) {
                if (typeof parsed.payload !== 'string' || typeof parsed.checksum !== 'string') {
                    return { payload: null, error: 'invalid' };
                }
                const checksum = await computeSha256Hex(parsed.payload);
                if (checksum !== parsed.checksum) {
                    return { payload: null, error: 'tampered' };
                }
                const inner = JSON.parse(parsed.payload);
                return { payload: normalizeLegacyPayload(inner), error: null };
            }
            return { payload: normalizeLegacyPayload(parsed), error: null };
        };

        const getImportTargetSlot = () => {
            const select = document.getElementById('import-slot-select');
            if (!select) return getAutosaveSlot();
            if (select.value === 'auto') return getAutosaveSlot();
            const slot = Number.parseInt(select.value, 10);
            return Number.isNaN(slot) ? getAutosaveSlot() : Math.min(3, Math.max(1, slot));
        };

        const setupExportImportControls = () => {
            const exportRefreshButton = document.getElementById('export-refresh-btn');
            const exportCopyButton = document.getElementById('export-copy-btn');
            const exportClearButton = document.getElementById('export-clear-btn');
            const importApplyButton = document.getElementById('import-apply-btn');
            const importClearButton = document.getElementById('import-clear-btn');
            const importTextArea = document.getElementById('import-text');
            const exportTextArea = document.getElementById('export-text');
            const importSlotSelect = document.getElementById('import-slot-select');
            const exportCopyMessage = document.getElementById('export-copy-message');
            const importTamperMessage = document.getElementById('import-tamper-message');

            if (exportRefreshButton) {
                exportRefreshButton.addEventListener('click', async () => {
                    await refreshExportPanel(true);
                    setSaveStatus('å¼•ãç¶™ãã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¾ã—ãŸã€‚', 'text-emerald-600');
                });
            }

            if (exportCopyButton && exportTextArea) {
                exportCopyButton.addEventListener('click', async () => {
                    const text = exportTextArea.value;
                    if (!text) {
                        setSaveStatus('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚', 'text-amber-600');
                        return;
                    }
                    if (navigator.clipboard?.writeText) {
                        await navigator.clipboard.writeText(text);
                    } else {
                        exportTextArea.select();
                        document.execCommand('copy');
                        exportTextArea.setSelectionRange(0, 0);
                    }
                    setSaveStatus('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ–‡å­—åˆ—ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚', 'text-emerald-600');
                    if (exportCopyMessage) {
                        exportCopyMessage.classList.remove('hidden');
                        setTimeout(() => {
                            exportCopyMessage.classList.add('hidden');
                        }, 1800);
                    }
                });
            }

            if (exportClearButton && exportTextArea) {
                exportClearButton.addEventListener('click', () => {
                    exportTextArea.value = '';
                    if (exportCopyMessage) {
                        exportCopyMessage.classList.add('hidden');
                    }
                });
            }

            if (importApplyButton && importTextArea) {
                importApplyButton.addEventListener('click', async () => {
                    const text = importTextArea.value;
                    if (!text.trim()) {
                        setSaveStatus('ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡å­—åˆ—ãŒç©ºã§ã™ã€‚', 'text-amber-600');
                        return;
                    }
                    let result = null;
                    try {
                        result = await normalizeImportedPayload(text);
                    } catch (error) {
                        result = null;
                    }
                    if (result?.error === 'tampered') {
                        setSaveStatus('ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡å­—åˆ—ãŒæ”¹ã–ã‚“ã•ã‚Œã¦ã„ã¾ã™ã€‚', 'text-rose-500');
                        if (importTamperMessage) {
                            importTamperMessage.classList.remove('hidden');
                        }
                        return;
                    }
                    if (importTamperMessage) {
                        importTamperMessage.classList.add('hidden');
                    }
                    const payload = result?.payload ?? null;
                    if (!payload?.data) {
                        setSaveStatus('ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡å­—åˆ—ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚', 'text-rose-500');
                        return;
                    }
                    const slot = getImportTargetSlot();
                    localStorage.setItem(getSaveKey(slot), JSON.stringify(payload));
                    loadFromSlot(slot);
                    setSaveStatus(`ã‚¹ãƒ­ãƒƒãƒˆ${slot}ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚`, 'text-blue-600');
                    refreshExportPanel();
                });
            }

            if (importClearButton && importTextArea) {
                importClearButton.addEventListener('click', () => {
                    importTextArea.value = '';
                });
            }

            if (importSlotSelect) {
                importSlotSelect.value = 'auto';
            }

            void refreshExportPanel(false);
        };

        const startAutosaveTimer = () => {
            setInterval(() => {
                const slot = getAutosaveSlot();
                saveToSlot(slot, true);
            }, SaveConfig.autosaveIntervalMs);
        };

        const JobData = {
            warrior: {
                name: "æˆ¦å£«",
                active: [
                    { id: 0, name: "è¡€æ²¸ãã®å’†å“®", mp: 6, mpGrowth: 0, pow: 1.17, powGrowth: 0.18, maxLevel: 150, effects: [{ target: "self", id: "attackUp", stacks: 1, turns: 2 }], desc: "é—˜å¿—ã‚’ç‡ƒã‚„ã—ã€æ”»æ’ƒã‚’åº•ä¸Šã’ã™ã‚‹å’†å“®" },
                    { id: 1, name: "ç‹‚èµ°é€£æ’ƒ", mp: 10, mpGrowth: 0, pow: 0.99, powGrowth: 0.11, hits: 2, maxLevel: 150, effects: [{ target: "enemy", id: "vulnerable", stacks: 1, turns: 2, log: "é€£æ’ƒã§è„†å¼±ã«ãªã£ãŸï¼" }], desc: "çªé€²ã‹ã‚‰ã®é€£æ’ƒã§è„†å¼±ã‚’åˆ»ã‚€" },
                    { id: 2, name: "é€†å¢ƒã®ä¸€æ’ƒ", mp: 14, pow: 2.34, powGrowth: 0.34, maxLevel: 150, critBonus: 5, critGrowth: 2, desc: "è¿½ã„è¾¼ã¾ã‚ŒãŸåŠ›ã‚’å©ãã¤ã‘ã‚‹å¼·æ‰“" },
                    { id: 3, name: "ç ´æ»…ã®èª“ã„", mp: 10, pow: 1.44, powGrowth: 0.18, maxLevel: 150, effects: [{ target: "self", id: "attackUp", stacks: 2, turns: 2 }, { target: "self", id: "vulnerable", stacks: 1, turns: 1 }], desc: "åŠ›ã‚’å¼•ãä¸Šã’ã‚‹ä»£å„Ÿã«éš™ã‚’ç”Ÿã‚€èª“ç´„" },
                    { id: 4, name: "æˆ¦é¬¼ã®åæ’ƒ", mp: 16, pow: 1.26, powGrowth: 0.16, maxLevel: 150, effects: [{ target: "self", id: "reflect", stacks: 1, turns: 2 }], desc: "åå°„ã§åæ’ƒã‚’ç‹™ã†è’ã€…ã—ã„æ–¬æ’ƒ" },
                    { id: 5, name: "å‘½ç‡ƒã‚„ã—", mp: 0, pow: 3.06, powGrowth: 0.45, hpCost: 0.12, maxLevel: 150, effects: [{ target: "self", id: "attackUp", stacks: 1, turns: 2 }], desc: "HPã‚’ç‡ƒæ–™ã«çˆ†ç™ºçš„ãªä¸€æ’ƒã‚’æ”¾ã¤" },
                    { id: 6, name: "é§å‰²ã‚Š", mp: 6, mpGrowth: 0, pow: 1.44, powGrowth: 0.22, maxLevel: 150, effects: [{ target: "enemy", id: "defenseDown", stacks: 1, turns: 2, log: "é§ãŒç •ã‘ãŸï¼" }], desc: "é˜²å¾¡ã‚’å‰Šã‚Šã€ç ´ç •ã®èµ·ç‚¹ã‚’ä½œã‚‹" },
                    { id: 7, name: "ç ´åŸã®æ§Œ", mp: 12, mpGrowth: 0, pow: 1.98, powGrowth: 0.32, maxLevel: 150, effects: [{ target: "enemy", id: "defenseDown", stacks: 2, turns: 2, log: "è£…ç”²ãŒå´©ã‚ŒãŸï¼" }], desc: "è„†ç”²ã‚’é‡ã­ã‚‹é‡æ’ƒã§å …ç‰¢ã‚’å´©ã™" },
                    { id: 8, name: "å´©ã—æ‰“ã¡", mp: 10, mpGrowth: 0, pow: 1.62, powGrowth: 0.23, maxLevel: 150, effects: [{ target: "enemy", id: "vulnerable", stacks: 1, turns: 2, log: "ä½“å‹¢ãŒå´©ã‚ŒãŸï¼" }], desc: "éš™ã‚’ä½œã‚Šã€è¢«ãƒ€ãƒ¡ã‚’å¼•ãä¸Šã’ã‚‹" },
                    { id: 9, name: "éœ‡æ’ƒæ³¢", mp: 14, mpGrowth: 0, pow: 1.08, powGrowth: 0.16, hits: 2, maxLevel: 150, effects: [{ target: "enemy", id: "blind", stacks: 1, turns: 2, log: "è¡æ’ƒã§è¦–ç•ŒãŒä¹±ã‚ŒãŸï¼" }], desc: "è¡æ’ƒæ³¢ã®é€£æ’ƒã§å‘½ä¸­ã‚’å´©ã™" },
                    { id: 10, name: "ç²‰ç •åœ§", mp: 16, mpGrowth: 0, pow: 1.89, powGrowth: 0.27, maxLevel: 150, effects: [{ target: "enemy", id: "attackDown", stacks: 1, turns: 2, log: "åœ§ã«ã‚ˆã‚Šè¡°å¼±ã—ãŸï¼" }], desc: "åœ§ã§æ•µç«åŠ›ã‚’è½ã¨ã—ã¦å´©ã—åˆ‡ã‚‹" },
                    { id: 11, name: "æ–­ç½ªã®æ¥”", mp: 20, mpGrowth: 0, pow: 2.61, powGrowth: 0.38, maxLevel: 150, effects: [{ target: "enemy", id: "silence", stacks: 1, turns: 1, log: "æ¥”ã§æ²ˆé»™ã—ãŸï¼" }], desc: "è¡Œå‹•ã‚’å°ã˜ã‚‹æ±ºå®šæ‰“" }
                ],
                passive: [
                    { id: 0, name: "å‰›åŠ›é›éŒ¬", desc: "STR+4/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.str += 4 * d },
                    { id: 1, name: "é‹¼ã®è‚‰ä½“", desc: "VIT+4/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.vit += 4 * d },
                    { id: 2, name: "ç ´å£Šæœ¬èƒ½", desc: "ä¸ãƒ€ãƒ¡å¢—åŠ +2%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.damageBoost += 2 * d },
                    { id: 3, name: "æ­¦å™¨ã®æ¥µæ„", desc: "ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸+6%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.critDamage += 6 * d },
                    { id: 4, name: "æˆ¦ç·šç¶­æŒ", desc: "æœ€å¤§HP+20/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.maxHpFlat += 20 * d },
                    { id: 5, name: "çŒ›é€²", desc: "æ”»æ’ƒåŠ›+2/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.attackFlat += 2 * d }
                ]
            },
            mage: {
                name: "é­”è¡“å¸«",
                active: [
                    { id: 0, name: "ç«çƒæ’ƒ", mp: 8, pow: 1.8, powGrowth: 0.27, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "weaken", stacks: 1, turns: 2, log: "ç‚ãŒå‹¢ã„ã‚’å‰Šã„ã ï¼" }], desc: "ç‚ã§å‹¢ã„ã‚’å‰Šãã€é€£æºã®èµ·ç‚¹ã‚’ä½œã‚‹åŸºæœ¬ç«åŠ›" },
                    { id: 1, name: "ç¼ãå‰¥ãŒã—", mp: 12, pow: 2.16, powGrowth: 0.32, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "defenseDown", stacks: 1, turns: 2, log: "è£…ç”²ãŒç„¼ã‘è½ã¡ãŸï¼" }], desc: "é˜²å¾¡ã‚’å‰Šã‚Šé«˜ç«åŠ›ã‚¹ã‚­ãƒ«ã®ä¸‹åœ°ã‚’ä½œã‚‹" },
                    { id: 2, name: "ç†¾ç«ã®ç¬¦", mp: 10, pow: 0.72, powGrowth: 0.09, isMagic: true, maxLevel: 150, effects: [{ target: "self", id: "attackUp", stacks: 1, turns: 2, log: "ç‚ã®ç¬¦ã§ç«åŠ›ãŒé«˜ã¾ã£ãŸï¼" }], desc: "æ¬¡ã®ä¸€æ’ƒã‚’å¼·ã‚ã‚‹è‡ªå·±å¼·åŒ–ã®æº–å‚™è¡“" },
                    { id: 3, name: "é»’ç…™çºã„", mp: 14, pow: 1.26, powGrowth: 0.18, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "blind", stacks: 1, turns: 2, log: "é»’ç…™ã§è¦–ç•ŒãŒå¥ªã‚ã‚ŒãŸï¼" }], desc: "æš—é—‡ã‚’ä»˜ä¸ã—ã€æš—é—‡ä¸­ã«é€£æºç«åŠ›ãŒå¼·åŒ–ã•ã‚Œã‚‹" },
                    { id: 4, name: "ç›²ç›®ç‹©ã‚Š", mp: 18, pow: 2.88, powGrowth: 0.41, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "vulnerable", stacks: 1, turns: 2, log: "æ··ä¹±ã®éš™ã«æ€¥æ‰€ã‚’çªã„ãŸï¼" }], desc: "é€£æºæ¡ä»¶: æ•µãŒæš—é—‡ä¸­ãªã‚‰å¨åŠ›ãŒä¸Šæ˜‡ã™ã‚‹" },
                    { id: 5, name: "çµ‚ç„‰ã®ç¦å‘ª", mp: 50, pow: 5.85, powGrowth: 1.08, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "silence", stacks: 1, turns: 1, log: "ç¦å‘ªã§æ²ˆé»™ã—ãŸï¼" }], desc: "æœ€å¤§ç«åŠ›ã§æˆ¦é—˜ã‚’æ±ºã‚ã‚‹å¥¥ç¾©" },
                    { id: 6, name: "ã‚¢ã‚¤ã‚¹ãƒ©ãƒ³ã‚¹", mp: 10, pow: 2.07, powGrowth: 0.32, isMagic: true, accuracyBonus: 5, accuracyGrowth: 3, maxLevel: 150, effects: [{ target: "enemy", id: "freeze", stacks: 1, turns: 1, log: "æ°·æ§ã§å‡çµã—ãŸï¼" }], desc: "å‘½ä¸­å¯„ã‚Šã®ä¸€æ’ƒã§å‡çµã‚’ç‹™ã†" },
                    { id: 7, name: "éœœé–", mp: 12, pow: 1.26, powGrowth: 0.18, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "attackDown", stacks: 1, turns: 2, log: "éœœé–ã§å‹•ããŒéˆã£ãŸï¼" }], desc: "æ”»æ’ƒåŠ›ã‚’æŠ‘ãˆã¦è¢«ãƒ€ãƒ¡ã‚’å®‰å®šåŒ–" },
                    { id: 8, name: "å‡åœ§", mp: 14, pow: 1.98, powGrowth: 0.27, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "weaken", stacks: 1, turns: 2, log: "å†·æ°—ã§å‹¢ã„ã‚’å‰Šã„ã ï¼" }], desc: "å¼±ä½“ã§æ¬¡ã®æ”»æ’ƒã‚’é€šã—ã‚„ã™ãã™ã‚‹" },
                    { id: 9, name: "ç™½éœ§", mp: 14, pow: 1.08, powGrowth: 0.18, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "blind", stacks: 1, turns: 2, log: "ç™½éœ§ã§è¦–ç•ŒãŒå¥ªã‚ã‚ŒãŸï¼" }], desc: "æš—é—‡ã‚’ä»˜ä¸ã—ã€æš—é—‡ä¸­ã«é€£æºç«åŠ›ãŒå¼·åŒ–ã•ã‚Œã‚‹" },
                    { id: 10, name: "é™æ°·æ–­", mp: 18, pow: 2.52, powGrowth: 0.36, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "defenseDown", stacks: 1, turns: 2, log: "æ°·åˆƒã§å®ˆã‚ŠãŒå´©ã‚ŒãŸï¼" }], desc: "é€£æºæ¡ä»¶: æš—é—‡ä¸­ã§å¨åŠ›ä¸Šæ˜‡ã€å‡çµä¸­ãªã‚‰ã•ã‚‰ã«ä¸Šæ˜‡" },
                    { id: 11, name: "é›¶åº¦å°å°", mp: 30, pow: 4.5, powGrowth: 0.72, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "freeze", stacks: 1, turns: 1, log: "é›¶åº¦ã®å°å°ã§å‡çµã—ãŸï¼" }], desc: "å¼·åŠ›ãªæ°·ã§è¡Œå‹•ã‚’æ­¢ã‚ã‚‹åˆ‡ã‚Šæœ­" }
                ],
                passive: [
                    { id: 0, name: "çŸ¥åŠ›å¢—å¼·", desc: "INT+4/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.int += 4 * d },
                    { id: 1, name: "é­”åŠ›å¾ªç’°", desc: "æœ€å¤§MP+15/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => { Game.player.maxMpFlat += 15 * d; } },
                    { id: 2, name: "ç‘æƒ³", desc: "MPè‡ªå‹•å›å¾©+2/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.mpRegen += 2 * d },
                    { id: 3, name: "é­”å°é›†ä¸­", desc: "ä¼šå¿ƒç‡+2%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.critRate += 2 * d },
                    { id: 4, name: "é­”åŠ›è²«é€š", desc: "é­”æ³•è²«é€š+4%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.mPen += 4 * d },
                    { id: 5, name: "ç§˜å¥¥å¼·åŒ–", desc: "ä¸ãƒ€ãƒ¡å¢—åŠ +2%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.damageBoost += 2 * d }
                ]
            },
            thief: {
                name: "ç›—è³Š",
                active: [
                    { id: 0, name: "ç…™å¹•æŠ•ã’", mp: 4, pow: 0.81, powGrowth: 0.11, maxLevel: 150, effects: [{ target: "enemy", id: "blind", stacks: 1, turns: 2, log: "ç…™ã§è¦–ç•ŒãŒå¥ªã‚ã‚ŒãŸï¼" }], desc: "ç…™å¹•ã§æš—é—‡ã‚’ä»˜ä¸ã—ã€ä»¥å¾Œã®åˆ¶åœ§é€£æºã®èµ·ç‚¹ã«ãªã‚‹" },
                    { id: 1, name: "å½±ç¸«ã„", mp: 8, pow: 1.26, powGrowth: 0.16, maxLevel: 150, effects: [{ target: "enemy", id: "silence", stacks: 1, turns: 1, log: "å½±ã«ç¸›ã‚‰ã‚Œã¦æ²ˆé»™ã—ãŸï¼" }], desc: "å½±ã§å°ã˜ã€æ•µã®ã‚¹ã‚­ãƒ«å›è»¢ã‚’æ­¢ã‚ã‚‹åˆ¶åœ§æŠ€" },
                    { id: 2, name: "æ¯’åˆƒ", mp: 10, pow: 1.53, powGrowth: 0.2, critBonus: 5, critGrowth: 2, maxLevel: 150, effects: [{ target: "enemy", id: "poison", stacks: 1, turns: 3, log: "æ¯’ãŒå›ã£ãŸï¼" }], desc: "æ€¥æ‰€ç‹™ã„ã®ä¸€æ’ƒã§æ¯’ã‚’ä»˜ä¸ã™ã‚‹" },
                    { id: 3, name: "è£‚å‚·åˆ»ã¿", mp: 7, pow: 0.81, powGrowth: 0.09, hits: 2, maxLevel: 150, effects: [{ target: "enemy", id: "bleed", stacks: 1, turns: 2, log: "è£‚å‚·ã§å‡ºè¡€ã—ãŸï¼" }], desc: "äºŒé€£æ’ƒã§å‡ºè¡€ã‚’ç‹™ã†" },
                    { id: 4, name: "æˆ¦æ„å‰Šã", mp: 5, pow: 0.81, powGrowth: 0.09, maxLevel: 150, effects: [{ target: "enemy", id: "weaken", stacks: 1, turns: 2, log: "æˆ¦æ„ã‚’å‰ŠãŒã‚ŒãŸï¼" }], desc: "æ”»æ’ƒã¨åŒæ™‚ã«æ•µã®å‹¢ã„ã‚’å‰Šãå¼±ä½“ä»˜ä¸" },
                    { id: 5, name: "å½±è¸ã¿", mp: 12, pow: 1.8, powGrowth: 0.25, accuracyBonus: 10, accuracyGrowth: 4, maxLevel: 150, desc: "æš—é—‡ã®éš™ã‚’çªã„ã¦è¸ã¿è¾¼ã¿ã€æ±ºå®šæ‰“ã‚’ç‹™ã†" },
                    { id: 6, name: "ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ–", mp: 3, pow: 0.9, powGrowth: 0.14, accuracyBonus: 15, accuracyGrowth: 5, maxLevel: 150, effects: [{ target: "self", id: "haste", stacks: 1, turns: 2 }], desc: "ç´ æ—©ã„çªãã§è¿…é€Ÿã‚’å¾—ã‚‹é€£æºèµ·ç‚¹" },
                    { id: 7, name: "ãƒ€ãƒ–ãƒ«ã‚¢ã‚¿ãƒƒã‚¯", mp: 7, pow: 0.77, powGrowth: 0.09, hits: 2, maxLevel: 150, desc: "äºŒé€£æ’ƒã§æ‰‹æ•°ã‚’ç¨¼ã" },
                    { id: 8, name: "å¥‡è¥²", mp: 12, pow: 2.16, powGrowth: 0.29, accuracyBonus: 10, accuracyGrowth: 4, maxLevel: 150, desc: "å…ˆæ‰‹ã§ç‹™ã„æ’ƒã¡ã€çŸ­æœŸæ±ºæˆ¦ã®ä¸»åŠ›ã¨ãªã‚‹ä¸€æ’ƒ" },
                    { id: 9, name: "æ€¥æ‰€ç©¿ã¡", mp: 14, pow: 1.89, powGrowth: 0.27, critBonus: 12, critGrowth: 3, maxLevel: 150, desc: "æ€¥æ‰€ã‚’ç‹™ã£ã¦é«˜ã„ä¼šå¿ƒç‡ã‚’å¾—ã‚‹åˆºçª" },
                    { id: 10, name: "å½±èµ°ã‚Š", mp: 9, pow: 1.08, powGrowth: 0.14, maxLevel: 150, effects: [{ target: "self", id: "haste", stacks: 1, turns: 3 }], desc: "èº«ã‚’æ»‘ã‚‰ã›ã¦è¿…é€Ÿã‚’å»¶é•·ã—ã€é€£ç¶šè¡Œå‹•ã‚’ç‹™ã†" },
                    { id: 11, name: "æ–­ç½ªã®ä¸€åˆºã—", mp: 24, pow: 3.78, powGrowth: 0.5, critBonus: 8, critGrowth: 2, maxLevel: 150, desc: "ç‹™ã„ã™ã¾ã—ãŸé«˜ç«åŠ›ã®ä¸€æ’ƒã§ã¨ã©ã‚ã‚’ç‹™ã†" }
                ],
                passive: [
                    { id: 0, name: "ä¿Šæ•", desc: "DEX+3/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.dex += 3 * d },
                    { id: 1, name: "ç¥é€Ÿå›é¿", desc: "å›é¿ç‡+2%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.evasionRate += 2 * d },
                    { id: 2, name: "ç›®åˆ©ã", desc: "ãƒ‰ãƒ­ãƒƒãƒ—ç‡+3%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.luck += 3 * d },
                    { id: 3, name: "å¹¸é‹ã®å¥³ç¥", desc: "è¿½åŠ çµŒé¨“å€¤+5%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.expBoost += 5 * d },
                    { id: 4, name: "æ€¥æ‰€æ”»æ’ƒ", desc: "ä¼šå¿ƒç‡+3%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.critRate += 3 * d },
                    { id: 5, name: "æš—æ®ºè€…ã®å¿ƒå¾—", desc: "æº€ã‚¿ãƒ³ã®æ•µã¸ã®åˆæ’ƒãŒå¼·åŒ–", maxLevel: 150, logic: 'first_hit_boost' }
                ]
            },
            ranger: {
                name: "ãƒ¬ãƒ³ã‚¸ãƒ£ãƒ¼",
                active: [
                    { id: 0, name: "è¿½è·¡ã®æ¨™", mp: 6, pow: 0.99, powGrowth: 0.14, accuracyBonus: 10, accuracyGrowth: 4, maxLevel: 150, effects: [{ target: "enemy", id: "vulnerable", stacks: 1, turns: 2, log: "æ¨™ã§ç‹™ã„ãŒå®šã¾ã£ãŸï¼" }], desc: "ç‹™ã„ã‚’åˆ»ã‚“ã§è„†å¼±ã‚’ä¸ãˆã‚‹è¿½è·¡ã®èµ·ç‚¹" },
                    { id: 1, name: "ç‹©äººã®è¦‹åˆ‡ã‚Š", mp: 8, pow: 0.9, powGrowth: 0.11, maxLevel: 150, effects: [{ target: "self", id: "haste", stacks: 1, turns: 2 }], desc: "ç›¸æ‰‹ã®ç™–ã‚’èª­ã¿ã€è¿…é€Ÿã§æ‰‹æ•°ã‚’æ•´ãˆã‚‹" },
                    { id: 2, name: "å‰Šã‚Šå°„ã¡", mp: 9, pow: 0.81, powGrowth: 0.11, hits: 2, maxLevel: 150, effects: [{ target: "enemy", id: "bleed", stacks: 1, turns: 3, log: "å‚·ãŒæ·±ãè£‚ã‘ãŸï¼" }], desc: "é€£å°„ã§ç¢ºå®Ÿã«å‰Šã‚Šã€å‡ºè¡€ã‚’ç‹™ã†" },
                    { id: 3, name: "ç‹©çŒŸã®è¶³æ­¢ã‚", mp: 12, pow: 1.35, powGrowth: 0.18, maxLevel: 150, effects: [{ target: "enemy", id: "attackDown", stacks: 1, turns: 2, log: "å‹•ããŒéˆã£ãŸï¼" }], desc: "å‹•ãã‚’å¥ªã„ã€æ”»æ’ƒåŠ›ã‚’è½ã¨ã—ã¦é€ƒãŒã•ãªã„" },
                    { id: 4, name: "è‡´å‘½ã®ä¸€çŸ¢", mp: 18, pow: 2.61, powGrowth: 0.36, critBonus: 8, critGrowth: 3, maxLevel: 150, effects: [{ target: "enemy", id: "defenseDown", stacks: 1, turns: 2, log: "æ€¥æ‰€ã«è£‚å‚·ãŒå…¥ã£ãŸï¼" }], desc: "æ€¥æ‰€ç‹™ã„ã§å®ˆã‚Šã‚’å´©ã™æ±ºå®šæ‰“" },
                    { id: 5, name: "ç£é“ã®å‹˜", mp: 10, pow: 0.72, powGrowth: 0.09, maxLevel: 150, effects: [{ target: "self", id: "attackUp", stacks: 1, turns: 2 }], desc: "ç‹©ã‚Šã®å‹˜ã‚’ç ”ãæ¾„ã¾ã—é—˜å¿—ã‚’é«˜ã‚ã‚‹" },
                    { id: 6, name: "è¿½æ’ƒã®æ¨™", mp: 7, pow: 0.9, powGrowth: 0.11, accuracyBonus: 8, accuracyGrowth: 3, maxLevel: 150, effects: [{ target: "enemy", id: "weaken", stacks: 1, turns: 2, log: "è¿½æ’ƒã®å°ã§å‹¢ã„ãŒå‰ŠãŒã‚ŒãŸï¼" }], desc: "è¿½æ’ƒã®åˆå›³ã‚’åˆ»ã¿ã€å¼±ä½“ã‚’ä¸ãˆã‚‹" },
                    { id: 7, name: "é€£é–å°„æ’ƒ", mp: 12, pow: 0.68, powGrowth: 0.07, hits: 3, maxLevel: 150, effects: [{ target: "enemy", id: "weaken", stacks: 1, turns: 2, log: "é€£å°„ã§å‹¢ã„ã‚’å¥ªã£ãŸï¼" }], desc: "å¤šæ®µé€£å°„ã§ã‚³ãƒ³ãƒœã®èµ·ç‚¹ã‚’ä½œã‚‹" },
                    { id: 8, name: "ç‹©äººã®ç¶²", mp: 14, pow: 1.44, powGrowth: 0.2, maxLevel: 150, effects: [{ target: "enemy", id: "vulnerable", stacks: 1, turns: 2, log: "ç¶²ã§ä½“å‹¢ãŒå´©ã‚ŒãŸï¼" }], desc: "ç›¸æ‰‹ã®å‹•ãã‚’æŠ‘ãˆã€è„†å¼±ã‚’ä»˜ä¸" },
                    { id: 9, name: "ç–¾é¢¨ã®ä¸€çŸ¢", mp: 10, pow: 1.53, powGrowth: 0.22, accuracyBonus: 12, accuracyGrowth: 4, maxLevel: 150, desc: "ç´ æ—©ã„è¿½æ’ƒã§æµã‚Œã‚’åŠ é€Ÿã•ã›ã‚‹" },
                    { id: 10, name: "ç©¿å­”æ’ƒ", mp: 16, pow: 2.16, powGrowth: 0.29, maxLevel: 150, effects: [{ target: "enemy", id: "defenseDown", stacks: 2, turns: 2, log: "è²«é€šã§è£…ç”²ãŒè£‚ã‘ãŸï¼" }], desc: "è£…ç”²ã‚’ç©¿ã¡ã€è„†ç”²ã‚’é‡ã­ã‚‹" },
                    { id: 11, name: "çµ‚ç«¯ã®ä¸€æ’ƒ", mp: 22, pow: 2.52, powGrowth: 0.41, critBonus: 6, critGrowth: 2, maxLevel: 150, effects: [{ target: "enemy", id: "vulnerable", stacks: 1, turns: 2, log: "ä»•ç•™ã‚ã®å‚·ãŒå…¥ã£ãŸï¼" }], desc: "é€£æºã®ç· ã‚ã«æ”¾ã¤é«˜ç«åŠ›ã®ä»•ç•™ã‚æŠ€" }
                ],
                passive: [
                    { id: 0, name: "å°„æ’ƒè¨“ç·´", desc: "å‘½ä¸­ç‡+3%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.accuracy += 3 * d },
                    { id: 1, name: "ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚¢ã‚¤", desc: "ä¼šå¿ƒç‡+2%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.critRate += 2 * d },
                    { id: 2, name: "é›†ä¸­", desc: "ä¸ãƒ€ãƒ¡å¢—åŠ +2%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.damageBoost += 2 * d },
                    { id: 3, name: "é‡ç”Ÿã®å‹˜", desc: "å›é¿ç‡+1%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.evasionRate += 1 * d },
                    { id: 4, name: "ãƒ¬ã‚¢ãƒãƒ³ãƒˆ", desc: "ãƒ¬ã‚¢ãƒ‰ãƒ­ç‡+3%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.rareFind += 3 * d },
                    { id: 5, name: "ç²ç‰©ã®è¿½è·¡", desc: "ã‚´ãƒ¼ãƒ«ãƒ‰å¢—åŠ ç‡+5%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.goldBoost += 5 * d }
                ]
            },
            paladin: {
                name: "è–é¨å£«",
                active: [
                    { id: 0, name: "å…‰ç›¾ã®å¥‘ç´„", mp: 8, pow: 0.81, powGrowth: 0.11, maxLevel: 150, effects: [{ target: "self", id: "barrier", stacks: 1, turns: 2, log: "å…‰ç›¾ã§å®ˆã‚ŠãŒå¼·åŒ–ã•ã‚ŒãŸï¼" }], desc: "å°ã•ãªæ”»æ’ƒã¨åŒæ™‚ã«ãƒãƒªã‚¢ã‚’å¼µã‚‹é˜²å¾¡ã®èµ·ç‚¹" },
                    { id: 1, name: "å®ˆè­·èª“ç´„", mp: 10, pow: 0.99, powGrowth: 0.14, maxLevel: 150, effects: [{ target: "self", id: "defenseUp", stacks: 1, turns: 2, log: "å®ˆè­·ã®èª“ç´„ã§å®ˆå‹¢ã‚’å¾—ãŸï¼" }], desc: "è¢«ãƒ€ãƒ¡ã‚’æŠ‘ãˆã‚‹å®ˆå‹¢ã‚’ã¾ã¨ã„ã€ç²˜ã‚Šå¼·ãæˆ¦ã†" },
                    { id: 2, name: "æµ„åŒ–ã®ç¥ˆã‚Š", mp: 12, val: 32, valGrowth: 12, type: 'heal', isMagic: true, maxLevel: 150, effects: [{ target: "self", id: "defenseUp", stacks: 1, turns: 2 }], desc: "è‡ªå·±å›å¾©ã¨å®ˆå‹¢ã§å®‰å®šã‚’ä½œã‚‹ç¥ˆã‚Š" },
                    { id: 3, name: "é»’è€€ã®èª“å°", mp: 10, pow: 1.08, powGrowth: 0.14, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "blind", stacks: 1, turns: 2, log: "é»’è€€ã®å°ã§è¦–ç•ŒãŒå¥ªã‚ã‚ŒãŸï¼" }], desc: "æš—é—‡ã‚’è‡ªå‰ã§ä»˜ä¸ã—ã€é˜²å¾¡é€£æºã®èµ·ç‚¹ã‚’ä½œã‚‹" },
                    { id: 4, name: "é»æ˜ã®å‰£", mp: 14, pow: 1.98, powGrowth: 0.29, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "vulnerable", stacks: 1, turns: 2, log: "é»æ˜ã®ä¸€é–ƒã§è„†å¼±ã«ãªã£ãŸï¼" }], desc: "è–ãªã‚‹ä¸€æ’ƒã§éš™ã‚’ä½œã‚Šã€è¿½æ’ƒã«ç¹‹ã’ã‚‹" },
                    { id: 5, name: "èµ¦ã—ã®èª“ã„", mp: 16, val: 52, valGrowth: 18, type: 'heal', isMagic: true, maxLevel: 150, effects: [{ target: "self", id: "barrier", stacks: 1, turns: 2 }], desc: "è‡ªå·±å›å¾©ã¨ãƒãƒªã‚¢ã§é•·æœŸæˆ¦ã‚’æ”¯ãˆã‚‹" },
                    { id: 6, name: "è£ãã®æ§", mp: 10, pow: 1.62, powGrowth: 0.23, maxLevel: 150, effects: [{ target: "enemy", id: "vulnerable", stacks: 1, turns: 2, log: "è£ãã§è„†å¼±ã«ãªã£ãŸï¼" }], desc: "è£ãã®çªãã§è„†å¼±ã‚’åˆ»ã‚€åˆ¶è£ã®ä¸€æ’ƒ" },
                    { id: 7, name: "æ‡ºæ‚”ã®å®£å‘Š", mp: 12, pow: 1.26, powGrowth: 0.18, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "weaken", stacks: 1, turns: 2, log: "æ‡ºæ‚”ã®å®£å‘Šã§å‹¢ã„ãŒå‰ŠãŒã‚ŒãŸï¼" }], desc: "æ•µç«åŠ›ã‚’æŠ‘ãˆã¤ã¤é€£æºã®ä¸‹åœ°ã‚’ä½œã‚‹" },
                    { id: 8, name: "é»’é¨ã®å¸³", mp: 12, pow: 0.9, powGrowth: 0.13, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "blind", stacks: 1, turns: 2, log: "é»’é¨ã®å¸³ã§è¦–ç•ŒãŒå¥ªã‚ã‚ŒãŸï¼" }, { target: "self", id: "attackUp", stacks: 1, turns: 2 }], desc: "æš—é—‡ã‚’ä»˜ä¸ã—ã€è‡ªèº«ã®æ”»ã‚ã‚’å¼·åŒ–ã™ã‚‹" },
                    { id: 9, name: "å½±ç‹©ã‚Š", mp: 16, pow: 2.34, powGrowth: 0.32, maxLevel: 150, critBonus: 5, critGrowth: 2, desc: "æš—é—‡ã®éš™ã‚’ç‹™ã„æ’ƒã¤é«˜ç«åŠ›ã®è¿½æ’ƒ" },
                    { id: 10, name: "å¿Œå…‰ã®é–", mp: 14, pow: 1.35, powGrowth: 0.18, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "silence", stacks: 1, turns: 1, log: "å¿Œå…‰ã®é–ã§æ²ˆé»™ã—ãŸï¼" }], desc: "æ•µã®è¡Œå‹•ã‚’ç¸›ã‚Šã€ä¸»å°æ¨©ã‚’æ¡ã‚‹" },
                    { id: 11, name: "å¤©åˆ‘ã®å®£å‘Š", mp: 24, pow: 3.06, powGrowth: 0.43, isMagic: true, maxLevel: 150, effects: [{ target: "enemy", id: "defenseDown", stacks: 2, turns: 2, log: "å¤©åˆ‘ã®å®£å‘Šã§å®ˆã‚ŠãŒå´©ã‚ŒãŸï¼" }], desc: "å¼·çƒˆãªåˆ¶è£ã§å®ˆã‚Šã‚’å´©ã—ã€ã¨ã©ã‚ã‚’ç‹™ã†" }
                ],
                passive: [
                    { id: 0, name: "ä¿¡ä»°", desc: "æœ€å¤§HP+15/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.maxHpFlat += 15 * d },
                    { id: 1, name: "è–ãªã‚‹å®ˆã‚Š", desc: "è¢«ãƒ€ãƒ¡è»½æ¸›+2%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.damageReduction += 2 * d },
                    { id: 2, name: "è–ç™’åŠ›", desc: "HPè‡ªå‹•å›å¾©+2/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.hpRegen += 2 * d },
                    { id: 3, name: "æ•¬è™”", desc: "MPè‡ªå‹•å›å¾©+1/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.mpRegen += 1 * d },
                    { id: 4, name: "ç¥ç½°", desc: "ä¸ãƒ€ãƒ¡å¢—åŠ +2%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.damageBoost += 2 * d },
                    { id: 5, name: "å®ˆè­·èª“ç´„", desc: "é˜²å¾¡åŠ›+4/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.defenseFlat += 4 * d }
                ]
            },
            monk: {
                name: "æ‹³é—˜å£«",
                active: [
                    { id: 0, name: "ç–¾é¢¨é€£æ‰“", mp: 4, pow: 0.54, powGrowth: 0.07, hits: 4, maxLevel: 150, desc: "ç™ºå‹•æ¡ä»¶: å¸¸æ™‚ä½¿ç”¨å¯ã€‚ç´ æ—©ã„é€£æ‰“ã§å‰Šã‚‹" },
                    { id: 1, name: "ãƒœãƒ‡ã‚£ãƒ»ã‚·ãƒ•ã‚¿ãƒ¼", mp: 7, pow: 0.99, powGrowth: 0.14, maxLevel: 150, effects: [{ target: "enemy", id: "weaken", stacks: 1, turns: 2, log: "å‹•ããŒéˆã£ãŸï¼" }], desc: "ç™ºå‹•æ¡ä»¶: ç›´å‰ã®æ”»æ’ƒãŒå‘½ä¸­ã€‚ãƒœãƒ‡ã‚£é€£æ‰“ã§ç›¸æ‰‹ã®å‹¢ã„ã‚’å‰Šã" },
                    { id: 2, name: "ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒ»ã‚¹ãƒªãƒƒãƒ—", mp: 9, pow: 0.9, powGrowth: 0.11, accuracyBonus: 5, accuracyGrowth: 2, maxLevel: 150, effects: [{ target: "self", id: "haste", stacks: 1, turns: 2 }, { target: "self", id: "reflect", stacks: 1, turns: 2 }], desc: "ç™ºå‹•æ¡ä»¶: æ•µã®æ”»æ’ƒã«åˆã‚ã›ã¦ä½¿ç”¨ã€‚å›é¿ã¨åæ’ƒã‚’ç‹™ã†" },
                    { id: 3, name: "ãƒ©ãƒƒã‚·ãƒ¥ãƒ»ã‚¢ãƒƒãƒ‘ãƒ¼", mp: 12, pow: 1.44, powGrowth: 0.18, critBonus: 8, critGrowth: 2, maxLevel: 150, desc: "ç™ºå‹•æ¡ä»¶: ç›´å‰ã«æ‹³æŠ€ã‚’ä½¿ç”¨ã€‚é€£æºã§å¨åŠ›ãŒå¢—ã™" },
                    { id: 4, name: "ãƒªãƒ³ã‚°ãƒ»ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³", mp: 14, pow: 0.81, powGrowth: 0.11, hits: 2, accuracyBonus: 10, accuracyGrowth: 3, maxLevel: 150, effects: [{ target: "enemy", id: "blind", stacks: 1, turns: 2, log: "è¦–ç•ŒãŒä¹±ã‚ŒãŸï¼" }], desc: "ç™ºå‹•æ¡ä»¶: æ•µãŒæš—é—‡ã€ã¾ãŸã¯è‡ªèº«ãŒè¿…é€Ÿã€‚é€£æ’ƒã§ä¸»å°æ¨©ã‚’æ¡ã‚‹" },
                    { id: 5, name: "ãƒ•ã‚£ãƒ‹ãƒƒã‚·ãƒ¥ãƒ»ãƒ–ãƒ­ãƒ¼", mp: 18, pow: 2.34, powGrowth: 0.32, critBonus: 12, critGrowth: 3, maxLevel: 150, desc: "ç™ºå‹•æ¡ä»¶: ç›´è¿‘ã§æ‹³æŠ€ãŒé€£ç¶šå‘½ä¸­ã€‚ç· ã‚ã®ä¸€æ’ƒ" },
                    { id: 6, name: "é‰„æ‹³è¡", mp: 10, pow: 1.89, powGrowth: 0.25, maxLevel: 150, effects: [{ target: "enemy", id: "defenseDown", stacks: 1, turns: 2, log: "é˜²å¾¡ãŒå‰ŠãŒã‚ŒãŸï¼" }], desc: "ç™ºå‹•æ¡ä»¶: å¸¸æ™‚ä½¿ç”¨å¯ã€‚é˜²å¾¡ã‚’å´©ã™é‡ã„ä¸€æ’ƒ" },
                    { id: 7, name: "ã‚¬ãƒ¼ãƒ‰ãƒ»ã‚¯ãƒ©ãƒƒã‚·ãƒ¥", mp: 16, pow: 2.43, powGrowth: 0.32, maxLevel: 150, effects: [{ target: "enemy", id: "defenseDown", stacks: 2, turns: 2, log: "ã‚¬ãƒ¼ãƒ‰ãŒå´©ã‚ŒãŸï¼" }], desc: "ç™ºå‹•æ¡ä»¶: æ•µãŒé˜²å¾¡ç³»çŠ¶æ…‹ã€‚ã‚¬ãƒ¼ãƒ‰ã‚’ç ´ç •ã™ã‚‹å¼·æ‰“" },
                    { id: 8, name: "è¸ã¿è¾¼ã¿ç ´ç •", mp: 14, pow: 2.07, powGrowth: 0.27, maxLevel: 150, effects: [{ target: "enemy", id: "attackDown", stacks: 1, turns: 2, log: "è¡æ’ƒã§å‹•ããŒéˆã£ãŸï¼" }], desc: "ç™ºå‹•æ¡ä»¶: è‡ªèº«ãŒé—˜å¿—/å¼·åŒ–ã€‚è¸ã¿è¾¼ã¿ã§æŠ¼ã—åˆ‡ã‚‹" },
                    { id: 9, name: "éœ‡è„šä¸€æ’ƒ", mp: 12, pow: 1.62, powGrowth: 0.22, accuracyBonus: 5, accuracyGrowth: 2, maxLevel: 150, effects: [{ target: "enemy", id: "blind", stacks: 1, turns: 2, log: "è¡æ’ƒã§è¦–ç•ŒãŒæºã‚ŒãŸï¼" }], desc: "ç™ºå‹•æ¡ä»¶: æ•µã®å‘½ä¸­ãŒé«˜ã„æ™‚ã«æœ‰åŠ¹ã€‚è¦–ç•Œã‚’ä¹±ã™è¡æ’ƒæ‹³" },
                    { id: 10, name: "ç ´å£Šã®æ‹³åœ§", mp: 18, pow: 1.8, powGrowth: 0.25, maxLevel: 150, effects: [{ target: "enemy", id: "vulnerable", stacks: 1, turns: 2, log: "é˜²å‹¢ãŒå´©ã‚ŒãŸï¼" }, { target: "enemy", id: "defenseDown", stacks: 1, turns: 2, log: "å®ˆã‚ŠãŒè£‚ã‘ãŸï¼" }], desc: "ç™ºå‹•æ¡ä»¶: æ•µãŒå¼±ä½“/è„†å¼±/è„†ç”²ã€‚åœ§ã§é€£æºã‚’é€šã™" },
                    { id: 11, name: "è¦‡æ‹³ãƒ»æ¥µ", mp: 28, pow: 3.78, powGrowth: 0.54, critBonus: 10, critGrowth: 3, maxLevel: 150, effects: [{ target: "self", id: "attackDown", stacks: 1, turns: 2 }], desc: "ç™ºå‹•æ¡ä»¶: ç›´å‰ã«è¢«ãƒ€ãƒ¡ã€‚æºœã‚ã®æ±ºå®šæ‰“" }
                ],
                passive: [
                    { id: 0, name: "ä½“è¡“é›éŒ¬", desc: "STR+2/ãƒ¬ãƒ™ãƒ« & DEX+2/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => { Game.player.str += 2 * d; Game.player.dex += 2 * d; } },
                    { id: 1, name: "æ°—ã®æµã‚Œ", desc: "æœ€å¤§HP+3/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.maxHpFlat += 3 * d },
                    { id: 2, name: "å†…åŠŸ", desc: "æœ€å¤§MP+3/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.maxMpFlat += 3 * d },
                    { id: 3, name: "é—˜å¿—", desc: "ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸+8%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.critDamage += 8 * d },
                    { id: 4, name: "éœèº«", desc: "å›é¿ç‡+2%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.evasionRate += 2 * d },
                    { id: 5, name: "é—˜æ°—å¸å", desc: "å¸è¡€ç‡+2%/ãƒ¬ãƒ™ãƒ«", maxLevel: 150, apply: (d) => Game.player.leechRate += 2 * d }
                ]
            }
        };

        const PassiveMilestoneBonuses = {
            warrior: {
                0: { 10: { stats: { attackFlat: 15 } }, 30: { stats: { critRate: 5 } }, 50: { stats: { damageBoost: 10 } } },
                1: { 10: { stats: { maxHpFlat: 120 } }, 30: { stats: { defenseFlat: 15 } }, 50: { stats: { damageReduction: 10 } } },
                2: { 10: { stats: { leechRate: 5 } }, 30: { stats: { hpRegen: 5 } }, 50: { stats: { damageBoost: 5 } } },
                3: { 10: { stats: { defenseFlat: 20 } }, 30: { stats: { damageReduction: 5 } }, 50: { stats: { attackFlat: 20 } } },
                4: { 10: { stats: { defenseFlat: 30 } }, 30: { stats: { maxHpFlat: 150 } }, 50: { stats: { damageReduction: 8 } } },
                5: { 10: { stats: { attackFlat: 12 } }, 30: { stats: { damageBoost: 10 } }, 50: { stats: { critRate: 5 } } }
            },
            mage: {
                0: { 10: { stats: { mPen: 8 } }, 30: { stats: { critRate: 5 } }, 50: { stats: { damageBoost: 10 } } },
                1: { 10: { stats: { mpRegen: 5 } }, 30: { stats: { maxMpFlat: 120 } }, 50: { stats: { skillMpDiscount: 5 } } },
                2: { 10: { stats: { mpRegen: 3 } }, 30: { stats: { mpRegen: 5 } }, 50: { stats: { maxMpFlat: 80 } } },
                3: { 10: { stats: { critDamage: 20 } }, 30: { stats: { accuracy: 10 } }, 50: { stats: { damageBoost: 10 } } },
                4: { 10: { stats: { damageBoost: 5 } }, 30: { stats: { mPen: 8 } }, 50: { stats: { critRate: 5 } } },
                5: { 10: { stats: { critRate: 5 } }, 30: { stats: { critDamage: 30 } }, 50: { stats: { damageBoost: 10 } } }
            },
            thief: {
                0: { 10: { stats: { accuracy: 10 } }, 30: { stats: { evasionRate: 5 } }, 50: { stats: { critRate: 5 } } },
                1: { 10: { stats: { evasionRate: 5 } }, 30: { stats: { damageReduction: 5 } }, 50: { stats: { accuracy: 10 } } },
                2: { 10: { stats: { rareFind: 10 } }, 30: { stats: { affixFind: 10 } }, 50: { stats: { eliteEncounter: 10 } } },
                3: { 10: { stats: { goldBoost: 10 } }, 30: { stats: { expBoost: 10 } }, 50: { stats: { damageBoost: 10 } } },
                4: { 10: { stats: { critDamage: 20 } }, 30: { stats: { critRate: 5 } }, 50: { stats: { damageBoost: 10 } } },
                5: { 10: { stats: { accuracy: 10 } }, 30: { stats: { critRate: 5 } }, 50: { stats: { damageBoost: 10 } } }
            },
            ranger: {
                0: { 10: { stats: { accuracy: 10 } }, 30: { stats: { critRate: 5 } }, 50: { stats: { damageBoost: 10 } } },
                1: { 10: { stats: { critDamage: 20 } }, 30: { stats: { critRate: 5 } }, 50: { stats: { damageBoost: 10 } } },
                2: { 10: { stats: { accuracy: 10 } }, 30: { stats: { critRate: 5 } }, 50: { stats: { damageBoost: 10 } } },
                3: { 10: { stats: { evasionRate: 5 } }, 30: { stats: { damageReduction: 5 } }, 50: { stats: { accuracy: 10 } } },
                4: { 10: { stats: { rareFind: 10 } }, 30: { stats: { affixFind: 10 } }, 50: { stats: { eliteEncounter: 10 } } },
                5: { 10: { stats: { goldBoost: 10 } }, 30: { stats: { expBoost: 5 } }, 50: { stats: { damageBoost: 10 } } }
            },
            paladin: {
                0: { 10: { stats: { hpRegen: 5 } }, 30: { stats: { maxHpFlat: 120 } }, 50: { stats: { damageReduction: 10 } } },
                1: { 10: { stats: { defenseFlat: 20 } }, 30: { stats: { damageReduction: 5 } }, 50: { stats: { maxHpFlat: 120 } } },
                2: { 10: { stats: { maxHpFlat: 80 } }, 30: { stats: { hpRegen: 5 } }, 50: { stats: { damageReduction: 5 } } },
                3: { 10: { stats: { maxMpFlat: 60 } }, 30: { stats: { mpRegen: 3 } }, 50: { stats: { maxMpFlat: 80 } } },
                4: { 10: { stats: { critRate: 5 } }, 30: { stats: { critDamage: 20 } }, 50: { stats: { damageBoost: 10 } } },
                5: { 10: { stats: { damageReduction: 5 } }, 30: { stats: { defenseFlat: 25 } }, 50: { stats: { maxHpFlat: 150 } } }
            },
            monk: {
                0: { 10: { stats: { accuracy: 10 } }, 30: { stats: { critRate: 5 } }, 50: { stats: { damageBoost: 10 } } },
                1: { 10: { stats: { maxHpFlat: 80 } }, 30: { stats: { hpRegen: 4 } }, 50: { stats: { damageReduction: 5 } } },
                2: { 10: { stats: { maxMpFlat: 60 } }, 30: { stats: { mpRegen: 2 } }, 50: { stats: { mpRegen: 3 } } },
                3: { 10: { stats: { critRate: 5 } }, 30: { stats: { critDamage: 20 } }, 50: { stats: { damageBoost: 10 } } },
                4: { 10: { stats: { evasionRate: 5 } }, 30: { stats: { accuracy: 10 } }, 50: { stats: { damageReduction: 5 } } },
                5: { 10: { stats: { leechRate: 5 } }, 30: { stats: { hpRegen: 5 } }, 50: { stats: { damageBoost: 5 } } }
            }
        };

        const StatusDefs = {
            poison: { id: 'poison', name: 'æ¯’', effectType: 'poison', stackable: true, maxStacks: 1, defaultTurns: 3, icon: 'fa-skull-crossbones', desc: 'ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«æœ€å¤§HPã®3%Ã—ã‚¹ã‚¿ãƒƒã‚¯ï¼ˆæœ€å¤§1ï¼‰ã€‚é˜²å¾¡ã§è»½æ¸›ã€æœ€ä½1%ä¿è¨¼ã€‚' },
            bleed: { id: 'bleed', name: 'å‡ºè¡€', effectType: 'bleed', stackable: true, maxStacks: 5, defaultTurns: 3, icon: 'fa-droplet', desc: 'ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«(å›ºå®š2+STRÃ—0.3)Ã—ã‚¹ã‚¿ãƒƒã‚¯ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚' },
            weaken: { id: 'weaken', name: 'å¼±ä½“', effectType: 'weaken', stackable: true, maxStacks: 5, defaultTurns: 2, icon: 'fa-down-long', desc: 'ä¸ãƒ€ãƒ¡ãŒä½ä¸‹ã™ã‚‹ã€‚' },
            vulnerable: { id: 'vulnerable', name: 'è„†å¼±', effectType: 'vulnerable', stackable: true, maxStacks: 3, defaultTurns: 2, icon: 'fa-shield-halved', desc: 'è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒå¢—åŠ ã™ã‚‹çŠ¶æ…‹ã€‚' },
            buff: { id: 'buff', name: 'å¼·åŒ–', effectType: 'buff', stackable: true, maxStacks: 3, defaultTurns: 2, icon: 'fa-arrow-up-long', desc: 'ä¸ãƒ€ãƒ¡ãŒå¢—åŠ ã™ã‚‹ã€‚' },
            attackUp: { id: 'attackUp', name: 'é—˜å¿—', effectType: 'attackUp', stackable: true, maxStacks: 5, defaultTurns: 3, icon: 'fa-arrow-up-long', desc: 'æ”»æ’ƒåŠ›ãŒä¸Šæ˜‡ã™ã‚‹ã€‚' },
            attackDown: { id: 'attackDown', name: 'è¡°å¼±', effectType: 'attackDown', stackable: true, maxStacks: 5, defaultTurns: 3, icon: 'fa-arrow-down-long', desc: 'æ”»æ’ƒåŠ›ãŒä½ä¸‹ã™ã‚‹ã€‚' },
            defenseUp: { id: 'defenseUp', name: 'å®ˆå‹¢', effectType: 'defenseUp', stackable: true, maxStacks: 4, defaultTurns: 3, icon: 'fa-shield-halved', desc: 'é˜²å¾¡åŠ›ãŒä¸Šæ˜‡ã™ã‚‹ã€‚' },
            defenseDown: { id: 'defenseDown', name: 'è„†ç”²', effectType: 'defenseDown', stackable: true, maxStacks: 4, defaultTurns: 3, icon: 'fa-shield', desc: 'é˜²å¾¡åŠ›ãŒä½ä¸‹ã™ã‚‹ã€‚' },
            freeze: { id: 'freeze', name: 'å‡çµ', effectType: 'freeze', stackable: false, maxStacks: 1, defaultTurns: 1, icon: 'fa-snowflake', desc: 'è¡Œå‹•ä¸èƒ½ã€‚è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã§è§£é™¤ã€‚' },
            blind: { id: 'blind', name: 'æš—é—‡', effectType: 'blind', stackable: true, maxStacks: 3, defaultTurns: 3, icon: 'fa-eye-slash', desc: 'å‘½ä¸­ç‡ã¨ä¼šå¿ƒç‡ãŒä½ä¸‹ã™ã‚‹ã€‚' },
            silence: { id: 'silence', name: 'æ²ˆé»™', effectType: 'silence', stackable: false, maxStacks: 1, defaultTurns: 2, icon: 'fa-hand-sparkles', desc: 'ã‚¹ã‚­ãƒ«ä½¿ç”¨ä¸å¯ã€‚' },
            haste: { id: 'haste', name: 'è¿…é€Ÿ', effectType: 'haste', stackable: true, maxStacks: 3, defaultTurns: 3, icon: 'fa-person-running', desc: 'å‘½ä¸­ç‡ã¨å›é¿ç‡ãŒä¸Šæ˜‡ã™ã‚‹ã€‚' },
            barrier: { id: 'barrier', name: 'ãƒãƒªã‚¢', effectType: 'barrier', stackable: true, maxStacks: 3, defaultTurns: 3, icon: 'fa-layer-group', shieldPerStack: 30, desc: 'ä¸€å®šé‡ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å¸åã™ã‚‹ã€‚' },
            reflect: { id: 'reflect', name: 'åå°„', effectType: 'reflect', stackable: true, maxStacks: 3, defaultTurns: 2, icon: 'fa-retweet', desc: 'è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã®ä¸€éƒ¨ã‚’åå°„ã™ã‚‹ã€‚' },
            taunt: { id: 'taunt', name: 'æŒ‘ç™º', effectType: 'taunt', stackable: true, maxStacks: 2, defaultTurns: 2, icon: 'fa-user-slash', desc: 'ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’å¼•ãã¤ã‘ã‚‹ã€‚' },
            potionRegenHp: { id: 'potionRegenHp', name: 'å†ç”Ÿ(HP)', effectType: 'regen', stackable: true, maxStacks: 3, defaultTurns: 3, icon: 'fa-heart-pulse', regenPerStack: 6, resource: 'hp', desc: 'ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã«HPãŒå›å¾©ã™ã‚‹ã€‚' },
            potionRegenMp: { id: 'potionRegenMp', name: 'å†ç”Ÿ(MP)', effectType: 'regen', stackable: true, maxStacks: 3, defaultTurns: 3, icon: 'fa-circle-nodes', regenPerStack: 4, resource: 'mp', desc: 'ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã«MPãŒå›å¾©ã™ã‚‹ã€‚' },
            potionNextHitBoost: { id: 'potionNextHitBoost', name: 'çŒ›æ’ƒ', effectType: 'nextHitBoost', stackable: false, maxStacks: 1, defaultTurns: Infinity, icon: 'fa-hand-fist', desc: 'æ¬¡ã®1å›ã ã‘ä¸ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒå¢—åŠ ã™ã‚‹ã€‚å‘½ä¸­æ™‚ã«æ¶ˆè²»ã€‚' },
            potionLeechBoost: { id: 'potionLeechBoost', name: 'å¸ç²¾', effectType: 'leechBoost', stackable: false, maxStacks: 1, defaultTurns: 1, icon: 'fa-droplet', desc: 'æ¬¡ã®1ã‚¿ãƒ¼ãƒ³å¸åç‡ãŒä¸Šæ˜‡ã™ã‚‹ã€‚' },
            potionReflectGuard: { id: 'potionReflectGuard', name: 'é¡å®ˆ', effectType: 'reflectGuard', stackable: true, maxStacks: 9, defaultTurns: Infinity, icon: 'fa-shield', desc: 'æ¬¡ã«å—ã‘ã‚‹åå°„ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹ã€‚' },
            potionSkillMpCut: { id: 'potionSkillMpCut', name: 'ç¯€é­”', effectType: 'skillMpCut', stackable: false, maxStacks: 1, defaultTurns: Infinity, icon: 'fa-wand-magic', desc: 'æ¬¡ã®ã‚¹ã‚­ãƒ«ã®MPæ¶ˆè²»ãŒè»½æ¸›ã•ã‚Œã‚‹ã€‚ä½¿ç”¨æ™‚ã«æ¶ˆè²»ã€‚' }
        };

        const EnemyTiers = [
            [
                { name: "ã‚¹ãƒ©ã‚¤ãƒ ", icon: "fa-bacteria", onHitEffects: [{ id: "poison", stacks: 1, turns: 3, chance: 0.25, log: "ç²˜æ¶²ã§æ¯’ã‚’å—ã‘ãŸï¼" }] },
                { name: "ã‚³ã‚¦ãƒ¢ãƒª", icon: "fa-moon", onHitEffects: [{ id: "blind", stacks: 1, turns: 2, chance: 0.2, log: "ç¾½ã°ãŸãã§è¦–ç•ŒãŒä¹±ã‚ŒãŸï¼" }] },
                { name: "ã‚³ãƒ¢ãƒ³ãƒã‚°", icon: "fa-bug"},
                { name: "é‡çŠ¬", icon: "fa-dog", onHitEffects: [{ id: "bleed", stacks: 1, turns: 2, chance: 0.25, log: "ç‰™ã§è£‚ã‹ã‚ŒãŸï¼" }] },
                { name: "è‰ã®ç²¾", icon: "fa-leaf", onHitEffects: [{ id: "weaken", stacks: 1, turns: 2, chance: 0.25, log: "èƒå­ã§å¼±ä½“åŒ–ã—ãŸï¼" }] }
            ],
            [
                { name: "ã‚´ãƒ–ãƒªãƒ³", icon: "fa-user-ninja"},
                { name: "ã‚¹ã‚±ãƒ«ãƒˆãƒ³", icon: "fa-skull", onHitEffects: [{ id: "bleed", stacks: 1, turns: 2, chance: 0.25, log: "éª¨åˆƒã§åˆ‡ã‚Šè£‚ã‹ã‚ŒãŸï¼" }] },
                { name: "å¤§èœ˜è››", icon: "fa-spider", onHitEffects: [{ id: "poison", stacks: 1, turns: 3, chance: 0.3, log: "æ¯’ç³¸ãŒçµ¡ã¿ã¤ã„ãŸï¼" }] },
                { name: "å°æ‚ªé­”", icon: "fa-ghost", onHitEffects: [{ id: "silence", stacks: 1, turns: 2, chance: 0.2, log: "å‘ªã„ã§æ²ˆé»™ã—ãŸï¼" }] },
                { name: "é‡ç”Ÿç‹¼", icon: "fa-paw"}
            ],
            [
                { name: "æ´çªŸãƒˆã‚«ã‚²", icon: "fa-dragon", onHitEffects: [{ id: "defenseDown", stacks: 1, turns: 2, chance: 0.2, log: "ç¡¬ã„é±—ã§å®ˆã‚ŠãŒå‰ŠãŒã‚ŒãŸï¼" }] },
                { name: "ã‚¹ãƒ”ã‚¢ã‚´ãƒ–ãƒªãƒ³", icon: "fa-user-ninja"},
                { name: "éª¨æˆ¦å£«", icon: "fa-skull"},
                { name: "å¤œå½±", icon: "fa-ghost", onHitEffects: [{ id: "blind", stacks: 1, turns: 2, chance: 0.25, log: "é—‡ã®ä¸€æ’ƒã§è¦–ç•ŒãŒéœã‚“ã ï¼" }] },
                { name: "å²©ãƒˆã‚«ã‚²", icon: "fa-mountain"} 
            ],
            [
                { name: "ã‚´ãƒ¼ãƒ¬ãƒ ", icon: "fa-mountain"},
                { name: "ã‚·ãƒ£ãƒ‰ã‚¦", icon: "fa-ghost"},
                { name: "ãƒãƒ³ã‚·ãƒ¼", icon: "fa-skull", onHitEffects: [{ id: "blind", stacks: 1, turns: 2, chance: 0.25, log: "å«ã³ã§è¦–ç•ŒãŒæ­ªã‚“ã ï¼" }] },
                { name: "é‹¼é‰„ç£", icon: "fa-hippo"},
                { name: "é›·é³¥", icon: "fa-bolt", onHitEffects: [{ id: "attackDown", stacks: 1, turns: 2, chance: 0.2, log: "é›·æ’ƒã§å‹•ããŒéˆã£ãŸï¼" }] }
            ],
            [
                { name: "ç‚ã®ç²¾éœŠ", icon: "fa-fire", onHitEffects: [{ id: "weaken", stacks: 1, turns: 2, chance: 0.25, log: "ç¼ç†±ã§åŠ›ãŒè½ã¡ãŸï¼" }] },
                { name: "æ°·ã®ç²¾éœŠ", icon: "fa-snowflake"},
                { name: "æ¯’ã‚¯ãƒ¢å¥³ç‹", icon: "fa-spider", onHitEffects: [{ id: "poison", stacks: 2, turns: 3, chance: 0.3, log: "å¼·ã„æ¯’ãŒå›ã£ãŸï¼" }] },
                { name: "é‚ªæ‚ªãªé­”å°å¸«", icon: "fa-hat-wizard", onHitEffects: [{ id: "silence", stacks: 1, turns: 2, chance: 0.25, log: "å‘ªæ–‡ã§æ²ˆé»™ã—ãŸï¼" }] },
                { name: "æ·±æµ·é­”", icon: "fa-fish"}
            ],
            [
                { name: "è’¼ç‹¼", icon: "fa-dog", onHitEffects: [{ id: "bleed", stacks: 1, turns: 3, chance: 0.3, log: "è’¼ã„ç‰™ã§è£‚ã‹ã‚ŒãŸï¼" }] },
                { name: "é—‡é¨å£«", icon: "fa-chess-knight", onHitEffects: [{ id: "attackDown", stacks: 1, turns: 2, chance: 0.25, log: "é—‡ã®åœ§ã§æ”»æ’ƒãŒä¸‹ãŒã£ãŸï¼" }] },
                { name: "æ­»éœŠé¨å£«", icon: "fa-skull"},
                { name: "é›·ç£", icon: "fa-bolt", onHitEffects: [{ id: "blind", stacks: 1, turns: 2, chance: 0.25, log: "é›·æ’ƒã§è¦–ç•ŒãŒæºã‚ŒãŸï¼" }] },
                { name: "ç•°ç•Œã®å½±", icon: "fa-ghost", onHitEffects: [{ id: "silence", stacks: 1, turns: 2, chance: 0.25, log: "ç•°ç•Œã®æ°—é…ã§æ²ˆé»™ã—ãŸï¼" }] }
            ],
            [
                { name: "ç¼ç†±ç«œ", icon: "fa-dragon"},
                { name: "å‡çµç«œ", icon: "fa-dragon"},
                { name: "æ¼†é»’ã®ç¿¼", icon: "fa-crow", onHitEffects: [{ id: "blind", stacks: 1, turns: 2, chance: 0.3, log: "é»’ç¿¼ãŒè¦–ç•Œã‚’è¦†ã£ãŸï¼" }] },
                { name: "æ·±ç·‘ã®ç£", icon: "fa-hippo"},
                { name: "ç ´ç •ã‚´ãƒ¼ãƒ¬ãƒ ", icon: "fa-mountain", onHitEffects: [{ id: "defenseDown", stacks: 1, turns: 2, chance: 0.3, log: "è¡æ’ƒã§é˜²å¾¡ãŒå´©ã‚ŒãŸï¼" }] }
            ],
            [
                { name: "è™šç„¡ã®å½±", icon: "fa-ghost", onHitEffects: [{ id: "silence", stacks: 1, turns: 2, chance: 0.3, log: "è™šç„¡ã®åŠ›ã§æ²ˆé»™ã—ãŸï¼" }] },
                { name: "æ˜Ÿå±‘ã®é­”ç£", icon: "fa-crow"},
                { name: "æ·±æµ·ç‹", icon: "fa-fish"},
                { name: "é›·å¸", icon: "fa-bolt", onHitEffects: [{ id: "blind", stacks: 1, turns: 2, chance: 0.3, log: "é›·å¸ã®å…‰ã§è¦–ç•ŒãŒä¹±ã‚ŒãŸï¼" }] },
                { name: "å†¥ç•Œã®é¨å£«", icon: "fa-chess-knight"}


            ],
            [
                { name: "ç„ç‚ç£", icon: "fa-fire"},
                { name: "æ°·æ™¶ç£", icon: "fa-snowflake"},
                { name: "æ·±æ·µç«œ", icon: "fa-dragon", onHitEffects: [{ id: "vulnerable", stacks: 1, turns: 2, chance: 0.25, log: "æ·±æ·µã®å’†å“®ã§è„†å¼±ã«ãªã£ãŸï¼" }] },
                { name: "çµ¶å«ã®äº¡éœŠ", icon: "fa-skull", onHitEffects: [{ id: "silence", stacks: 1, turns: 2, chance: 0.3, log: "çµ¶å«ã§æ²ˆé»™ã—ãŸï¼" }] },
                { name: "å¥ˆè½ã®å·¨å½±", icon: "fa-ghost"}
            ],
            [
                { name: "çµ‚ç„‰ç«œ", icon: "fa-dragon", onHitEffects: [{ id: "attackDown", stacks: 1, turns: 2, chance: 0.3, log: "çµ‚ç„‰ã®çˆªã§æ”»æ’ƒãŒéˆã£ãŸï¼" }] },
                { name: "æ˜Ÿæ»…ã®å½±", icon: "fa-ghost"},
                { name: "ç„¡é™ã®å·¨ç£", icon: "fa-hippo"},
                { name: "å¯©åˆ¤ã®é¨å£«", icon: "fa-chess-knight"},
                { name: "çµ‚æœ«ã®é­”å°", icon: "fa-hat-wizard", onHitEffects: [{ id: "weaken", stacks: 1, turns: 2, chance: 0.3, log: "çµ‚æœ«é­”æ³•ã§å¼±ä½“åŒ–ã—ãŸï¼" }] }
            ]
        ];

        const ElitePrefixes = {
            1: ["å‡¶æš´ãª", "è’ã€…ã—ã„", "çŒ›ã‚‹"],
            2: ["æ®‹è™ãª", "ç‹‚æˆ¦å£«ã®", "è¡€å¡—ã‚‰ã‚ŒãŸ"],
            3: ["è¦‡é“ã®", "ç ´å£Šè€…ã®", "ç½ç¦ã®"],
            4: ["ç ´æ»…ã®", "å¥ˆè½ã®", "æ–­ç½ªã®"],
            5: ["çµ‚ç„‰ã®", "ç¥ç½°ã®", "æ»…ã³ã®"]
        };

        const EliteRankWeights = [
            { rank: 1, weight: 50 },
            { rank: 2, weight: 30 },
            { rank: 3, weight: 15 },
            { rank: 4, weight: 4, minEncounter: 70 },
            { rank: 5, weight: 1, minEncounter: 80 }
        ];

        const EliteStatBoostPool = [
            { key: "hp", label: "HP", multiplier: 1.3 },
            { key: "str", label: "æ”»æ’ƒ", multiplier: 1.25 },
            { key: "exp", label: "çµŒé¨“å€¤", multiplier: 1.4 },
            { key: "loot", label: "æˆ¦åˆ©å“", multiplier: 1.25 }
        ];

        const BossFloors = [
            50, 100, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000
        ];
        const BossRushStartFloor = 5001;
        const BossRushNoDropStartFloor = BossRushStartFloor;
        const MaxFloorLimit = 10000;
        const BossDropChance = 0.05;
        const NormalDropChance = 0.95;
        const RoadLegendaryDropChance = 0.008;
        const RoadLegendaryNormalChance = 0.992;
        const BossRushBaseScale = 1;
        const BossRushScaleStep = 3;
        const BossRushBaseStats = {
            hp: 561543,
            str: 34846,
            def: 4215,
            acc: 2312,
            eva: 1004,
            exp: 0
        };
        const BossRushBuffConfig = {
            extraActionChance: 0.25,
            startBonusActionChance: 0.18,
            followUpMultiplier: 0.6,
            healCounterMultiplier: 0.35,
            mistakeCounterMultiplier: 0.45,
            statusRandomChance: 0.35,
            statusGainBoost: 0.06,
            critDefBoost: 0.08,
            hitTakenBoost: 0.03,
            turnAtkBoost: 0.05,
            turnDefBoost: 0.05,
            hp50Boost: 0.35,
            hpMissingDamageBoost: 0.6,
            buffGuardPerBuff: 0.05,
            buffGuardMax: 0.35,
            statusGuardPerStack: 0.06,
            statusGuardMax: 0.4,
            damageSpreadPct: 0.3,
            smallDamageNullifyPct: 0.02,
            reflectPct: 0.3,
            leechPct: 0.2,
            reviveHpPct: 0.5,
            baseCritMultiplier: 1.5
        };
        const DxFloorStart = BossRushStartFloor;
        const DxBaseMultiplier = 2.4;
        const DxFloorScaleRate = 0.03;
        const DxBonusMultiplier = 1.45;
        const BossDxExtraMultiplier = 1.15;
        const CombatBalance = {
            playerNormalPow: 0.95,
            playerSkillPow: 1,
            enemyNormalPow: 0.95,
            enemySkillPow: 1
        };
        const EnemySkillPools = {
            balanced: [
                { name: "å‡è¡¡ã®ä¸€æ’ƒ", pow: 0.95, effects: [{ target: "player", id: "weaken", stacks: 1, turns: 2, log: "ä½“å‹¢ãŒå´©ã‚ŒãŸï¼" }] }
            ],
            attack: [
                { name: "å¼·æ’ƒ", pow: 1.2, effects: [{ target: "player", id: "defenseDown", stacks: 1, turns: 2, log: "é˜²å¾¡ãŒå‰Šã‚‰ã‚ŒãŸï¼" }] }
            ],
            speed: [
                { name: "è¿…æ’ƒä¹±èˆ", pow: 0.6, hits: 2, effects: [{ target: "player", id: "bleed", stacks: 1, turns: 2, log: "ç´ æ—©ã„æ–¬æ’ƒã§å‡ºè¡€ï¼" }] }
            ],
            defense: [
                { name: "å®ˆå‹¢ã®æ§‹ãˆ", pow: null, effects: [{ target: "self", id: "defenseUp", stacks: 2, turns: 3 }, { target: "self", id: "barrier", stacks: 1, turns: 2 }], log: "å®ˆã‚ŠãŒå¼·åŒ–ã•ã‚ŒãŸï¼" }
            ]
        };
        const BossExtraSkillPool = [
            { name: "DXãƒãƒ¼ã‚¹ãƒˆ", pow: 1.1, effects: [{ target: "player", id: "vulnerable", stacks: 1, turns: 2, log: "DXã®è¡æ’ƒã§è„†å¼±ã«ãªã£ãŸï¼" }] },
            { name: "DXå¼·åŒ–", pow: null, effects: [{ target: "self", id: "attackUp", stacks: 2, turns: 3 }, { target: "self", id: "haste", stacks: 1, turns: 2 }], log: "DXã®åŠ›ã§å¼·åŒ–ã•ã‚ŒãŸï¼" },
            { name: "DXå´©ã—", pow: 0.85, hits: 2, effects: [{ target: "player", id: "attackDown", stacks: 1, turns: 2, log: "æ”»æ’ƒãŒéˆã£ãŸï¼" }] }
        ];
        const BossRushBuffCategories = [
            {
                id: "basic",
                colorClass: "bg-rose-100 text-rose-600",
                icon: "fa-arrow-up",
                buffs: [
                    { id: "br_basic_hp", shortLabel: "HP+100", label: "ä½“åŠ›+100%", applySpawn: (enemy) => { enemy.maxHp = Math.floor(enemy.maxHp * 2); enemy.hp = enemy.maxHp; } },
                    { id: "br_basic_atk", shortLabel: "æ”»+100", label: "æ”»æ’ƒ+100%", applySpawn: (enemy) => { enemy.str = Math.floor(enemy.str * 2); } },
                    { id: "br_basic_def", shortLabel: "é˜²+50", label: "é˜²å¾¡+50%", applySpawn: (enemy) => { enemy.def = Math.floor(enemy.def * 1.5); } },
                    { id: "br_basic_extra_action", shortLabel: "è¡Œ+1", label: "è¡Œå‹•+1(ç‡)" },
                    { id: "br_basic_crit_rate", shortLabel: "ä¼šå¿ƒ+30", label: "ä¼šå¿ƒç‡+30%" },
                    { id: "br_basic_crit_dmg", shortLabel: "ä¼šå¿ƒD+100", label: "ä¼šå¿ƒDMG+100%" }
                ]
            },
            {
                id: "behavior",
                colorClass: "bg-sky-100 text-sky-600",
                icon: "fa-shield-halved",
                buffs: [
                    { id: "br_blue_reduce_30", shortLabel: "è¢«-30", label: "è¢«ãƒ€ãƒ¡-30%" },
                    { id: "br_blue_reduce_50", shortLabel: "è¢«-50", label: "è¢«ãƒ€ãƒ¡-50%" },
                    { id: "br_blue_nullify", shortLabel: "å°ç„¡åŠ¹", label: "å°ãƒ€ãƒ¡ç„¡åŠ¹" },
                    { id: "br_blue_reflect", shortLabel: "åå°„30", label: "åå°„30%" },
                    { id: "br_blue_leech", shortLabel: "å¸å20", label: "ä¸ãƒ€ãƒ¡å¸å20%" },
                    { id: "br_blue_ignore_def", shortLabel: "é˜²ç„¡è¦–", label: "é˜²å¾¡ç„¡è¦–" },
                    { id: "br_blue_spread", shortLabel: "åˆ†æ•£", label: "è¢«ãƒ€ãƒ¡åˆ†æ•£" }
                ]
            },
            {
                id: "scaling",
                colorClass: "bg-emerald-100 text-emerald-600",
                icon: "fa-seedling",
                buffs: [
                    { id: "br_green_turn_atk", shortLabel: "æ”»UP/T", label: "ã‚¿ãƒ¼ãƒ³æ”»æ’ƒUP" },
                    { id: "br_green_turn_def", shortLabel: "é˜²UP/T", label: "ã‚¿ãƒ¼ãƒ³é˜²å¾¡UP" },
                    { id: "br_green_hit_scale", shortLabel: "è¢«å¼¾UP", label: "è¢«å¼¾å¼·åŒ–" },
                    { id: "br_green_hp50_boost", shortLabel: "åŠå¼·åŒ–", label: "HP50%å¼·åŒ–" },
                    { id: "br_green_hp30_extra", shortLabel: "ç€•æ­»è¡Œ+1", label: "HP30%ã§è¡Œ+1" }
                ]
            },
            {
                id: "meta",
                colorClass: "bg-amber-100 text-amber-600",
                icon: "fa-bullseye",
                buffs: [
                    { id: "br_yellow_heal_counter", shortLabel: "å›å¾©åæ’ƒ", label: "å›å¾©åæ’ƒ" },
                    { id: "br_yellow_buff_guard", shortLabel: "ãƒãƒ•ç›¾", label: "ãƒãƒ•æ•°ã§è»½æ¸›" },
                    { id: "br_yellow_debuff_counter", shortLabel: "ç•°å¸¸åæ’ƒ", label: "ç•°å¸¸è§£é™¤åæ’ƒ" },
                    { id: "br_yellow_crit_def", shortLabel: "ä¼šå¿ƒé˜²", label: "ä¼šå¿ƒã§é˜²å¾¡UP" },
                    { id: "br_yellow_status_limit", shortLabel: "ç•°å¸¸1ç¨®", label: "ç•°å¸¸1ç¨®" }
                ]
            },
            {
                id: "pattern",
                colorClass: "bg-purple-100 text-purple-600",
                icon: "fa-repeat",
                buffs: [
                    { id: "br_purple_double", shortLabel: "2é€£è¡Œå‹•", label: "2é€£ç¶šè¡Œå‹•" },
                    { id: "br_purple_follow", shortLabel: "è¿½æ’ƒ", label: "è¿½æ’ƒ" },
                    { id: "br_purple_start_bonus", shortLabel: "é–‹å¹•è¿½", label: "é–‹å¹•è¿½åŠ è¡Œå‹•" }
                ]
            },
            {
                id: "status",
                colorClass: "bg-orange-100 text-orange-600",
                icon: "fa-biohazard",
                buffs: [
                    { id: "br_orange_random", shortLabel: "ç•°å¸¸ä»˜ä¸", label: "ãƒ©ãƒ³ãƒ€ãƒ ç•°å¸¸" },
                    { id: "br_orange_immune", shortLabel: "ç•°å¸¸ç„¡åŠ¹", label: "ç•°å¸¸ç„¡åŠ¹" },
                    { id: "br_orange_gain", shortLabel: "ç•°å¸¸å¼·åŒ–", label: "ç•°å¸¸ã§å¼·åŒ–" },
                    { id: "br_orange_guard", shortLabel: "ç•°å¸¸ç›¾", label: "ç•°å¸¸æ•°ã§è»½æ¸›" }
                ]
            },
            {
                id: "late",
                minFloor: 1031,
                colorClass: "bg-red-100 text-red-600",
                icon: "fa-skull",
                buffs: [
                    { id: "br_red_revive", shortLabel: "å¾©æ´»", label: "å¾©æ´»" },
                    { id: "br_red_ignore_def", shortLabel: "é˜²ç„¡è¦–æ”»", label: "é˜²ç„¡è¦–æ”»æ’ƒ" },
                    { id: "br_red_missing_hp", shortLabel: "æ¸›HPç«åŠ›", label: "æ¸›HPç«åŠ›" },
                    { id: "br_red_mistake", shortLabel: "ãƒŸã‚¹åå¿œ", label: "ãƒŸã‚¹å³åå¿œ" }
                ]
            }
        ];

        const getBossRushBuffCount = (floor) => {
            if (!Game.isBossRush || floor < BossRushStartFloor) return 0;
            const offset = floor - BossRushStartFloor;
            if (offset <= 49) return 1;
            if (offset <= 99) return 2;
            if (offset <= 149) return 3;
            if (offset <= 199) return 4;
            return 5;
        };

        const getBossRushBuffs = (enemy) => (Array.isArray(enemy?.bossRushBuffs) ? enemy.bossRushBuffs : []);

        const hasBossRushBuff = (enemy, buffId) => getBossRushBuffs(enemy).some((buff) => buff.id === buffId);

        const getBossRushBuffState = (enemy) => {
            if (!enemy) return null;
            if (!enemy.bossRushBuffState) {
                enemy.bossRushBuffState = {
                    turnCount: 0,
                    hitsTaken: 0,
                    defenseBoostPct: 0,
                    statusBoostPct: 0,
                    revived: false
                };
            }
            return enemy.bossRushBuffState;
        };

        const buildBossRushBuffPool = (floor) => {
            return BossRushBuffCategories
                .filter((category) => !category.minFloor || floor >= category.minFloor)
                .map((category) => {
                    let buffs = category.buffs;
                    if (floor === BossRushStartFloor + 50 && category.id === "basic") {
                        buffs = buffs.filter((buff) => !["br_basic_hp", "br_basic_def"].includes(buff.id));
                    }
                    return { ...category, buffs };
                })
                .filter((category) => category.buffs.length > 0);
        };

        const rollBossRushBuffs = (floor) => {
            const count = getBossRushBuffCount(floor);
            if (count <= 0) return [];
            const pool = buildBossRushBuffPool(floor);
            const picked = [];
            const available = [...pool];
            while (picked.length < count && available.length > 0) {
                const category = available.splice(Math.floor(Math.random() * available.length), 1)[0];
                if (!category || !category.buffs.length) continue;
                const buff = pickRandom(category.buffs);
                if (!buff) continue;
                picked.push({
                    ...buff,
                    categoryId: category.id,
                    colorClass: category.colorClass,
                    icon: category.icon
                });
            }
            return picked;
        };

        const applyBossRushBuffStats = (enemy, buffs) => {
            if (!enemy || !Array.isArray(buffs)) return;
            buffs.forEach((buff) => {
                if (buff.applySpawn) {
                    buff.applySpawn(enemy);
                }
            });
        };

        const getBossRushPlayerBuffCount = () => {
            if (!Array.isArray(Game.player?.statusEffects)) return 0;
            return Game.player.statusEffects.filter((effect) => !NegativeStatusEffectIds.has(effect.id)).length;
        };

        const getBossRushEnemyDebuffCount = (enemy) => {
            if (!Array.isArray(enemy?.statusEffects)) return 0;
            return enemy.statusEffects.filter((effect) => NegativeStatusEffectIds.has(effect.id)).length;
        };

        const getBossRushDamageNullifyThreshold = (enemy) => {
            if (!enemy || !hasBossRushBuff(enemy, "br_blue_nullify")) return 0;
            return Math.max(1, Math.floor((enemy.maxHp || 0) * BossRushBuffConfig.smallDamageNullifyPct));
        };

        const getBossRushEnemyAttackMultiplier = (enemy) => {
            if (!enemy) return 1;
            const state = getBossRushBuffState(enemy);
            let multiplier = 1;
            if (hasBossRushBuff(enemy, "br_green_turn_atk")) {
                multiplier += BossRushBuffConfig.turnAtkBoost * Math.max(0, state.turnCount || 0);
            }
            if (hasBossRushBuff(enemy, "br_green_hit_scale")) {
                multiplier += BossRushBuffConfig.hitTakenBoost * Math.max(0, state.hitsTaken || 0);
            }
            if (hasBossRushBuff(enemy, "br_green_hp50_boost") && enemy.hp <= (enemy.maxHp || 1) * 0.5) {
                multiplier += BossRushBuffConfig.hp50Boost;
            }
            if (hasBossRushBuff(enemy, "br_red_missing_hp")) {
                const missingRate = 1 - (enemy.hp / (enemy.maxHp || enemy.hp || 1));
                multiplier += Math.max(0, missingRate) * BossRushBuffConfig.hpMissingDamageBoost;
            }
            if (hasBossRushBuff(enemy, "br_orange_gain")) {
                multiplier += Math.max(0, (state.statusBoostPct || 0) / 100);
            }
            return multiplier;
        };

        const getBossRushEnemyDefenseMultiplier = (enemy) => {
            if (!enemy) return 1;
            const state = getBossRushBuffState(enemy);
            let multiplier = 1;
            if (hasBossRushBuff(enemy, "br_green_turn_def")) {
                multiplier += BossRushBuffConfig.turnDefBoost * Math.max(0, state.turnCount || 0);
            }
            if (hasBossRushBuff(enemy, "br_green_hit_scale")) {
                multiplier += BossRushBuffConfig.hitTakenBoost * Math.max(0, state.hitsTaken || 0);
            }
            if (hasBossRushBuff(enemy, "br_green_hp50_boost") && enemy.hp <= (enemy.maxHp || 1) * 0.5) {
                multiplier += BossRushBuffConfig.hp50Boost;
            }
            if (hasBossRushBuff(enemy, "br_yellow_crit_def")) {
                multiplier += Math.max(0, (state.defenseBoostPct || 0) / 100);
            }
            if (hasBossRushBuff(enemy, "br_orange_gain")) {
                multiplier += Math.max(0, (state.statusBoostPct || 0) / 100);
            }
            return multiplier;
        };

        const getBossRushDamageTakenMultiplier = (enemy, player) => {
            if (!enemy || !player) return 1;
            let multiplier = 1;
            if (hasBossRushBuff(enemy, "br_blue_reduce_30")) multiplier *= 0.7;
            if (hasBossRushBuff(enemy, "br_blue_reduce_50")) multiplier *= 0.5;
            if (hasBossRushBuff(enemy, "br_yellow_buff_guard")) {
                const buffCount = getBossRushPlayerBuffCount();
                const reduction = Math.min(BossRushBuffConfig.buffGuardMax, buffCount * BossRushBuffConfig.buffGuardPerBuff);
                multiplier *= Math.max(0.3, 1 - reduction);
            }
            if (hasBossRushBuff(enemy, "br_orange_guard")) {
                const debuffCount = getBossRushEnemyDebuffCount(enemy);
                const reduction = Math.min(BossRushBuffConfig.statusGuardMax, debuffCount * BossRushBuffConfig.statusGuardPerStack);
                multiplier *= Math.max(0.3, 1 - reduction);
            }
            return multiplier;
        };

        const getBossRushEnemyCritRate = (enemy) => {
            if (!enemy) return 0;
            let rate = enemy.critRate || 0;
            if (hasBossRushBuff(enemy, "br_basic_crit_rate")) rate += 30;
            return rate;
        };

        const getBossRushEnemyCritMultiplier = (enemy) => {
            if (!enemy) return BossRushBuffConfig.baseCritMultiplier;
            let multiplier = BossRushBuffConfig.baseCritMultiplier;
            if (hasBossRushBuff(enemy, "br_basic_crit_dmg")) {
                multiplier += 1;
            }
            return multiplier;
        };

        const applyBossRushCarryoverDamage = (enemy) => {
            if (!enemy) return;
            if (!Game.isBossRush) {
                Game.bossRushCarryoverDamage = 0;
                return;
            }
            const carry = Math.max(0, Math.floor(Game.bossRushCarryoverDamage || 0));
            if (carry <= 0) return;
            Game.bossRushCarryoverDamage = 0;
            const applied = applyDamage(enemy, carry, null, { ignoreReflect: true, ignoreBossRushSpread: true, ignoreBossRushNullify: true, ignoreBossRushDamageReduction: true });
            if (applied > 0) {
                addLog(`åˆ†æ•£ãƒ€ãƒ¡ãƒ¼ã‚¸ ${applied}ãŒè“„ç©ã‹ã‚‰ç™ºå‹•ï¼`, "text-rose-400");
            }
        };

        const shouldBossRushIgnoreDefense = (enemy) => (
            hasBossRushBuff(enemy, "br_blue_ignore_def") || hasBossRushBuff(enemy, "br_red_ignore_def")
        );
        const BossDefs = {
            50: {
                floor: 50,
                name: "æ¯’æ²¼ã®ãƒ´ã‚£ã‚¹",
                icon: "fa-skull-crossbones",
                skillInterval: 3,
                skills: [
                    {
                        name: "æ¯’éœ§æ•£å¸ƒ",
                        pow: 0.9,
                        effects: [
                            { target: "player", id: "poison", stacks: 1, turns: 2, log: "æ¯’ãŒå›ã£ãŸï¼" },
                            { target: "player", id: "attackDown", stacks: 1, turns: 2, log: "æ”»æ’ƒåŠ›ãŒä½ä¸‹ã—ãŸâ€¦" }
                        ]
                    }
                ]
            },
            100: {
                floor: 100,
                name: "ç–¾é¢¨ç‹¼ã‚»ã‚¤ãƒ«",
                icon: "fa-wind",
                skillInterval: 2,
                skills: [
                    {
                        name: "ç–¾é¢¨é€£æ–¬",
                        pow: 0.56,
                        hits: 2,
                        effects: [
                        ]
                    }
                ]
            },
            500: {
                floor: 500,
                name: "å²©å¡Šç‹ã‚¬ãƒ«ãƒ‰",
                icon: "fa-mountain",



                skillInterval: 4,
                skills: [
                    {
                        name: "å²©æ®»çµç•Œ",
                        pow: null,
                        effects: [
                            { target: "self", id: "defenseUp", stacks: 2, turns: 3 },
                            { target: "self", id: "barrier", stacks: 2, turns: 3 }
                        ],
                        log: "å²©ã®çµç•Œã§èº«ã‚’å›ºã‚ãŸï¼"
                    }
                ]
            },
            1000: {
                floor: 1000,
                name: "æ°·ç‰¢ã®ãƒ•ãƒ­ã‚¹ãƒˆ",
                icon: "fa-snowflake",



                skillInterval: 5,
                skills: [
                    {
                        name: "æ°·æŸ±è½ã¨ã—",
                        pow: 1.08,
                        effects: [
                            { target: "player", id: "freeze", stacks: 1, turns: 1, log: "å‡çµã—ãŸï¼" },
                            { target: "player", id: "vulnerable", stacks: 1, turns: 2 }
                        ]
                    }
                ]
            },
            1500: {
                floor: 1500,
                name: "é—‡ç´¡ããƒã‚¯ãƒˆ",
                icon: "fa-mask",



                skillInterval: 3,
                skills: [
                    {
                        name: "é—‡ã®å¸³",
                        pow: null,
                        effects: [
                            { target: "player", id: "blind", stacks: 2, turns: 3, log: "æš—é—‡ã«åŒ…ã¾ã‚ŒãŸï¼" },
                            { target: "player", id: "silence", stacks: 1, turns: 2, log: "æ²ˆé»™ã§ã‚¹ã‚­ãƒ«ãŒå°ã˜ã‚‰ã‚ŒãŸï¼" },
                            { target: "self", id: "attackUp", stacks: 2, turns: 3 }
                        ]
                    }
                ]
            },
            2000: {
                floor: 2000,
                name: "ç¼ç†±ç‹ã‚¤ã‚°ãƒ‹ã‚¹",
                icon: "fa-fire",



                skillInterval: 3,
                skills: [
                    {
                        name: "ç¼ç†±è£‚å‚·",
                        pow: 1.17,
                        effects: [
                            { target: "player", id: "bleed", stacks: 2, turns: 3, log: "å‡ºè¡€ãŒæ­¢ã¾ã‚‰ãªã„ï¼" }
                        ]
                    }
                ]
            },
            2500: {
                floor: 2500,
                name: "é›·ç‹ãƒ´ã‚©ãƒ«ãƒˆ",
                icon: "fa-bolt",



                skillInterval: 3,
                skills: [
                    {
                        name: "é›·æ§Œ",
                        pow: 1.26,
                        effects: [
                            { target: "player", id: "vulnerable", stacks: 2, turns: 2, log: "è„†å¼±çŠ¶æ…‹ã«ãªã£ãŸï¼" }
                        ]
                    }
                ]
            },
            3000: {
                floor: 3000,
                name: "è–å ‚å®ˆã‚¿ãƒªãƒ ",
                icon: "fa-sun",



                skillInterval: 4,
                skills: [
                    {
                        name: "è–åŸŸ",
                        pow: null,
                        healPct: 0.15,
                        effects: [
                            { target: "self", id: "barrier", stacks: 1, turns: 3 },
                            { target: "self", id: "reflect", stacks: 1, turns: 2 }
                        ],
                        log: "è–åŸŸãŒå±•é–‹ã•ã‚ŒãŸï¼"
                    }
                ]
            },
            3500: {
                floor: 3500,
                name: "ç–«ç—…ã®ãƒ©ã‚°",
                icon: "fa-virus",



                skillInterval: 5,
                skills: [
                    {
                        name: "ç–«ç—…æ•£å¸ƒ",
                        pow: 0.9,
                        effects: [
                            { target: "player", id: "poison", stacks: 3, turns: 3, log: "ç–«æ¯’ãŒä½“ã‚’è•ã‚€ï¼" },
                            { target: "player", id: "weaken", stacks: 2, turns: 2 }
                        ]
                    }
                ]
            },
            4000: {
                floor: 4000,
                name: "é‰„å£ç‹ãƒ•ã‚§ãƒªã‚¹",
                icon: "fa-shield-halved",



                skillInterval: 4,
                skills: [
                    {
                        name: "é‰„å£è¡æ’ƒ",
                        pow: 0.99,
                        effects: [
                            { target: "self", id: "defenseUp", stacks: 3, turns: 3 },
                            { target: "player", id: "attackDown", stacks: 1, turns: 2, log: "æ”»æ’ƒãŒéˆããªã£ãŸï¼" }
                        ]
                    }
                ]
            },
            4500: {
                floor: 4500,
                name: "å½±åˆƒç‹ã‚«ã‚²ãƒ­ã‚¦",
                icon: "fa-user-secret",



                skillInterval: 2,
                skills: [
                    {
                        name: "å½±ç¸«ã„",
                        pow: 0.9,
                        hits: 2,
                        effects: [
                            { target: "player", id: "bleed", stacks: 2, turns: 3, log: "å½±ã®åˆƒã§è£‚ã‹ã‚ŒãŸï¼" },
                            { target: "self", id: "haste", stacks: 1, turns: 2 }
                        ]
                    }
                ]
            },
            5000: {
                floor: 5000,
                name: "çµ‚ç„‰ç«œã‚¢ãƒã‚«ãƒªã‚¹",
                icon: "fa-dragon",



                skillInterval: 4,
                skills: [
                    {
                        name: "çµ‚ç„‰ã®å’†å“®",
                        pow: 1.62,
                        effects: [
                            { target: "player", id: "vulnerable", stacks: 2, turns: 2, log: "ææ€–ã§èº«ãŒéœ‡ãˆã‚‹ï¼" },
                            { target: "player", id: "attackDown", stacks: 2, turns: 2 }
                        ]
                    }
                ]
            }
        };

        const BossLootTables = {
            50: [
                { name: "æ¯’ç‰™ã®çŸ­å‰£", type: "weapon", rarity: "epic", stats: [{ key: "attackFlat", value: 39 }, { key: "dex", value: 14 }, { key: "leechRate", value: 5 }], uniqueStats: [] },
                { name: "æ¯’æ²¼ã®ãƒ˜ãƒ«ãƒ ", type: "head", rarity: "epic", stats: [{ key: "defenseFlat", value: 27 }, { key: "maxHp", value: 36 }], uniqueStats: [] },
                { name: "æ¹¿æ¯’ã®ãƒ­ãƒ¼ãƒ–", type: "armor", rarity: "epic", stats: [{ key: "hpRegen", value: 6 }, { key: "damageReduction", value: 3 }], uniqueStats: [] }
            ],
            100: [
                { name: "ç–¾é¢¨ã®çˆªå‰£", type: "weapon", rarity: "epic", stats: [{ key: "attackFlat", value: 57 }, { key: "dex", value: 20 }, { key: "accuracy", value: 14 }], uniqueStats: [] },
                { name: "é¢¨èµ°ã‚Šã®ãƒ–ãƒ¼ãƒ„", type: "feet", rarity: "epic", stats: [{ key: "evasionRate", value: 15 }, { key: "dex", value: 14 }, { key: "maxHp", value: 53 }], uniqueStats: [] },
                { name: "ç–¾é¢¨ã®ç± æ‰‹", type: "hands", rarity: "epic", stats: [{ key: "attackFlat", value: 18 }, { key: "evasionRate", value: 8 }], uniqueStats: [] }
            ],
            500: [
                { name: "å²©æ ¸ã®å¤§ç›¾", type: "armor", rarity: "epic", stats: [{ key: "defenseFlat", value: 89 }, { key: "vit", value: 26 }, { key: "damageReduction", value: 6 }], uniqueStats: [] },
                { name: "å²©å®ˆã‚Šã®å…œ", type: "head", rarity: "epic", stats: [{ key: "defenseFlat", value: 41 }, { key: "vit", value: 17 }, { key: "maxHp", value: 72 }], uniqueStats: [] },
                { name: "å²©è„ˆã®è­·ç¬¦", type: "accessory", rarity: "epic", stats: [{ key: "maxHp", value: 54 }, { key: "damageReduction", value: 5 }], uniqueStats: [] }
            ],
            1000: [
                { name: "æ°·æ™¶ã®æ–", type: "weapon", rarity: "epic", stats: [{ key: "attackFlat", value: 63 }, { key: "int", value: 20 }, { key: "mPen", value: 14 }], uniqueStats: [] },
                { name: "æ°·ç‰¢ã®æŒ‡è¼ª", type: "accessory", rarity: "epic", stats: [{ key: "critRate", value: 8 }, { key: "maxMp", value: 45 }, { key: "mpRegen", value: 3 }], uniqueStats: [] },
                { name: "å‡éœ§ã®æ‰‹ç”²", type: "hands", rarity: "epic", stats: [{ key: "int", value: 12 }, { key: "mPen", value: 8 }], uniqueStats: [] }
            ],
            1500: [
                { name: "å®µé—‡ã®ãƒãƒ³ãƒˆ", type: "armor", rarity: "epic", stats: [{ key: "evasionRate", value: 15 }, { key: "dex", value: 18 }, { key: "damageBoost", value: 8 }], uniqueStats: [] },
                { name: "é—‡ç‹©ã‚Šã®çŸ­å‰£", type: "weapon", rarity: "epic", stats: [{ key: "attackFlat", value: 71 }, { key: "critRate", value: 11 }, { key: "dex", value: 14 }], uniqueStats: [] },
                { name: "é—‡ç¸«ã„ã®å…œ", type: "head", rarity: "epic", stats: [{ key: "dex", value: 14 }, { key: "critRate", value: 6 }], uniqueStats: [] },
            ],
            2000: [
                { name: "ç†¾ç«ã®å¤§å‰£", type: "weapon", rarity: "epic", stats: [{ key: "attackFlat", value: 83 }, { key: "str", value: 20 }, { key: "critDamage", value: 20 }], uniqueStats: [] },
                { name: "ç‚è­·ã®æ‰‹ç”²", type: "hands", rarity: "epic", stats: [{ key: "attackFlat", value: 20 }, { key: "str", value: 14 }, { key: "damageBoost", value: 8 }], uniqueStats: [] },
                { name: "ç¼ç‚ã®è­·è¡£", type: "armor", rarity: "epic", stats: [{ key: "defenseFlat", value: 45 }, { key: "str", value: 12 }], uniqueStats: [] },
            ],
            2500: [
                { name: "é›·é³´ã®æˆ¦æ§Œ", type: "weapon", rarity: "epic", stats: [{ key: "attackFlat", value: 89 }, { key: "str", value: 24 }, { key: "accuracy", value: 14 }], uniqueStats: [] },
                { name: "å¸¯é›»ã®è­·ç¬¦", type: "accessory", rarity: "epic", stats: [{ key: "critRate", value: 11 }, { key: "damageBoost", value: 11 }, { key: "maxHp", value: 80 }], uniqueStats: [] },
                { name: "é›·å½±ã®å…œ", type: "head", rarity: "epic", stats: [{ key: "accuracy", value: 11 }, { key: "critRate", value: 6 }], uniqueStats: [] },
            ],
            3000: [
                { name: "è–ç´‹ã®ãƒ­ãƒ¼ãƒ–", type: "armor", rarity: "epic", stats: [{ key: "defenseFlat", value: 72 }, { key: "int", value: 20 }, { key: "maxMp", value: 60 }], uniqueStats: [] },
                { name: "è–ç¥ˆã®è­·ç¬¦", type: "accessory", rarity: "epic", stats: [{ key: "hpRegen", value: 17 }, { key: "mpRegen", value: 5 }, { key: "damageReduction", value: 6 }], uniqueStats: [] },
                { name: "è–å…‰ã®æ–", type: "weapon", rarity: "epic", stats: [{ key: "attackFlat", value: 42 }, { key: "int", value: 15 }], uniqueStats: [] }
            ],
            3500: [
                { name: "ç–«æ¯’ã®éŒ", type: "weapon", rarity: "epic", stats: [{ key: "attackFlat", value: 95 }, { key: "dex", value: 20 }, { key: "mPen", value: 14 }], uniqueStats: [] },
                { name: "è…è•ã®æŒ‡è¼ª", type: "accessory", rarity: "epic", stats: [{ key: "damageBoost", value: 11 }, { key: "leechRate", value: 8 }, { key: "maxHp", value: 80 }], uniqueStats: [] },
                { name: "è…è•ã®è„šç”²", type: "feet", rarity: "epic", stats: [{ key: "evasionRate", value: 9 }, { key: "dex", value: 12 }], uniqueStats: [] }
            ],
            4000: [
                { name: "é‰„å£ã®é§", type: "armor", rarity: "epic", stats: [{ key: "defenseFlat", value: 104 }, { key: "vit", value: 30 }, { key: "damageReduction", value: 9 }], uniqueStats: [] },
                { name: "é‹¼é‰„ã®ã‚°ãƒ­ãƒ¼ãƒ–", type: "hands", rarity: "epic", stats: [{ key: "defenseFlat", value: 32 }, { key: "str", value: 18 }, { key: "maxHp", value: 60 }], uniqueStats: [] },
                { name: "é‰„å£ã®è­·ç¬¦", type: "accessory", rarity: "epic", stats: [{ key: "maxHp", value: 60 }, { key: "damageReduction", value: 5 }], uniqueStats: [] }
            ],
            4500: [
                { name: "å½±åˆƒã®å¿åˆ€", type: "weapon", rarity: "epic", stats: [{ key: "attackFlat", value: 102 }, { key: "dex", value: 26 }, { key: "critRate", value: 14 }], uniqueStats: [] },
                { name: "å¤œèµ°ã‚Šã®è¶³è¢‹", type: "feet", rarity: "epic", stats: [{ key: "evasionRate", value: 17 }, { key: "dex", value: 18 }, { key: "accuracy", value: 14 }], uniqueStats: [] },
                { name: "å½±åˆƒã®è­·ç¬¦", type: "accessory", rarity: "epic", stats: [{ key: "critRate", value: 8 }, { key: "damageBoost", value: 6 }], uniqueStats: [] }
            ],
            5000: [
                { name: "çµ‚ç„‰ã®ç«œæ§", type: "weapon", rarity: "legendary", stats: [{ key: "attackFlat", value: 113 }, { key: "str", value: 29 }, { key: "damageBoost", value: 16 }], uniqueStats: [] },
                { name: "ç«œé±—ã®è­·é§", type: "armor", rarity: "legendary", stats: [{ key: "defenseFlat", value: 108 }, { key: "vit", value: 37 }, { key: "maxHp", value: 142 }], uniqueStats: [] },
                { name: "çµ‚ç„‰ã®è­·ç¬¦", type: "accessory", rarity: "legendary", stats: [{ key: "luck", value: 49 }, { key: "rareFind", value: 46 }, { key: "affixFind", value: 43 }], uniqueStats: [] }
            ],
        };


        const BossUniqueEffects = {
            "æ¯’ç‰™ã®çŸ­å‰£": { type: "statBonus", stats: [ { key: "statusEffectStackBonus", value: 2 }, { key: "poisonMaxStacksBonus", value: 1 } ], label: "æ¯’ç‰™ã®çŸ­å‰£ï¼šçŠ¶æ…‹ç•°å¸¸ä»˜ä¸ã‚¹ã‚¿ãƒƒã‚¯ +2 / æ¯’ä¸Šé™ã‚¹ã‚¿ãƒƒã‚¯ +1" },
            "ç–¾é¢¨ã®çˆªå‰£": { type: "statMultiplier", stat: "dex", value: 12, label: "ç–¾é¢¨ã®çˆªå‰£ï¼šDEXå€ç‡ +12%" },
            "é¢¨èµ°ã‚Šã®ãƒ–ãƒ¼ãƒ„": { type: "bonusHitsChance", chance: 20, hits: 1, hitMultiplier: 0.7, label: "é¢¨èµ°ã‚Šã®ãƒ–ãƒ¼ãƒ„ï¼š20%ã§è¿½åŠ ãƒ’ãƒƒãƒˆ+1(70%)" },
            "å²©æ ¸ã®å¤§ç›¾": { type: "statMultiplier", stat: "vit", value: 12, extraType: "damageBuffer", label: "å²©æ ¸ã®å¤§ç›¾ï¼šVITå€ç‡ +12%ï¼‹å—ã‘ãŸãƒ€ãƒ¡ãƒ¼ã‚¸ã®ä¸€éƒ¨ã‚’ç„¡åŠ¹åŒ–ã—ã€ãã®é‡ã‚’æ¬¡ã®æ”»æ’ƒã«ä¸Šä¹—ã›" },
            "å²©å®ˆã‚Šã®å…œ": { type: "martyrLight", label: "å—é›£ã®å…‰ï¼šè¢«å¼¾ã—ãŸåˆè¨ˆã‚’ã€Œå…‰ã€ã«å¤‰æ›ã—ã€ä¸€å®šé‡ã§è‡ªå‹•çˆ†ç™ºï¼ˆå›å¾©æ‰±ã„ã§ã¯ãªã„ï¼‰" },
            "æ°·æ™¶ã®æ–": { type: "statBonus", stats: [ { key: "skillPowerBoost", value: 12 } ], label: "æ°·æ™¶ã®æ–ï¼šã‚¹ã‚­ãƒ«å¨åŠ› +12%" },
            "æ°·ç‰¢ã®æŒ‡è¼ª": { type: "recastSkill", label: "å†è© å”±ï¼šã‚¹ã‚­ãƒ«ä½¿ç”¨å¾Œã€ä¸€å®šç¢ºç‡ã§åŒã‚¹ã‚­ãƒ«ãŒâ€œç„¡è© å”±â€ã§å†ç™ºå‹•ï¼ˆ1å›ï¼‰" },
            "å®µé—‡ã®ãƒãƒ³ãƒˆ": { type: "damageBoost", condition: { type: "enemyStatus", status: "poison" }, value: 15, label: "å®µé—‡ã®ãƒãƒ³ãƒˆï¼šæ¯’ã®æ•µã«ä¸ãƒ€ãƒ¡+15%" },
            "é—‡ç‹©ã‚Šã®çŸ­å‰£": { type: "bonusHitsChance", chance: 18, hits: 1, hitMultiplier: 0.75, label: "é—‡ç‹©ã‚Šã®çŸ­å‰£ï¼š18%ã§è¿½åŠ ãƒ’ãƒƒãƒˆ+1(75%)" },
            "ç†¾ç«ã®å¤§å‰£": { type: "killOverflow", label: "ç†¾ç«ã®å¤§å‰£ï¼šã‚­ãƒ«ã”ã¨ã«ã€Œéå‰°ç«åŠ›ã€ã‚’ä¿å­˜ã€æ¬¡ã®æ•µã¸ã®åˆæ’ƒã«ä¸Šä¹—ã›" },
            "ç‚è­·ã®æ‰‹ç”²": { type: "overkillBank", label: "ç‚è­·ã®æ‰‹ç”²ï¼šã‚ªãƒ¼ãƒãƒ¼ã‚­ãƒ«è²¯é‡‘ï¼šæ•µã‚’å€’ã—ãŸä½™å‰°ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ã€Œè²¯è“„ã€ã—ã€æ¬¡ã®æ”»æ’ƒã«ä¸Šä¹—ã›ï¼ˆä¸Šé™ã‚ã‚Šï¼‰" },
            "é›·é³´ã®æˆ¦æ§Œ": { type: "damageReturnCharge", label: "é›·é³´ã®æˆ¦æ§Œï¼šå—ã‘ãŸåˆè¨ˆãƒ€ãƒ¡ãƒ¼ã‚¸ã®ä¸€å®šå‰²åˆã‚’è“„ç©ã—ã€æ¬¡ã®æ”»æ’ƒã«ä¸Šä¹—ã›ã—ã¦è¿”ã™" },
            "å¸¯é›»ã®è­·ç¬¦": { type: "statBonus", stats: [ { key: "skillMpDiscount", value: 10 } ], label: "å¸¯é›»ã®è­·ç¬¦ï¼šã‚¹ã‚­ãƒ«MPæ¶ˆè²» -10%" },
            "è–ç´‹ã®ãƒ­ãƒ¼ãƒ–": { type: "statMultiplier", stat: "int", value: 18, label: "è–ç´‹ã®ãƒ­ãƒ¼ãƒ–ï¼šINTå€ç‡ +18%" },
            "è–ç¥ˆã®è­·ç¬¦": { type: "statBonus", stats: [ { key: "skillPowerBoost", value: 16 } ], label: "è–ç¥ˆã®è­·ç¬¦ï¼šã‚¹ã‚­ãƒ«å¨åŠ› +16%" },
            "ç–«æ¯’ã®éŒ": { type: "statBonus", stats: [ { key: "statusEffectStackBonus", value: 2 }, { key: "poisonMaxStacksBonus", value: 1 } ], label: "ç–«æ¯’ã®éŒï¼šçŠ¶æ…‹ç•°å¸¸ä»˜ä¸ã‚¹ã‚¿ãƒƒã‚¯ +2 / æ¯’ä¸Šé™ã‚¹ã‚¿ãƒƒã‚¯ +1" },
            "è…è•ã®æŒ‡è¼ª": { type: "statBonus", stats: [ { key: "statusEffectTurnBonus", value: 1 }, { key: "poisonMinPctBonus", value: 0.5 } ], label: "è…è•ã®æŒ‡è¼ªï¼šçŠ¶æ…‹ç•°å¸¸ä»˜ä¸ã‚¿ãƒ¼ãƒ³ +1 / æ¯’æœ€ä½ä¿è¨¼ +0.5%" },
            "é‰„å£ã®é§": { type: "statMultiplier", stat: "vit", value: 18, extraType: "lethalGuard", label: "é‰„å£ã®é§ï¼šVITå€ç‡ +18%ï¼‹è‡´æ­»ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹ã¨HP1ã§è€ãˆã‚‹ï¼ˆ1æˆ¦é—˜1å›ï¼‰" },
            "é‹¼é‰„ã®ã‚°ãƒ­ãƒ¼ãƒ–": { type: "statMultiplier", stat: "str", value: 14, label: "é‹¼é‰„ã®ã‚°ãƒ­ãƒ¼ãƒ–ï¼šSTRå€ç‡ +14%" },
            "å½±åˆƒã®å¿åˆ€": { type: "bonusHitsChance", chance: 22, hits: 1, hitMultiplier: 0.7, label: "å½±åˆƒã®å¿åˆ€ï¼š22%ã§è¿½åŠ ãƒ’ãƒƒãƒˆ+1(70%)" },
            "å¤œèµ°ã‚Šã®è¶³è¢‹": { type: "statMultiplier", stat: "dex", value: 18, label: "å¤œèµ°ã‚Šã®è¶³è¢‹ï¼šDEXå€ç‡ +18%" },
            "çµ‚ç„‰ã®ç«œæ§": { type: "multiHitAmplifyDex", label: "çµ‚ç„‰ã®ç«œæ§ï¼šé€£æ‰“ã®å¢—å¹…ï¼šæ”»æ’ƒãŒå¸¸ã«å¤šæ®µåŒ–ã€‚DEXã§åˆ†å‰²å›æ•°ãŒå¢—ãˆã€æœ€å¾Œã®1ç™ºã¯å¤§æœ¬å‘½" },
            "ç«œé±—ã®è­·é§": { type: "statMultiplier", stat: "vit", value: 25, extraType: "defenseLayers", label: "ç«œé±—ã®è­·é§ï¼šVITå€ç‡ +25%ï¼‹è¢«å¼¾ã™ã‚‹ãŸã³ã€Œé˜²å¾¡å±¤ã€+1ã€å±¤æ•°ã¶ã‚“æ¬¡ã®æ”»æ’ƒãŒè¿½æ’ƒ" },
            "æ¯’æ²¼ã®ãƒ˜ãƒ«ãƒ ": { type: "singleStatusRule", label: "æ¯’æ²¼ã®ãƒ˜ãƒ«ãƒ ï¼šå˜ä¸€ç•°å¸¸ã®æŸï¼šçŠ¶æ…‹ç•°å¸¸ã¯1ç¨®é¡ã—ã‹ä»˜ã‹ãªã„ä»£ã‚ã‚Šã«ã€ä»˜ä¸æ™‚ã«å¿…ãš2é‡ã‚¹ã‚¿ãƒƒã‚¯" },
            "æ¹¿æ¯’ã®ãƒ­ãƒ¼ãƒ–": { type: "poisonUnlimited", label: "æ¹¿æ¯’ã®ãƒ­ãƒ¼ãƒ–ï¼šæ¯’ä¸Šé™è§£æ”¾ï¼šæ¯’ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸Šé™ãŒæ’¤å»ƒã•ã‚Œã‚‹" },
            "ç–¾é¢¨ã®ç± æ‰‹": { type: "extraTurnChance", condition: { type: "enemyHpBelow", threshold: 0.4 }, chance: 8, hitMultiplier: 0.7, label: "ç–¾é¢¨ã®ç± æ‰‹ï¼šæ•µHP40%ä»¥ä¸‹ã§8%ã§è¿½åŠ è¡Œå‹•(70%)" },
            "å²©è„ˆã®è­·ç¬¦": { type: "barrierSplitHits", label: "å²©è„ˆã®è­·ç¬¦ï¼šãƒãƒªã‚¢ãŒå­˜åœ¨ã™ã‚‹é–“ã€æ”»æ’ƒãŒåˆ†å‰²ãƒ’ãƒƒãƒˆåŒ–" },
            "å‡éœ§ã®æ‰‹ç”²": { type: "repeatMemory", label: "å‡éœ§ã®æ‰‹ç”²ï¼šåå¾©è¨˜æ†¶ï¼šã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã€å‰ã‚¿ãƒ¼ãƒ³æœ€å¾Œã«ä½¿ã£ãŸã‚¹ã‚­ãƒ«ã‚’è‡ªå‹•å†å®Ÿè¡Œ" },
            "é—‡ç¸«ã„ã®å…œ": { type: "poisonOverload", label: "é—‡ç¸«ã„ã®å…œï¼šæ¯’éç©è¼‰ï¼šæ¯’ãŒä¸€å®šæ•°ä»¥ä¸Šã‚ã‚‹é–“ã€æ¯ã‚¿ãƒ¼ãƒ³è¿½åŠ ã§çˆ†ç™ºãƒ€ãƒ¡ãƒ¼ã‚¸" },
            "ç¼ç‚ã®è­·è¡£": { type: "sureHitHighHp", condition: { type: "enemyHpAbove", threshold: 0.5 }, label: "ç¼ç‚ã®è­·è¡£ï¼šé–‹å¹•ç¼ç†±ï¼šæ•µHP50%ä»¥ä¸Šã®é–“ã€å¿…ä¸­" },
            "é›·å½±ã®å…œ": { type: "extraTurnChance", condition: { type: "enemyHpBelow", threshold: 0.3 }, chance: 10, hitMultiplier: 1, label: "é›·å½±ã®å…œï¼šè¿…é›·å¾‹ï¼šæ•µHP30%ä»¥ä¸‹ã§è¡Œå‹•å›æ•°+1(ç¢ºç‡10%)" },
            "è–å…‰ã®æ–": { type: "mpRestoreAfterSkill", condition: { type: "playerMpBelow", threshold: 0.5 }, label: "è–å…‰ã®æ–ï¼šç¥ˆã‚Šã®åéŸ¿ï¼šMP50%ä»¥ä¸‹ã§ã‚¹ã‚­ãƒ«ä½¿ç”¨å¾Œã«MPå°å›å¾©(å›ºå®š)" },
            "è…è•ã®è„šç”²": { type: "poisonStackSurge", condition: { type: "playerHpAbove", threshold: 0.75 }, value: 3, label: "è…è•ã®è„šç”²ï¼šè…è•ä¼æ’­ï¼šHP75%ä»¥ä¸Šã§æ¯’ä»˜ä¸æ™‚ã«å³+3ã‚¹ã‚¿ãƒƒã‚¯" },
            "é‰„å£ã®è­·ç¬¦": { type: "returnDoubleGuard", condition: { type: "playerHpAbove", threshold: 0.6 }, label: "é‰„å£ã®è­·ç¬¦ï¼šé‰„å£åéŸ¿ï¼šHP60%ä»¥ä¸Šã§è¢«ãƒ€ãƒ¡ã‚’æ¬¡ã®æ”»æ’ƒã«2å€ã§è¿”ã™" },
            "å½±åˆƒã®è­·ç¬¦": { type: "shadowFirstStrike", condition: { type: "playerHpAbove", threshold: 0.6 }, label: "å½±åˆƒã®è­·ç¬¦ï¼šå½±åˆƒã®å®£å‘Šï¼šHP60%ä»¥ä¸Šã®åˆæ’ƒãŒå¿…ãšä¼šå¿ƒï¼†å€ç‡ä¸Šæ˜‡" },
            "çµ‚ç„‰ã®è­·ç¬¦": { type: "levelRatioBoost", stat: "luk", randomize: true, stepRange: [1, 5], gainRange: [1, 2], label: "çµ‚ç„‰ã®è­·ç¬¦ï¼šLUKæˆé•·" },
        };

        const BossUniqueEffectConfig = {
            martyrLightThresholdRate: 0.3,
            martyrLightDamageRate: 1,
            recastChance: 0.2,
            overkillCapRate: 1.5,
            killOverflowRate: 0.35,
            killOverflowCapRate: 1.2,
            damageReturnRate: 0.35,
            damageReturnCapRate: 1.4,
            damageBufferAbsorbRate: 0.25,
            damageBufferCapRate: 1.2,
            barrierSplitHits: 2,
            barrierSplitMultiplier: 0.5,
            multiHitBase: 2,
            multiHitDexStep: 120,
            multiHitMaxExtra: 4,
            multiHitFinalMultiplier: 1.7,
            defenseLayerMultiplier: 0.6,
            poisonOverloadStacks: 8,
            poisonOverloadRate: 0.02,
            holyStaffMpRestore: 6,
            shadowFirstStrikeMultiplier: 1.4
        };

        const RoadLegendaryUniqueEffects = {
            "é»æ˜ã®çŸ­å‰£": { type: "damageBoost", condition: { type: "playerHpAbove", threshold: 0.8 }, value: 25, label: "é»æ˜ã®çŸ­å‰£ï¼šHP80%ä»¥ä¸Šã§ä¸ãƒ€ãƒ¡+25%" },
            "æ™¨å…‰ã®è­·ç¬¦": { type: "damageTakenReduction", condition: { type: "playerHpAbove", threshold: 0.7 }, value: 15, label: "æ™¨å…‰ã®è­·ç¬¦ï¼šHP70%ä»¥ä¸Šã§è¢«ãƒ€ãƒ¡-15%" },
            "ç°ç‡¼ã®æ‰‹ç”²": { type: "critBoost", value: 25, label: "ç°ç‡¼ã®æ‰‹ç”²ï¼šä¼šå¿ƒç‡+25%" },
            "ç ‚ç¸›ã‚Šã®ãƒ–ãƒ¼ãƒ„": { type: "extraTurnChance", condition: { type: "enemyHpBelow", threshold: 0.5 }, chance: 12, hitMultiplier: 0.6, label: "ç ‚ç¸›ã‚Šã®ãƒ–ãƒ¼ãƒ„ï¼šæ•µHP50%ä»¥ä¸‹ã§12%ã§è¿½åŠ è¡Œå‹•(60%)" },
            "æœˆå½±ã®ãƒãƒ³ãƒˆ": { type: "damageTakenReduction", value: 20, label: "æœˆå½±ã®ãƒãƒ³ãƒˆï¼šè¢«ãƒ€ãƒ¡-20%" },
            "ç™½éœ§ã®æŒ‡è¼ª": { type: "damageTakenReduction", condition: { type: "playerHpBelow", threshold: 0.5 }, value: 35, label: "ç™½éœ§ã®æŒ‡è¼ªï¼šHP50%ä»¥ä¸‹ã§è¢«ãƒ€ãƒ¡-35%" },
            "é›·è¿…ã®æˆ¦æ§Œ": { type: "bonusHitsChance", chance: 15, hits: 1, hitMultiplier: 0.6, label: "é›·è¿…ã®æˆ¦æ§Œï¼š15%ã§è¿½åŠ ãƒ’ãƒƒãƒˆ+1(60%)" },
            "é™é›»ã®å…œ": { type: "critBoost", value: 12, label: "é™é›»ã®å…œï¼šä¼šå¿ƒç‡+12%" },
            "æ·±æ½­ã®ãƒ­ãƒ¼ãƒ–": { type: "statBonus", stats: [ { key: "mpRegen", value: 8 }, { key: "maxMp", value: 60 } ], label: "æ·±æ½­ã®ãƒ­ãƒ¼ãƒ–ï¼šMPè‡ªå‹•å›å¾©+8 / æœ€å¤§MP+60" },
            "æ¿¡åˆƒã®çŸ­å‰£": { type: "damageBoost", condition: { type: "enemyStatus", status: "poison" }, value: 30, label: "æ¿¡åˆƒã®çŸ­å‰£ï¼šæ¯’ã®æ•µã«ä¸ãƒ€ãƒ¡+30%" },
            "ç†¾ç«ã®å¤§å‰£": { type: "statMultiplier", stat: "str", value: 20, label: "ç†¾ç«ã®å¤§å‰£ï¼šSTRå€ç‡ +20%" },
            "ç´…ç‚ã®è­·ç¬¦": { type: "damageBoost", condition: { type: "playerHpAbove", threshold: 0.9 }, value: 30, label: "ç´…ç‚ã®è­·ç¬¦ï¼šHP90%ä»¥ä¸Šã§ä¸ãƒ€ãƒ¡+30%" },
            "éœœåˆ»ã®æ–": { type: "statMultiplier", stat: "int", value: 20, label: "éœœåˆ»ã®æ–ï¼šINTå€ç‡ +20%" },
            "æ°·ç‰¢ã®è‚©å½“ã¦": { type: "damageTakenReduction", condition: { type: "enemyStatus", status: "freeze" }, value: 25, label: "æ°·ç‰¢ã®è‚©å½“ã¦ï¼šå‡çµä¸­ã®æ•µã‹ã‚‰è¢«ãƒ€ãƒ¡-25%" },
            "å¤œå‰ã®çˆªå‰£": { type: "bonusHitsChance", chance: 18, hits: 1, hitMultiplier: 0.7, label: "å¤œå‰ã®çˆªå‰£ï¼š18%ã§è¿½åŠ ãƒ’ãƒƒãƒˆ+1(70%)" },
            "å½±è¨ã¡ã®è¶³è¢‹": { type: "accuracyBoost", condition: { type: "playerHpAbove", threshold: 0.7 }, value: 15, label: "å½±è¨ã¡ã®è¶³è¢‹ï¼šHP70%ä»¥ä¸Šã§å‘½ä¸­+15" },
            "å°å°ã®æ›¸": { type: "statBonus", stats: [ { key: "skillPowerBoost", value: 20 } ], label: "å°å°ã®æ›¸ï¼šã‚¹ã‚­ãƒ«å¨åŠ› +20%" },
            "ç¦è¡“ã®è­·ç¬¦": { type: "statBonus", stats: [ { key: "skillMpDiscount", value: 20 }, { key: "maxMp", value: 80 } ], label: "ç¦è¡“ã®è­·ç¬¦ï¼šã‚¹ã‚­ãƒ«MPæ¶ˆè²»-20% / æœ€å¤§MP+80" },
            "çµ‚æœ«å‰å¤œã®å‰£": { type: "riskBoost", condition: { type: "playerHpAbove", threshold: 0.8 }, value: 45, penalty: 20, label: "çµ‚æœ«å‰å¤œã®å‰£ï¼šHP80%ä»¥ä¸Šã§ä¸ãƒ€ãƒ¡+45%/è¢«ãƒ€ãƒ¡+20%" },
            "åˆ»å°ã®è­·ç¬¦": { type: "damageBoost", condition: { type: "enemyHpBelow", threshold: 0.5 }, value: 35, label: "åˆ»å°ã®è­·ç¬¦ï¼šæ•µHP50%ä»¥ä¸‹ã§ä¸ãƒ€ãƒ¡+35%" }
        };

        const RoadLegendaryLootTables = [
            {
                floorStart: 1,
                items: [
                    { name: "é»æ˜ã®çŸ­å‰£", type: "weapon", stats: [{ key: "attackFlat", value: 19 }, { key: "dex", value: 11 }, { key: "critRate", value: 4 }], uniqueStats: [] },
                    { name: "æ™¨å…‰ã®è­·ç¬¦", type: "accessory", stats: [{ key: "maxHp", value: 29 }, { key: "damageReduction", value: 4 }, { key: "luk", value: 3 }], uniqueStats: [] }
                ]
            },
            {
                floorStart: 101,
                items: [
                    { name: "ç°ç‡¼ã®æ‰‹ç”²", type: "hands", stats: [{ key: "attackFlat", value: 57 }, { key: "str", value: 24 }, { key: "critRate", value: 11 }], uniqueStats: [] },
                    { name: "ç ‚ç¸›ã‚Šã®ãƒ–ãƒ¼ãƒ„", type: "feet", stats: [{ key: "defenseFlat", value: 65 }, { key: "evasionRate", value: 13 }, { key: "dex", value: 29 }], uniqueStats: [] }
                ]
            },
            {
                floorStart: 201,
                items: [
                    { name: "æœˆå½±ã®ãƒãƒ³ãƒˆ", type: "armor", stats: [{ key: "defenseFlat", value: 81 }, { key: "evasionRate", value: 15 }, { key: "dex", value: 35 }], uniqueStats: [] },
                    { name: "ç™½éœ§ã®æŒ‡è¼ª", type: "accessory", stats: [{ key: "maxHp", value: 124 }, { key: "damageReduction", value: 10 }, { key: "luk", value: 10 }], uniqueStats: [] }
                ]
            },
            {
                floorStart: 301,
                items: [
                    { name: "é›·è¿…ã®æˆ¦æ§Œ", type: "weapon", stats: [{ key: "attackFlat", value: 70 }, { key: "str", value: 30 }, { key: "accuracy", value: 15 }], uniqueStats: [] },
                    { name: "é™é›»ã®å…œ", type: "head", stats: [{ key: "defenseFlat", value: 81 }, { key: "vit", value: 43 }, { key: "critRate", value: 14 }], uniqueStats: [] }
                ]
            },
            {
                floorStart: 401,
                items: [
                    { name: "æ·±æ½­ã®ãƒ­ãƒ¼ãƒ–", type: "armor", stats: [{ key: "defenseFlat", value: 94 }, { key: "int", value: 50 }, { key: "maxMp", value: 118 }], uniqueStats: [] },
                    { name: "æ¿¡åˆƒã®çŸ­å‰£", type: "weapon", stats: [{ key: "attackFlat", value: 81 }, { key: "dex", value: 40 }, { key: "leechRate", value: 18 }], uniqueStats: [] }
                ]
            },
            {
                floorStart: 501,
                items: [
                    { name: "ç†¾ç«ã®å¤§å‰£", type: "weapon", stats: [{ key: "attackFlat", value: 81 }, { key: "str", value: 35 }, { key: "critDamage", value: 18 }], uniqueStats: [] },
                    { name: "ç´…ç‚ã®è­·ç¬¦", type: "accessory", stats: [{ key: "damageBoost", value: 10 }, { key: "maxHp", value: 145 }, { key: "luk", value: 11 }], uniqueStats: [] }
                ]
            },
            {
                floorStart: 601,
                items: [
                    { name: "éœœåˆ»ã®æ–", type: "weapon", stats: [{ key: "attackFlat", value: 96 }, { key: "int", value: 59 }, { key: "mPen", value: 21 }], uniqueStats: [] },
                    { name: "æ°·ç‰¢ã®è‚©å½“ã¦", type: "armor", stats: [{ key: "defenseFlat", value: 110 }, { key: "vit", value: 59 }, { key: "damageReduction", value: 14 }], uniqueStats: [] }
                ]
            },
            {
                floorStart: 701,
                items: [
                    { name: "å¤œå‰ã®çˆªå‰£", type: "weapon", stats: [{ key: "attackFlat", value: 96 }, { key: "dex", value: 48 }, { key: "critRate", value: 18 }], uniqueStats: [] },
                    { name: "å½±è¨ã¡ã®è¶³è¢‹", type: "feet", stats: [{ key: "evasionRate", value: 21 }, { key: "dex", value: 48 }, { key: "accuracy", value: 21 }], uniqueStats: [] }
                ]
            },
            {
                floorStart: 801,
                items: [
                    { name: "å°å°ã®æ›¸", type: "weapon", stats: [{ key: "attackFlat", value: 110 }, { key: "int", value: 68 }, { key: "maxMp", value: 158 }], uniqueStats: [] },
                    { name: "ç¦è¡“ã®è­·ç¬¦", type: "accessory", stats: [{ key: "skillMpDiscount", value: 23 }, { key: "maxMp", value: 158 }, { key: "int", value: 68 }], uniqueStats: [] }
                ]
            },
            {
                floorStart: 901,
                items: [
                    { name: "çµ‚æœ«å‰å¤œã®å‰£", type: "weapon", stats: [{ key: "attackFlat", value: 110 }, { key: "str", value: 48 }, { key: "damageBoost", value: 13 }], uniqueStats: [] },
                    { name: "åˆ»å°ã®è­·ç¬¦", type: "accessory", stats: [{ key: "damageBoost", value: 13 }, { key: "maxHp", value: 194 }, { key: "luk", value: 15 }], uniqueStats: [] }
                ]
            }
        ];

        const BossRushLootTables = {};

        const StatLabels = {
            str: "STR",
            vit: "VIT",
            int: "INT",
            dex: "DEX",
            luk: "LUK",
            lukMultiplier: "LUKå€ç‡",
            maxHp: "æœ€å¤§HP",
            maxMp: "æœ€å¤§MP",
            maxHpFlat: "æœ€å¤§HP",
            maxMpFlat: "æœ€å¤§MP",
            attackFlat: "æ”»æ’ƒåŠ›",
            defenseFlat: "é˜²å¾¡åŠ›",
            hpRegen: "HPè‡ªå‹•å›å¾©",
            mpRegen: "MPè‡ªå‹•å›å¾©",
            critRate: "ä¼šå¿ƒç‡",
            critDamage: "ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸",
            damageBoost: "ä¸ãƒ€ãƒ¡å¢—åŠ ",
            damageReduction: "è¢«ãƒ€ãƒ¡è»½æ¸›",
            evasionRate: "å›é¿ç‡",
            leechRate: "å¸è¡€ç‡",
            expBoost: "è¿½åŠ çµŒé¨“å€¤",
            mPen: "é­”æ³•è²«é€š",
            luck: "ãƒ‰ãƒ­ãƒƒãƒ—ç‡",
            accuracy: "å‘½ä¸­ç‡",
            rareFind: "ãƒ¬ã‚¢ãƒ‰ãƒ­ç‡",
            affixFind: "Affixç‡",
            eliteEncounter: "ã‚¨ãƒªãƒ¼ãƒˆé­é‡ç‡",
            goldBoost: "ã‚´ãƒ¼ãƒ«ãƒ‰å¢—åŠ ç‡",
            potionCapacity: "å®¹é‡",
            potionCost: "æ¶ˆè²»é‡",
            potionCostReduction: "æ¶ˆè²»é‡",
            potionHealFlat: "å›å¾©é‡",
            potionHealPct: "å›å¾©é‡",
            potionChargeOnKill: "è¨ä¼å›å¾©",
            potionCleanse: "çŠ¶æ…‹ç•°å¸¸å›å¾©",
            potionAutoRegen: "å†ç”Ÿä»˜ä¸",
            potionBarrier: "ãƒãƒªã‚¢ä»˜ä¸",
            potionResonance: "å…±é³´ä»˜ä¸",
            potionNextHitBoost: "æ¬¡æ’ƒå¼·åŒ–",
            potionLeechBoost: "å¸åå¼·åŒ–",
            potionReflectGuard: "åå°„ç„¡åŠ¹",
            potionSkillMpCut: "ã‚¹ã‚­ãƒ«MPè»½æ¸›",
            poisonMaxStacksBonus: "æ¯’ä¸Šé™ã‚¹ã‚¿ãƒƒã‚¯",
            poisonMinPctBonus: "æ¯’æœ€ä½ä¿è¨¼"
        };

        const PercentStats = new Set([
            "critRate",
            "critDamage",
            "damageBoost",
            "damageReduction",
            "evasionRate",
            "leechRate",
            "expBoost",
            "mPen",
            "luck",
            "accuracy",
            "rareFind",
            "affixFind",
            "eliteEncounter",
            "goldBoost",
            "potionHealPct",
            "potionNextHitBoost",
            "potionLeechBoost",
            "potionSkillMpCut",
            "poisonMinPctBonus"
        ]);

        const RarityDefs = [
            { key: "normal", name: "ãƒãƒ¼ãƒãƒ«", mul: 1.0 },
            { key: "magic", name: "ãƒã‚¸ãƒƒã‚¯", mul: 1.3 },
            { key: "rare", name: "ãƒ¬ã‚¢", mul: 1.8 },
            { key: "epic", name: "ã‚¨ãƒ”ãƒƒã‚¯", mul: 3.0 },
            { key: "legendary", name: "ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼", mul: 5.0 }
        ];
        const RaritySortOrder = Object.fromEntries(RarityDefs.map((def, index) => [def.key, index]));
        const SellBasePrices = {
            normal: 1,
            magic: 10,
            rare: 1000,
            epic: 10000,
            legendary: 100000
        };
        const AffixRankMultipliers = {
            1: 1.2,
            2: 1.5,
            3: 2.0
        };

        const EquipmentTypeLabels = {
            weapon: "æ­¦å™¨",
            armor: "é§",
            head: "å…œ",
            hands: "æ‰‹",
            feet: "è¶³",
            accessory: "è£…é£¾å“",
            potion: "ãƒãƒ¼ã‚·ãƒ§ãƒ³"
        };

        const getEquipmentTypeLabel = (item) => {
            const baseLabel = EquipmentTypeLabels[item?.type] ?? "";
            if (!baseLabel) return baseLabel;
            if (item?.isBossDrop) return `${baseLabel} ãƒœã‚¹ãƒ‰ãƒ­ãƒƒãƒ—`;
            if (item?.isRoadLegendary) return `${baseLabel} é“ä¸­ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼`;
            return baseLabel;
        };

        const InventorySortDefs = {
            acquired: { label: "å…¥æ‰‹é †", icon: "fa-clock" },
            rarity: { label: "ãƒ¬ã‚¢åº¦é †", icon: "fa-gem" },
            affix: { label: "Affixé †", icon: "fa-star" }
        };

        const EquipmentTypePools = {
            weapon: "weapons",
            armor: "armors",
            head: "heads",
            hands: "hands",
            feet: "feet",
            accessory: "accessories"
        };

        const EquipmentBaseSeed = {
            attackFlat: 10,
            defenseFlat: 12,
            maxHp: 18,
            maxMp: 12,
            str: 4,
            vit: 4,
            int: 4,
            dex: 4,
            luk: 2,
            critRate: 3,
            accuracy: 4,
            evasionRate: 4,
            damageReduction: 3
        };

        const EquipmentTypeMultipliers = {
            weapon: 1,
            armor: 1,
            head: 1,
            hands: 1,
            feet: 1,
            accessory: 1
        };

        const getEquipmentGrowthScale = (floor) => {
            const safeFloor = Math.max(1, floor || 1);
            return 1 + safeFloor * 0.018 + safeFloor * safeFloor * 0.000055;
        };

        const getDxScaleMultiplier = (floor) => {
            if (floor < DxFloorStart) return 1;
            const offset = Math.max(1, floor - (DxFloorStart - 1));
            return DxBaseMultiplier * (1 + offset * DxFloorScaleRate) * DxBonusMultiplier;
        };

        const getBossDxScaleMultiplier = (floor) => getDxScaleMultiplier(floor) * BossDxExtraMultiplier;

        const applyDxEnemyScaling = (enemy, floor) => {
            if (!enemy || floor < DxFloorStart) return;
            const multiplier = enemy.isBoss ? getBossDxScaleMultiplier(floor) : getDxScaleMultiplier(floor);
            ["maxHp", "hp", "str", "def", "acc", "eva", "exp"].forEach((key) => {
                if (Number.isFinite(enemy[key])) {
                    enemy[key] = Math.floor(enemy[key] * multiplier);
                }
            });
            if (Number.isFinite(enemy.hp) && Number.isFinite(enemy.maxHp)) {
                enemy.hp = Math.min(enemy.hp, enemy.maxHp);
            }
        };

        const buildDxItemName = (name, floor) => {
            if (!name || floor < DxFloorStart) return name;
            if (name.startsWith("DX")) return name;
            return `DX${name}`;
        };

        const getEquipmentSeedValue = (key) => EquipmentBaseSeed[key] ?? 1;

        const getEquipmentTypeMultiplier = (type) => EquipmentTypeMultipliers[type] ?? 1;

        const buildEquipmentBaseStats = (stats, floor, rarityMul, type) => {
            const scale = getEquipmentGrowthScale(floor) * getDxScaleMultiplier(floor);
            const typeMul = getEquipmentTypeMultiplier(type);
            return stats.map((stat) => {
                const seedValue = getEquipmentSeedValue(stat.key);
                const scaledValue = Math.max(1, Math.round(seedValue * scale * rarityMul * typeMul));
                return { key: stat.key, value: rollStatValue(scaledValue, 0.12) };
            });
        };

        const EquipmentTiers = [
            {
                floorStart: 1,
                weapons: [
                    { name: "æ—…äººã®å‰£", stats: [{ key: "attackFlat", value: 18 }, { key: "str", value: 7 }] },
                    { name: "è¦‹ç¿’ã„ã®çŸ­å‰£", stats: [{ key: "attackFlat", value: 14 }, { key: "dex", value: 9 }] },
                    { name: "æœ¨æ–", stats: [{ key: "attackFlat", value: 12 }, { key: "int", value: 11 }] }
                ],
                armors: [
                    { name: "å¸ƒã®ãƒ­ãƒ¼ãƒ–", stats: [{ key: "defenseFlat", value: 13 }, { key: "maxMp", value: 16 }] },
                    { name: "é©ã®èƒ´ç€", stats: [{ key: "defenseFlat", value: 18 }, { key: "dex", value: 6 }, { key: "maxHp", value: 23 }] },
                    { name: "æœ¨ã®ç›¾é§", stats: [{ key: "defenseFlat", value: 20 }, { key: "vit", value: 7 }] }
                ],
                heads: [
                    { name: "æ—…äººã®ãƒ•ãƒ¼ãƒ‰", stats: [{ key: "defenseFlat", value: 7 }, { key: "maxMp", value: 10 }] },
                    { name: "é©ã®ã‚­ãƒ£ãƒƒãƒ—", stats: [{ key: "defenseFlat", value: 10 }, { key: "dex", value: 6 }] },
                    { name: "æœ¨ç¶¿ã®ãƒ˜ãƒ«ãƒ ", stats: [{ key: "defenseFlat", value: 10 }, { key: "vit", value: 6 }] }
                ],
                hands: [
                    { name: "æ—…äººã®æ‰‹è¢‹", stats: [{ key: "attackFlat", value: 6 }, { key: "dex", value: 3 }] },
                    { name: "é©ã®ã‚°ãƒ­ãƒ¼ãƒ–", stats: [{ key: "defenseFlat", value: 7 }, { key: "dex", value: 6 }] },
                    { name: "å¸ƒã®ãƒŸãƒˆãƒ³", stats: [{ key: "int", value: 3 }, { key: "mpRegen", value: 2 }] }
                ],
                feet: [
                    { name: "æ—…äººã®ãƒ–ãƒ¼ãƒ„", stats: [{ key: "defenseFlat", value: 7 }, { key: "evasionRate", value: 6 }] },
                    { name: "é©ã®ãƒ–ãƒ¼ãƒ„", stats: [{ key: "defenseFlat", value: 10 }, { key: "dex", value: 3 }] },
                    { name: "è»½æ­©ã®é´", stats: [{ key: "accuracy", value: 6 }, { key: "dex", value: 3 }] }
                ],
                accessories: [
                    { name: "ç´ æœ´ãªæŒ‡è¼ª", stats: [{ key: "critRate", value: 3 }, { key: "str", value: 3 }, { key: "luk", value: 2 }] },
                    { name: "è­·ã‚Šã®ãƒšãƒ³ãƒ€ãƒ³ãƒˆ", stats: [{ key: "damageReduction", value: 3 }, { key: "maxHp", value: 19 }] },
                    { name: "å­¦å¾’ã®ã‚¿ãƒªã‚¹ãƒãƒ³", stats: [{ key: "int", value: 6 }, { key: "maxMp", value: 13 }] }
                ]
            },
            {
                floorStart: 51,
                weapons: [
                    { name: "é‹¼ã®å‰£", stats: [{ key: "attackFlat", value: 29 }, { key: "str", value: 12 }] },
                    { name: "ç–¾é¢¨ã®çŸ­å‰£", stats: [{ key: "attackFlat", value: 23 }, { key: "dex", value: 15 }] },
                    { name: "è³¢è€…ã®æ–", stats: [{ key: "attackFlat", value: 22 }, { key: "int", value: 20 }] }
                ],
                armors: [
                    { name: "é­”å°ãƒ­ãƒ¼ãƒ–", stats: [{ key: "defenseFlat", value: 29 }, { key: "maxMp", value: 42 }, { key: "int", value: 9 }] },
                    { name: "ç†Ÿç·´ã®é©é§", stats: [{ key: "defenseFlat", value: 33 }, { key: "dex", value: 10 }, { key: "maxHp", value: 53 }] },
                    { name: "é‹¼é‰„ã®é§", stats: [{ key: "defenseFlat", value: 40 }, { key: "vit", value: 16 }] }
                ],
                heads: [
                    { name: "é‹¼ã®å…œ", stats: [{ key: "defenseFlat", value: 19 }, { key: "vit", value: 10 }] },
                    { name: "ãƒ¬ãƒ³ã‚¸ãƒ£ãƒ¼ãƒãƒƒãƒˆ", stats: [{ key: "defenseFlat", value: 16 }, { key: "dex", value: 10 }] },
                    { name: "é­”å°ã®ã‚µãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ", stats: [{ key: "defenseFlat", value: 12 }, { key: "int", value: 10 }, { key: "maxMp", value: 16 }] }
                ],
                hands: [
                    { name: "é‹¼ã®ã‚¬ãƒ³ãƒˆãƒ¬ãƒƒãƒˆ", stats: [{ key: "defenseFlat", value: 16 }, { key: "str", value: 9 }] },
                    { name: "ç–¾é¢¨ã®ã‚°ãƒ­ãƒ¼ãƒ–", stats: [{ key: "attackFlat", value: 10 }, { key: "dex", value: 10 }] },
                    { name: "è© å”±ã®æ‰‹ç”²", stats: [{ key: "int", value: 9 }, { key: "mpRegen", value: 3 }] }
                ],
                feet: [
                    { name: "é‹¼ã®ãƒ–ãƒ¼ãƒ„", stats: [{ key: "defenseFlat", value: 19 }, { key: "vit", value: 7 }] },
                    { name: "é¢¨åˆ‡ã‚Šã®é´", stats: [{ key: "evasionRate", value: 7 }, { key: "dex", value: 9 }] },
                    { name: "å·¡ç¤¼ã®é´", stats: [{ key: "maxHp", value: 30 }, { key: "hpRegen", value: 3 }] }
                ],
                accessories: [
                    { name: "å‹‡æ°—ã®æŒ‡è¼ª", stats: [{ key: "critRate", value: 6 }, { key: "str", value: 9 }] },
                    { name: "å®ˆè­·ã®é¦–é£¾ã‚Š", stats: [{ key: "damageReduction", value: 6 }, { key: "maxHp", value: 45 }, { key: "luk", value: 3 }] },
                    { name: "çŸ¥æµã®è­·ç¬¦", stats: [{ key: "int", value: 10 }, { key: "maxMp", value: 20 }] }
                ]
            },
            {
                floorStart: 101,
                weapons: [
                    { name: "é»’æ›œå‰£", stats: [{ key: "attackFlat", value: 46 }, { key: "str", value: 20 }, { key: "dex", value: 10 }] },
                    { name: "å½±åˆƒ", stats: [{ key: "attackFlat", value: 43 }, { key: "dex", value: 23 }] },
                    { name: "æ˜Ÿè© ã¿ã®æ–", stats: [{ key: "attackFlat", value: 38 }, { key: "int", value: 29 }, { key: "maxMp", value: 25 }] }
                ],
                armors: [
                    { name: "æ˜Ÿç´¡ãã®ãƒ­ãƒ¼ãƒ–", stats: [{ key: "defenseFlat", value: 45 }, { key: "maxMp", value: 66 }, { key: "int", value: 15 }] },
                    { name: "å½±çºã„ã®èƒ´ç€", stats: [{ key: "defenseFlat", value: 46 }, { key: "dex", value: 16 }, { key: "maxHp", value: 81 }] },
                    { name: "é‡åšãªã‚‹é§", stats: [{ key: "defenseFlat", value: 53 }, { key: "vit", value: 29 }, { key: "maxHp", value: 58 }] }
                ],
                heads: [
                    { name: "æ˜Ÿå† ã®ãƒ˜ãƒ«ãƒ ", stats: [{ key: "defenseFlat", value: 29 }, { key: "vit", value: 19 }] },
                    { name: "å½±ç¸«ã„ã®ãƒ•ãƒ¼ãƒ‰", stats: [{ key: "defenseFlat", value: 23 }, { key: "dex", value: 15 }, { key: "evasionRate", value: 7 }] },
                    { name: "å¤©æ–‡ã®ã‚µãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ", stats: [{ key: "defenseFlat", value: 22 }, { key: "int", value: 16 }, { key: "maxMp", value: 25 }] }
                ],
                hands: [
                    { name: "é»’æ›œã®ç± æ‰‹", stats: [{ key: "attackFlat", value: 16 }, { key: "str", value: 12 }] },
                    { name: "å½±èµ°ã‚Šã®ã‚°ãƒ­ãƒ¼ãƒ–", stats: [{ key: "dex", value: 16 }, { key: "critRate", value: 6 }] },
                    { name: "æ˜Ÿè© ã¿ã®æ‰‹ç”²", stats: [{ key: "int", value: 15 }, { key: "mpRegen", value: 6 }] }
                ],
                feet: [
                    { name: "é‡è£…ã®ãƒ–ãƒ¼ãƒ„", stats: [{ key: "defenseFlat", value: 29 }, { key: "damageReduction", value: 6 }] },
                    { name: "å½±æ­©ãã®é´", stats: [{ key: "evasionRate", value: 10 }, { key: "dex", value: 15 }] },
                    { name: "ç¥å®˜ã®é´", stats: [{ key: "maxHp", value: 53 }, { key: "hpRegen", value: 6 }] }
                ],
                accessories: [
                    { name: "è¦‡è€…ã®æŒ‡è¼ª", stats: [{ key: "critRate", value: 9 }, { key: "damageBoost", value: 6 }] },
                    { name: "æ˜Ÿå®ˆã®è­·ç¬¦", stats: [{ key: "rareFind", value: 6 }, { key: "maxMp", value: 33 }, { key: "luk", value: 7 }] },
                    { name: "é»’æ›œã®ãƒšãƒ³ãƒ€ãƒ³ãƒˆ", stats: [{ key: "damageReduction", value: 7 }, { key: "maxHp", value: 58 }] }
                ]
            }
        ];

        const EquipmentTierBoosts = [
            { floorStart: 201, prefix: "æ·±æ·µã®", scale: 1.25 },
            { floorStart: 401, prefix: "å†¥åŸŸã®", scale: 1.45 },
            { floorStart: 601, prefix: "çµ‚ç„‰ã®", scale: 1.7 },
            { floorStart: 801, prefix: "ç¥åŸŸã®", scale: 1.95 }
        ];

        const buildScaledEquipmentTier = (baseTier, preset) => ({
            floorStart: preset.floorStart,
            weapons: baseTier.weapons.map((item) => ({
                name: `${preset.prefix}${item.name}`,
                stats: item.stats.map((stat) => ({ key: stat.key, value: Math.floor(stat.value * preset.scale) }))
            })),
            armors: baseTier.armors.map((item) => ({
                name: `${preset.prefix}${item.name}`,
                stats: item.stats.map((stat) => ({ key: stat.key, value: Math.floor(stat.value * preset.scale) }))
            })),
            heads: baseTier.heads.map((item) => ({
                name: `${preset.prefix}${item.name}`,
                stats: item.stats.map((stat) => ({ key: stat.key, value: Math.floor(stat.value * preset.scale) }))
            })),
            hands: baseTier.hands.map((item) => ({
                name: `${preset.prefix}${item.name}`,
                stats: item.stats.map((stat) => ({ key: stat.key, value: Math.floor(stat.value * preset.scale) }))
            })),
            feet: baseTier.feet.map((item) => ({
                name: `${preset.prefix}${item.name}`,
                stats: item.stats.map((stat) => ({ key: stat.key, value: Math.floor(stat.value * preset.scale) }))
            })),
            accessories: baseTier.accessories.map((item) => ({
                name: `${preset.prefix}${item.name}`,
                stats: item.stats.map((stat) => ({ key: stat.key, value: Math.floor(stat.value * preset.scale) }))
            }))
        });

        const baseEquipmentTier = EquipmentTiers[EquipmentTiers.length - 1];
        EquipmentTierBoosts.forEach((preset) => {
            EquipmentTiers.push(buildScaledEquipmentTier(baseEquipmentTier, preset));
        });

        const PotionScaledStats = new Set([
            "potionCapacity",
            "potionHealFlat",
            "potionHealPct",
            "potionChargeOnKill"
        ]);

        const PotionBases = [
            { name: "HPå›å¾©è–¬(å°)", target: "hp", healType: "pct", healMode: "hybridCap", healCapPct: 25, icon: "fa-heart", stats: [{ key: "potionHealFlat", value: 60 }, { key: "potionHealPct", value: 3 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 30 }, { key: "potionChargeOnKill", value: 14 }] },
            { name: "HPå›å¾©è–¬(ä¸­)", target: "hp", healType: "pct", healMode: "hybridCap", healCapPct: 28, icon: "fa-heart", stats: [{ key: "potionHealFlat", value: 90 }, { key: "potionHealPct", value: 5 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 45 }, { key: "potionChargeOnKill", value: 12 }] },
            { name: "HPå›å¾©è–¬(å¤§)", target: "hp", healType: "pct", healMode: "hybridCap", healCapPct: 32, icon: "fa-heart", stats: [{ key: "potionHealFlat", value: 120 }, { key: "potionHealPct", value: 7 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 60 }, { key: "potionChargeOnKill", value: 10 }] },
            { name: "MPå›å¾©è–¬(å°)", target: "mp", healType: "pct", healMode: "hybridCap", healCapPct: 25, icon: "fa-droplet", stats: [{ key: "potionHealFlat", value: 40 }, { key: "potionHealPct", value: 4 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 30 }, { key: "potionChargeOnKill", value: 14 }] },
            { name: "MPå›å¾©è–¬(ä¸­)", target: "mp", healType: "pct", healMode: "hybridCap", healCapPct: 28, icon: "fa-droplet", stats: [{ key: "potionHealFlat", value: 65 }, { key: "potionHealPct", value: 6 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 45 }, { key: "potionChargeOnKill", value: 12 }] },
            { name: "MPå›å¾©è–¬(å¤§)", target: "mp", healType: "pct", healMode: "hybridCap", healCapPct: 32, icon: "fa-droplet", stats: [{ key: "potionHealFlat", value: 90 }, { key: "potionHealPct", value: 8 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 60 }, { key: "potionChargeOnKill", value: 10 }] },
            { name: "HPå›å¾©å‰¤(å°)", target: "hp", healType: "pct", healMode: "missing", icon: "fa-heart", stats: [{ key: "potionHealFlat", value: 40 }, { key: "potionHealPct", value: 15 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 30 }, { key: "potionChargeOnKill", value: 14 }] },
            { name: "HPå›å¾©å‰¤(ä¸­)", target: "hp", healType: "pct", healMode: "missing", icon: "fa-heart", stats: [{ key: "potionHealFlat", value: 60 }, { key: "potionHealPct", value: 20 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 45 }, { key: "potionChargeOnKill", value: 12 }] },
            { name: "HPå›å¾©å‰¤(å¤§)", target: "hp", healType: "pct", healMode: "missing", icon: "fa-heart", stats: [{ key: "potionHealFlat", value: 80 }, { key: "potionHealPct", value: 25 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 60 }, { key: "potionChargeOnKill", value: 10 }] },
            { name: "MPå›å¾©å‰¤(å°)", target: "mp", healType: "pct", healMode: "missing", icon: "fa-droplet", stats: [{ key: "potionHealFlat", value: 25 }, { key: "potionHealPct", value: 20 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 30 }, { key: "potionChargeOnKill", value: 14 }] },
            { name: "MPå›å¾©å‰¤(ä¸­)", target: "mp", healType: "pct", healMode: "missing", icon: "fa-droplet", stats: [{ key: "potionHealFlat", value: 40 }, { key: "potionHealPct", value: 25 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 45 }, { key: "potionChargeOnKill", value: 12 }] },
            { name: "MPå›å¾©å‰¤(å¤§)", target: "mp", healType: "pct", healMode: "missing", icon: "fa-droplet", stats: [{ key: "potionHealFlat", value: 55 }, { key: "potionHealPct", value: 30 }, { key: "potionCapacity", value: 100 }, { key: "potionCost", value: 60 }, { key: "potionChargeOnKill", value: 10 }] }
        ];

        const PotionPrefixAffixes = [
            { name: "å¢—é‡ã®", rank: 1, stats: ["potionCapacity"] },
            { name: "çŒ›æ’ƒã®", rank: 1, stats: ["potionNextHitBoost"] },
            { name: "æµ„åŒ–ã®", rank: 1, stats: ["potionCleanse"] },
            { name: "å¤§å®¹é‡ã®", rank: 2, stats: ["potionCapacity", "potionResonance"] },
            { name: "ç²¾è£½ã®", rank: 2, stats: ["potionNextHitBoost", "potionAutoRegen"] },
            { name: "ç¥ˆã‚Šã®", rank: 2, stats: ["potionAutoRegen", "potionCleanse"] },
            { name: "ç¥è–¬ã®", rank: 3, stats: ["potionCapacity", "potionResonance", "potionAutoRegen"] },
            { name: "éœŠè–¬ã®", rank: 3, stats: ["potionNextHitBoost", "potionAutoRegen", "potionBarrier"] },
            { name: "ç§˜è–¬ã®", rank: 3, stats: ["potionCapacity", "potionReflectGuard", "potionCleanse"] }
        ];

        const PotionSuffixAffixes = [
            { name: "ã®ç¯€ç´„", rank: 1, stats: ["potionCostReduction"] },
            { name: "ã®èŠ½å¹ã", rank: 1, stats: ["potionAutoRegen"] },
            { name: "ã®è§£æ¯’", rank: 1, stats: ["potionCleanse"] },
            { name: "ã®æ¸‡æœ›", rank: 2, stats: ["potionLeechBoost", "potionCostReduction"] },
            { name: "ã®å¾ªç’°", rank: 2, stats: ["potionAutoRegen", "potionCostReduction"] },
            { name: "ã®æµ„åŒ–", rank: 2, stats: ["potionCleanse", "potionAutoRegen"] },
            { name: "ã®è¶…è¶Š", rank: 3, stats: ["potionCapacity", "potionSkillMpCut", "potionCostReduction"] },
            { name: "ã®ç¥ç¦", rank: 3, stats: ["potionResonance", "potionCostReduction", "potionAutoRegen"] },
            { name: "ã®æµ„å¤©", rank: 3, stats: ["potionCleanse", "potionReflectGuard", "potionCostReduction"] }
        ];

        const PrefixAffixes = [
            { name: "é‹­æ’ƒã®", suffixName: "ã®å†’é™ºè€…", rank: 1, group: "attack", stats: ["attackFlat"] },
            { name: "ç‹™æ’ƒã®", suffixName: "ã®æˆ¦é¬¼", rank: 1, group: "attack", stats: ["critRate"] },
            { name: "å¼·æ‰“ã®", suffixName: "ã®ãƒ»ç´…åˆƒ", rank: 1, group: "attack", stats: ["str"] },
            { name: "é‰„å£ã®", suffixName: "ã®å®ˆäºº", rank: 1, group: "defense", stats: ["defenseFlat"] },
            { name: "å …å®ˆã®", suffixName: "ã®ç›¾æŒã¡", rank: 1, group: "defense", stats: ["vit"] },
            { name: "è€ä¹…ã®", suffixName: "ã®ãƒ»è­·ç›¾", rank: 1, group: "defense", stats: ["maxHp"] },
            { name: "å¹¸é‹ã®", suffixName: "ã®æ—…å•†", rank: 1, group: "treasure", stats: ["luck"] },
            { name: "è²¡é‹ã®", suffixName: "ã®æ¢ç´¢è€…", rank: 1, group: "treasure", stats: ["goldBoost"] },
            { name: "æ¢ç´¢ã®", suffixName: "ã®ãƒ»é‡‘çŒ«", rank: 1, group: "treasure", stats: ["rareFind"] },
            { name: "ç™’ã—ã®", suffixName: "ã®è–æ­Œ", rank: 1, group: "support", stats: ["hpRegen"] },
            { name: "èª¿å¾‹ã®", suffixName: "ã®ç™’å¥", rank: 1, group: "support", stats: ["mpRegen"] },
            { name: "ç²¾å¯†ã®", suffixName: "ã®é·¹çœ¼", rank: 1, group: "precision", stats: ["accuracy"] },
            { name: "é›†ä¸­ã®", suffixName: "ã®å°„æ‰‹", rank: 1, group: "precision", stats: ["accuracy", "critRate"] },
            { name: "ç›´æ„Ÿã®", suffixName: "ã®ãƒ»è’¼ç³", rank: 1, group: "precision", stats: ["accuracy", "dex"] },
            { name: "ç”Ÿå‘½ã®", suffixName: "ã®æ´»åŠ›", rank: 1, group: "vitality", stats: ["maxHp"] },
            { name: "ç²¾ç¥ã®", suffixName: "ã®éœŠæ°—", rank: 1, group: "vitality", stats: ["maxMp"] },
            { name: "æµ„åŒ–ã®", suffixName: "ã®è­·ç¬¦", rank: 1, group: "resistance", stats: ["hpRegen"] },
            { name: "æŠµæŠ—ã®", suffixName: "ã®é™å¯‚", rank: 1, group: "resistance", stats: ["damageReduction"] },
            { name: "å•†æ‰ã®", suffixName: "ã®èˆªè·¯", rank: 1, group: "economy", stats: ["goldBoost"] },
            { name: "çµŒé¨“ã®", suffixName: "ã®çŸ¥æµ", rank: 1, group: "economy", stats: ["expBoost"] },
            { name: "å¹¸é‹ã®", suffixName: "ã®å®åŒ ", rank: 1, group: "economy", stats: ["luck"] },
            { name: "å‰›åŠ›ã®", suffixName: "ã®å‰›è…•", rank: 1, group: "stat", stats: ["str"] },
            { name: "ç†çŸ¥ã®", suffixName: "ã®è³¢è€…", rank: 1, group: "stat", stats: ["int"] },
            { name: "ä¿Šæ•ã®", suffixName: "ã®è¿…è„š", rank: 1, group: "stat", stats: ["dex"] },
            { name: "å‰›æ’ƒã®", suffixName: "ã®çƒˆé¢¨", rank: 2, group: "attack", stats: ["str", "critRate"] },
            { name: "æ–¬è£‚ã®", suffixName: "ã®å‰£èˆ", rank: 2, group: "attack", stats: ["attackFlat", "damageBoost"] },
            { name: "çŒ›é€²ã®", suffixName: "ã®é»’ç¿¼", rank: 2, group: "attack", stats: ["damageBoost", "attackFlat"] },
            { name: "å®ˆè­·ã®", suffixName: "ã®ç ¦å®ˆ", rank: 2, group: "defense", stats: ["vit", "maxHp"] },
            { name: "å …ç‰¢ã®", suffixName: "ã®è’¼å£", rank: 2, group: "defense", stats: ["damageReduction", "defenseFlat"] },
            { name: "ä¸å±ˆã®", suffixName: "ã®ä¸å‹•", rank: 2, group: "defense", stats: ["hpRegen", "damageReduction"] },
            { name: "è±Šç©£ã®", suffixName: "ã®å®è·¯", rank: 2, group: "treasure", stats: ["rareFind", "goldBoost"] },
            { name: "è’é›†ã®", suffixName: "ã®æ˜Ÿè¦‹", rank: 2, group: "treasure", stats: ["affixFind", "expBoost"] },
            { name: "æ¡æ˜ã®", suffixName: "ã®æ‹¾éº", rank: 2, group: "treasure", stats: ["goldBoost", "expBoost"] },
            { name: "æ…ˆæ„›ã®", suffixName: "ã®å®‰å¯§", rank: 2, group: "support", stats: ["hpRegen", "maxHp"] },
            { name: "ç‘æƒ³ã®", suffixName: "ã®æœˆç¥ˆ", rank: 2, group: "support", stats: ["mpRegen", "maxMp"] },
            { name: "æ²»ç™’ã®", suffixName: "ã®ç™½ç¯", rank: 2, group: "support", stats: ["hpRegen", "maxHp"] },
            { name: "ç…§æº–ã®", suffixName: "ã®æ…§çœ¼", rank: 2, group: "precision", stats: ["accuracy", "critRate"] },
            { name: "è¦‹åˆ‡ã‚Šã®", suffixName: "ã®å¤œéš¼", rank: 2, group: "precision", stats: ["accuracy", "evasionRate"] },
            { name: "è²«é€šã®", suffixName: "ã®è¿…è¦–", rank: 2, group: "precision", stats: ["accuracy", "mPen"] },
            { name: "å……å®Ÿã®", suffixName: "ã®ç‘ç©‚", rank: 2, group: "vitality", stats: ["maxHp", "hpRegen"] },
            { name: "å……é­”ã®", suffixName: "ã®æ—ºç››", rank: 2, group: "vitality", stats: ["maxMp", "mpRegen"] },
            { name: "ä½“åŠ›ã®", suffixName: "ã®æ·±æ³‰", rank: 2, group: "vitality", stats: ["maxHp", "hpRegen"] },
            { name: "å…ç–«ã®", suffixName: "ã®é˜²å£", rank: 2, group: "resistance", stats: ["damageReduction", "hpRegen"] },
            { name: "æ–­çµ¶ã®", suffixName: "ã®æŠ—é­”", rank: 2, group: "resistance", stats: ["damageReduction", "evasionRate"] },
            { name: "åç›Šã®", suffixName: "ã®å¯Œç±¤", rank: 2, group: "economy", stats: ["goldBoost", "expBoost"] },
            { name: "ç™ºè¦‹ã®", suffixName: "ã®äº¤æ˜“", rank: 2, group: "economy", stats: ["rareFind", "affixFind"] },
            { name: "å®æ¢ã—ã®", suffixName: "ã®é»„é‡‘è·¯", rank: 2, group: "economy", stats: ["rareFind", "goldBoost"] },
            { name: "æ­¦å‹‡ã®", suffixName: "ã®è±ªèƒ†", rank: 2, group: "stat", stats: ["str", "dex"] },
            { name: "è‹±çŸ¥ã®", suffixName: "ã®æ™ºå°", rank: 2, group: "stat", stats: ["int", "critRate"] },
            { name: "æ©Ÿæ•ã®", suffixName: "ã®ç–¾å½±", rank: 2, group: "stat", stats: ["dex", "evasionRate"] },
            { name: "è¦‡ç‹ã®", suffixName: "ã®é­”å‰£", rank: 3, group: "attack", stats: ["str", "critDamage", "damageBoost"] },
            { name: "ç ´å£Šã®", suffixName: "ã®ç–¾é¢¨", rank: 3, group: "attack", stats: ["damageBoost", "critDamage", "critRate"] },
            { name: "æ»…æ®ºã®", suffixName: "ã®è¦‡è€…", rank: 3, group: "attack", stats: ["attackFlat", "critRate", "accuracy"] },
            { name: "ä¸å±ˆã®", suffixName: "ã®å …é™£", rank: 3, group: "defense", stats: ["vit", "damageReduction", "hpRegen"] },
            { name: "ç£çŸ³ã®", suffixName: "ã®è­·è¡›", rank: 3, group: "defense", stats: ["maxHp", "evasionRate", "damageReduction"] },
            { name: "è­·ç¥ã®", suffixName: "ã®é™å£", rank: 3, group: "defense", stats: ["defenseFlat", "damageReduction", "hpRegen"] },
            { name: "å¤©é‹ã®", suffixName: "ã®å®åŒ ", rank: 3, group: "treasure", stats: ["luck", "rareFind", "affixFind"] },
            { name: "è‡³å®ã®", suffixName: "ã®é»„é‡‘è·¯", rank: 3, group: "treasure", stats: ["rareFind", "goldBoost", "affixFind"] },
            { name: "éš†ç››ã®", suffixName: "ã®ç‘å…†", rank: 3, group: "treasure", stats: ["luck", "goldBoost", "expBoost"] },
            { name: "ç¥ç¦ã®", suffixName: "ã®æ…ˆé›¨", rank: 3, group: "support", stats: ["hpRegen", "mpRegen", "maxHp"] },
            { name: "æ•‘æ¸ˆã®", suffixName: "ã®å›ç”Ÿ", rank: 3, group: "support", stats: ["hpRegen", "maxHp", "damageReduction"] },
            { name: "è–æ³‰ã®", suffixName: "ã®å¤©æµ", rank: 3, group: "support", stats: ["mpRegen", "maxMp", "int"] },
            { name: "ç¥çœ¼ã®", suffixName: "ã®ç‹™æ˜Ÿ", rank: 3, group: "precision", stats: ["accuracy", "critRate", "critDamage"] },
            { name: "ç„¡åŒã®", suffixName: "ã®ç©ºåˆƒ", rank: 3, group: "precision", stats: ["accuracy", "critRate", "critDamage"] },
            { name: "çœ‹ç ´ã®", suffixName: "ã®å°çœ¼", rank: 3, group: "precision", stats: ["accuracy", "mPen", "damageBoost"] },
            { name: "ä¸æ»…ã®", suffixName: "ã®è’¼å‘½", rank: 3, group: "vitality", stats: ["maxHp", "damageReduction", "hpRegen"] },
            { name: "ç¥é«„ã®", suffixName: "ã®å†ç´¡", rank: 3, group: "vitality", stats: ["maxMp", "mpRegen", "maxHp"] },
            { name: "æ’å¸¸ã®", suffixName: "ã®æ°¸ç’°", rank: 3, group: "vitality", stats: ["maxHp", "maxMp", "hpRegen"] },
            { name: "çµç•Œã®", suffixName: "ã®ç„å£", rank: 3, group: "resistance", stats: ["damageReduction", "maxHp", "hpRegen"] },
            { name: "æ¸…å»‰ã®", suffixName: "ã®ç¥“å°", rank: 3, group: "resistance", stats: ["hpRegen", "mpRegen", "maxHp"] },
            { name: "ä¸ä¾µã®", suffixName: "ã®é™é˜²", rank: 3, group: "resistance", stats: ["damageReduction", "evasionRate", "maxHp"] },
            { name: "ç¹æ „ã®", suffixName: "ã®ç‘å…†", rank: 3, group: "economy", stats: ["goldBoost", "expBoost", "luck"] },
            { name: "å¤§å¯Œè±ªã®", suffixName: "ã®è”µç‹", rank: 3, group: "economy", stats: ["goldBoost", "rareFind", "affixFind"] },
            { name: "ä¼æ‰¿ã®", suffixName: "ã®ç§˜éŒ²", rank: 3, group: "economy", stats: ["expBoost", "rareFind", "affixFind"] },
            { name: "è¦‡æ°—ã®", suffixName: "ã®è¦‡é“", rank: 3, group: "stat", stats: ["str", "dex", "damageBoost"] },
            { name: "å¡æ™ºã®", suffixName: "ã®å¤©è³¢", rank: 3, group: "stat", stats: ["int", "critRate", "maxMp"] },
            { name: "è¶…é€Ÿã®", suffixName: "ã®è¿…ç‰™", rank: 3, group: "stat", stats: ["dex", "accuracy", "critRate"] }
        ];

        const SuffixAffixes = PrefixAffixes.map(({ suffixName, ...affix }) => ({
            ...affix,
            name: suffixName || `ã®${affix.name.replace(/ã®$/, "")}`
        }));

        const AffixValueTable = {
            str: [5, 9, 14],
            vit: [6, 11, 18],
            int: [5, 9, 14],
            dex: [5, 9, 14],
            luk: [3, 6, 10],
            maxHp: [35, 80, 140],
            maxMp: [15, 35, 70],
            maxHpFlat: [35, 80, 140],
            maxMpFlat: [15, 35, 70],
            attackFlat: [9, 17, 31],
            defenseFlat: [11, 21, 39],
            hpRegen: [4, 7, 13],
            mpRegen: [1, 2, 4],
            critRate: [3, 6, 10],
            critDamage: [14, 28, 49],
            damageBoost: [5, 9, 14],
            damageReduction: [2, 4, 8],
            evasionRate: [4, 7, 13],
            leechRate: [2, 4, 6],
            expBoost: [4, 8, 15],
            mPen: [5, 9, 14],
            luck: [5, 10, 18],
            accuracy: [3, 6, 10],
            rareFind: [4, 8, 15],
            affixFind: [5, 10, 18],
            goldBoost: [5, 10, 18],
            potionCapacity: [15, 30, 50],
            potionHeal: [10, 22, 38],
            potionCostReduction: [5, 10, 18],
            potionCleanse: [1, 2, 3],
            potionAutoRegen: [1, 2, 3],
            potionChargeOnKill: [5, 10, 18],
            potionBarrier: [1, 2, 3],
            potionResonance: [1, 1, 1],
            potionNextHitBoost: [20, 35, 50],
            potionLeechBoost: [8, 12, 16],
            potionReflectGuard: [1, 2, 3],
            potionSkillMpCut: [30, 50, 70]
        };

        const pickRandom = (list) => list[Math.floor(Math.random() * list.length)];
        const clampPercent = (value) => Math.max(0, Math.min(100, value));
        const getDamageRatio = (attack, defense) => {
            const atk = Math.max(1, Math.floor(attack));
            const def = Math.max(0, Math.floor(defense));
            return atk / (atk + def);
        };
        const rollStatValue = (baseValue, variance = 0.12) => {
            const min = Math.max(1, Math.floor(baseValue * (1 - variance)));
            const max = Math.max(min, Math.ceil(baseValue * (1 + variance)));
            return min === max ? min : (min + Math.floor(Math.random() * (max - min + 1)));
        };
        const getAffixLevelMultiplier = () => 1 + Math.max(0, (Game.player.level || 1) - 1) * 0.0015;

        const rollEliteRank = (encounterRate) => {
            const safeRate = Math.max(0, encounterRate);
            const chance = Math.min(100, safeRate);
            if (Math.random() * 100 >= chance) return 0;
            const eligible = EliteRankWeights.filter((entry) => (
                entry.minEncounter === undefined || safeRate >= entry.minEncounter
            ));
            if (eligible.length === 0) return 0;
            const rankBias = Math.max(0, safeRate - 100) / 100;
            const biasMultiplier = 1 + rankBias;
            const adjusted = eligible.map((entry) => ({
                ...entry,
                adjustedWeight: entry.weight * (1 + (entry.rank - 1) * 0.25 * biasMultiplier)
            }));
            const totalWeight = adjusted.reduce((sum, entry) => sum + entry.adjustedWeight, 0);
            let roll = Math.random() * totalWeight;
            for (const entry of adjusted) {
                if (roll < entry.adjustedWeight) return entry.rank;
                roll -= entry.adjustedWeight;
            }
            return adjusted[0].rank;
        };

        const buildEliteEnemy = (baseEnemy, rank) => {
            const prefixPool = ElitePrefixes[rank] || ["å¼·åŒ–ã•ã‚ŒãŸ"];
            const prefix = pickRandom(prefixPool);
            const stars = "â˜…".repeat(rank);
            const boosts = [];
            let maxHp = baseEnemy.maxHp;
            let str = baseEnemy.str;
            let exp = baseEnemy.exp;
            let lootMultiplier = 1;

            for (let i = 0; i < rank; i++) {
                const boost = pickRandom(EliteStatBoostPool);
                boosts.push(boost.key);
                if (boost.key === "hp") {
                    maxHp = Math.floor(maxHp * boost.multiplier);
                } else if (boost.key === "str") {
                    str = Math.floor(str * boost.multiplier);
                } else if (boost.key === "exp") {
                    exp = Math.floor(exp * boost.multiplier);
                } else if (boost.key === "loot") {
                    lootMultiplier *= boost.multiplier;
                }
            }

            return {
                ...baseEnemy,
                name: `${stars}${prefix}${baseEnemy.name}`,
                maxHp,
                hp: maxHp,
                str,
                exp,
                elite: { rank, prefix, boosts, lootMultiplier }
            };
        };

        const EnemyArchetypes = {
            balanced: { id: "balanced", label: "æ¨™æº–", hp: 1, str: 1, def: 1, acc: 1, eva: 1 },
            speed: { id: "speed", label: "é€Ÿåº¦å‹", hp: 0.85, str: 1, def: 0.95, acc: 1.1, eva: 1.25 },
            attack: { id: "attack", label: "æ”»æ’ƒå‹", hp: 0.9, str: 1.25, def: 0.9, acc: 1.05, eva: 1 },
            defense: { id: "defense", label: "é˜²å¾¡å‹", hp: 1.25, str: 0.85, def: 1.2, acc: 0.95, eva: 0.95 }
        };
        const EnemyArchetypePool = ["balanced", "speed", "attack", "defense"];

        const getEnemyArchetypeId = (enemy) => enemy?.archetype || pickRandom(EnemyArchetypePool);

        const getEnemySkillInterval = (archetypeId) => {
            if (archetypeId === "speed") return 2;
            if (archetypeId === "defense") return 4;
            if (archetypeId === "attack") return 3;
            return 3;
        };

        const buildEnemySkillSet = (archetypeId, existingSkills = [], options = {}) => {
            const pool = options.pool || EnemySkillPools[archetypeId] || EnemySkillPools.balanced;
            const extraSkill = pickRandom(pool);
            const skills = Array.isArray(existingSkills) ? [...existingSkills] : [];
            if (skills.length >= 2) return skills.slice(0, 2);
            if (skills.length > 0) {
                if (extraSkill) skills.push(extraSkill);
                return skills.slice(0, 2);
            }
            if (extraSkill) skills.push(extraSkill);
            return skills;
        };

        const getEnemyLevelByFloor = (floor) => {
            const safeFloor = Math.max(1, floor || 1);
            return Math.max(1, Math.floor(safeFloor));
        };

        const calcEnemyBaseStatsByLevel = (level) => {
            const safeLevel = Math.max(1, level || 1);
            const scale = safeLevel - 1;
            const calcStat = (base, addPerLevel, percentPerLevel) => {
                const percentScale = (percentPerLevel / 100) * scale;
                return Math.floor(base + addPerLevel * scale + base * percentScale);
            };
            return {
                maxHp: calcStat(22, 6.0, 0.25),
                hp: calcStat(22, 6.0, 0.25),
                str: calcStat(5, 1.9, 0.4),
                def: calcStat(3, 1.0, 0.32),
                acc: calcStat(5, 0.3, 0.15),
                eva: calcStat(1, 0.25, 0.15),
                exp: calcStat(12, 2.3, 0.3)
            };
        };

        const applyBossFloorGrowth = (baseStats, floor) => {
            const safeFloor = Math.max(1, floor || 1);
            const scale = safeFloor - 1;
            const calcBossStat = (base, addPerFloor, percentPerFloor) => {
                const percentScale = (percentPerFloor / 100) * scale;
                return Math.floor(base + addPerFloor * scale + base * percentScale);
            };
            return {
                maxHp: calcBossStat(baseStats.maxHp, 8, 1.3),
                hp: calcBossStat(baseStats.hp, 8, 1.3),
                str: calcBossStat(baseStats.str, 2.6, 0.9),
                def: calcBossStat(baseStats.def, 1.7, 0.7),
                acc: calcBossStat(baseStats.acc, 0.4, 0.2),
                eva: calcBossStat(baseStats.eva, 0.35, 0.2),
                exp: calcBossStat(baseStats.exp, 4, 0.8)
            };
        };

        const applyEnemyArchetype = (baseStats, archetypeId = "balanced") => {
            const archetype = EnemyArchetypes[archetypeId] || EnemyArchetypes.balanced;
            return {
                maxHp: Math.floor(baseStats.maxHp * archetype.hp),
                hp: Math.floor(baseStats.hp * archetype.hp),
                str: Math.floor(baseStats.str * archetype.str),
                def: Math.floor(baseStats.def * archetype.def),
                acc: Math.floor(baseStats.acc * archetype.acc),
                eva: Math.floor(baseStats.eva * archetype.eva),
                exp: Math.floor(baseStats.exp),
                archetypeId: archetype.id,
                archetypeLabel: archetype.label
            };
        };

        const calcEnemyStatsByFloor = (floor, base, archetypeId = "balanced") => {
            const level = getEnemyLevelByFloor(floor);
            const baseStats = calcEnemyBaseStatsByLevel(level);
            return applyEnemyArchetype(baseStats, archetypeId);
        };

        const getBossScale = (floor) => {
            const hpScale = 1 + (floor * 0.015) + (floor * floor * 0.00015);
            return hpScale;
        };

        const getBossRushScale = (floor) => {
            const count = Math.max(1, floor - BossRushStartFloor + 1);
            return BossRushBaseScale + (count - 1) * BossRushScaleStep;
        };

        const getEnemyPool = (floor) => {
            const baseIdx = Math.min(EnemyTiers.length - 1, Math.floor((floor - 1) / 100));
            return EnemyTiers[baseIdx];
        };

        const getTierIndex = (floor) => {
            for (let i = EquipmentTiers.length - 1; i >= 0; i--) {
                if (floor >= EquipmentTiers[i].floorStart) return i;
            }
            return 0;
        };

        const getRoadLegendaryTable = (floor) => {
            for (let i = RoadLegendaryLootTables.length - 1; i >= 0; i--) {
                if (floor >= RoadLegendaryLootTables[i].floorStart) return RoadLegendaryLootTables[i];
            }
            return RoadLegendaryLootTables[0];
        };

        const rollRarity = (rareFind, eliteRank = 0, options = {}) => {
            let weights = [
                { key: "normal", weight: 60 },
                { key: "magic", weight: 25 },
                { key: "rare", weight: 10 },
                { key: "epic", weight: 4 },
                { key: "legendary", weight: 1 }
            ];
            if (options.maxRarityKey) {
                const maxIndex = weights.findIndex((rarity) => rarity.key === options.maxRarityKey);
                if (maxIndex >= 0) {
                    weights = weights.slice(0, maxIndex + 1);
                }
            }
            const bonus = Math.max(0, rareFind) / 100;
            const eliteBonus = Math.max(0, eliteRank) * 0.12;
            const adjusted = weights.map((rarity, idx) => ({
                key: rarity.key,
                weight: rarity.weight * (1 + bonus * idx + eliteBonus * idx)
            }));
            const total = adjusted.reduce((sum, r) => sum + r.weight, 0);
            let roll = Math.random() * total;
            let selected = adjusted[0];
            for (const rarity of adjusted) {
                if (roll < rarity.weight) {
                    selected = rarity;
                    break;
                }
                roll -= rarity.weight;
            }
            return RarityDefs.find((rarity) => rarity.key === selected.key);
        };

        const rollAffixRank = (affixRate, eliteRank = 0) => {
            const baseRank3 = 0.12;
            const maxRank3 = 0.9;
            const baseRank2 = 0.25;
            const minRank2 = 0.05;
            const progress = Math.min(1, Math.max(0, affixRate + eliteRank * 4) / 240);
            const rank3 = baseRank3 + (maxRank3 - baseRank3) * progress;
            const rank2 = baseRank2 + (minRank2 - baseRank2) * progress;
            const rank1 = Math.max(0, 1 - rank2 - rank3);
            const roll = Math.random();
            if (roll < rank1) return 1;
            if (roll < rank1 + rank2) return 2;
            return 3;
        };

        const getAffixStats = (affix, rank) => {
            const pool = affix.fixedStats || affix.stats || [];
            const selected = pool.slice(0, Math.max(1, rank));
            const levelMultiplier = getAffixLevelMultiplier();
            return selected.map((key) => {
                const baseValues = AffixValueTable[key] || [1, 2, 3];
                const scaledValue = baseValues[rank - 1] * 1.5 * levelMultiplier;
                return { key, value: rollStatValue(scaledValue, 0.15) };
            });
        };

        const rollAffix = (pool, rank) => {
            const candidates = pool.filter((affix) => affix.rank === rank);
            const affix = pickRandom(candidates);
            const stats = getAffixStats(affix, rank);
            return { name: affix.name, rank, stats };
        };

        const buildItem = (base, type, options = {}) => {
            const totals = getTotalStats();
            const eliteRank = Game.enemy?.elite?.rank || 0;
            const rarity = options.forceLegendary
                ? (RarityDefs.find((def) => def.key === "legendary") || RarityDefs[RarityDefs.length - 1])
                : rollRarity(totals.rareFind, eliteRank, { maxRarityKey: options.maxRarityKey });
            const affixRate = totals.affixFind + eliteRank * 8;
            const affixChance = Math.min(100, 2 + affixRate);
            const prefixRank = Math.random() * 100 < affixChance ? rollAffixRank(affixRate, eliteRank) : 0;
            const suffixRank = Math.random() * 100 < affixChance ? rollAffixRank(affixRate, eliteRank) : 0;
            const prefix = prefixRank ? rollAffix(PrefixAffixes, prefixRank) : null;
            const suffix = suffixRank ? rollAffix(SuffixAffixes, suffixRank) : null;
            const prefixStars = prefix ? "â˜†".repeat(prefix.rank) : "";
            const suffixStars = suffix ? "â˜†".repeat(suffix.rank) : "";
            const originFloor = Math.max(1, options.floor ?? Game.floor ?? 1);
            const baseStats = buildEquipmentBaseStats(base.stats, originFloor, rarity.mul, type);
            const affixStats = [
                ...(prefix ? prefix.stats.map((stat) => ({ ...stat, source: "prefix" })) : []),
                ...(suffix ? suffix.stats.map((stat) => ({ ...stat, source: "suffix" })) : [])
            ];
            const item = {
                name: `${prefixStars}${prefix ? prefix.name : ""}${base.name}${suffix ? suffix.name : ""}${suffixStars}`,
                type,
                rarity: rarity.key,
                rarityMul: rarity.mul,
                baseStats,
                affixStats,
                uniqueStats: [],
                prefix,
                suffix,
                originFloor
            };
            item.name = buildDxItemName(item.name, originFloor);
            if (item.type !== "potion") {
                item.enhancementLevel = 0;
                item.isBroken = false;
            }
            return item;
        };

        const convertPotionAffixStats = (stats, base) => {
            return stats.map((stat) => {
                if (stat.key !== "potionHeal") return stat;
                const key = base.healType === "pct" ? "potionHealPct" : "potionHealFlat";
                return { ...stat, key };
            });
        };

        const buildPotion = (base, options = {}) => {
            const totals = getTotalStats();
            const eliteRank = Game.enemy?.elite?.rank || 0;
            const rarity = options.forceRarityKey
                ? (RarityDefs.find((def) => def.key === options.forceRarityKey) || RarityDefs[0])
                : rollRarity(totals.rareFind, eliteRank);
            const affixRate = totals.affixFind + eliteRank * 8;
            const affixChance = options.noAffix ? 0 : Math.min(100, 2 + affixRate);
            const prefixRank = Math.random() * 100 < affixChance ? rollAffixRank(affixRate, eliteRank) : 0;
            const suffixRank = Math.random() * 100 < affixChance ? rollAffixRank(affixRate, eliteRank) : 0;
            const prefix = prefixRank ? rollAffix(PotionPrefixAffixes, prefixRank) : null;
            const suffix = suffixRank ? rollAffix(PotionSuffixAffixes, suffixRank) : null;
            const prefixStars = prefix ? "â˜†".repeat(prefix.rank) : "";
            const suffixStars = suffix ? "â˜†".repeat(suffix.rank) : "";
            const baseStats = base.stats.map((stat) => {
                const scale = PotionScaledStats.has(stat.key) ? rarity.mul : 1;
                return { key: stat.key, value: Math.max(1, Math.floor(stat.value * scale)) };
            });
            const affixStats = convertPotionAffixStats([
                ...(prefix ? prefix.stats.map((stat) => ({ ...stat, source: "prefix" })) : []),
                ...(suffix ? suffix.stats.map((stat) => ({ ...stat, source: "suffix" })) : [])
            ], base);
            const potion = {
                name: `${prefixStars}${prefix ? prefix.name : ""}${base.name}${suffix ? suffix.name : ""}${suffixStars}`,
                type: "potion",
                target: base.target,
                healType: base.healType,
                healMode: base.healMode || "default",
                healCapPct: base.healCapPct ?? null,
                icon: base.icon,
                rarity: rarity.key,
                rarityMul: rarity.mul,
                baseStats,
                affixStats,
                uniqueStats: [],
                prefix,
                suffix,
                currentCapacity: 0
            };
            potion.name = buildDxItemName(potion.name, Game.floor || 1);
            return potion;
        };

        const buildBossItem = (base, floor, index, options = {}) => {
            const totals = getTotalStats();
            const eliteRank = Game.enemy?.elite?.rank || 0;
            const rarity = options.forceLegendary
                ? (RarityDefs.find((def) => def.key === "legendary") || RarityDefs[RarityDefs.length - 1])
                : rollRarity(totals.rareFind, eliteRank);
            const affixRate = totals.affixFind + eliteRank * 8;
            const affixChance = Math.min(100, 2 + affixRate);
            const prefixRank = Math.random() * 100 < affixChance ? rollAffixRank(affixRate, eliteRank) : 0;
            const suffixRank = Math.random() * 100 < affixChance ? rollAffixRank(affixRate, eliteRank) : 0;
            const prefix = prefixRank ? rollAffix(PrefixAffixes, prefixRank) : null;
            const suffix = suffixRank ? rollAffix(SuffixAffixes, suffixRank) : null;
            const prefixStars = prefix ? "â˜†".repeat(prefix.rank) : "";
            const suffixStars = suffix ? "â˜†".repeat(suffix.rank) : "";
            const originFloor = Math.max(1, floor || 1);
            const baseStats = buildEquipmentBaseStats(base.stats, originFloor, rarity.mul, base.type);
            const affixStats = [
                ...(prefix ? prefix.stats.map((stat) => ({ ...stat, source: "prefix" })) : []),
                ...(suffix ? suffix.stats.map((stat) => ({ ...stat, source: "suffix" })) : [])
            ];
            const uniqueStats = (base.uniqueStats || []).map((stat) => ({ ...stat }));
            const displayName = base.name;
            const effectBaseName = base.originalName || base.name;
            const effect = BossUniqueEffects[effectBaseName];
            let resolvedEffect = effect;
            if (effect?.type === "levelRatioBoost" && effect.randomize) {
                const stepMin = effect.stepRange?.[0] ?? 2;
                const stepMax = effect.stepRange?.[1] ?? stepMin;
                const gainMin = effect.gainRange?.[0] ?? 1;
                const gainMax = effect.gainRange?.[1] ?? gainMin;
                const step = Math.floor(Math.random() * (stepMax - stepMin + 1)) + stepMin;
                const gain = Math.floor(Math.random() * (gainMax - gainMin + 1)) + gainMin;
                const statKeys = ["str", "vit", "int", "dex", "luk"];
                const statKey = statKeys.includes(effect.stat) ? effect.stat : statKeys[Math.floor(Math.random() * statKeys.length)];
                const statLabel = StatLabels[statKey] || statKey;
                resolvedEffect = {
                    ...effect,
                    stat: statKey,
                    step,
                    gain,
                    label: `${displayName}ï¼š${statLabel}æˆé•· Lv${step}ã”ã¨ã«+${gain}`
                };
                delete resolvedEffect.randomize;
                delete resolvedEffect.stepRange;
                delete resolvedEffect.gainRange;
            }
            if (resolvedEffect) {
                uniqueStats.push({ key: "bossUniqueEffect", value: 0, effect: resolvedEffect });
            }
            const item = {
                name: `${prefixStars}${prefix ? prefix.name : ""}${displayName}${suffix ? suffix.name : ""}${suffixStars}`,
                type: base.type,
                rarity: rarity.key,
                rarityMul: rarity.mul,
                baseStats,
                affixStats,
                uniqueStats,
                prefix,
                suffix,
                isBossDrop: true,
                originFloor
            };
            item.name = buildDxItemName(item.name, originFloor);
            if (item.type !== "potion") {
                item.enhancementLevel = 0;
                item.isBroken = false;
            }
            return item;
        };

        const buildRoadLegendaryItem = (base) => {
            const totals = getTotalStats();
            const eliteRank = Game.enemy?.elite?.rank || 0;
            const rarity = (RarityDefs.find((def) => def.key === "legendary") || RarityDefs[RarityDefs.length - 1]);
            const affixRate = totals.affixFind + eliteRank * 8;
            const affixChance = Math.min(100, 2 + affixRate);
            const prefixRank = Math.random() * 100 < affixChance ? rollAffixRank(affixRate, eliteRank) : 0;
            const suffixRank = Math.random() * 100 < affixChance ? rollAffixRank(affixRate, eliteRank) : 0;
            const prefix = prefixRank ? rollAffix(PrefixAffixes, prefixRank) : null;
            const suffix = suffixRank ? rollAffix(SuffixAffixes, suffixRank) : null;
            const prefixStars = prefix ? "â˜†".repeat(prefix.rank) : "";
            const suffixStars = suffix ? "â˜†".repeat(suffix.rank) : "";
            const originFloor = Math.max(1, Game.floor || 1);
            const baseStats = buildEquipmentBaseStats(base.stats, originFloor, rarity.mul, base.type);
            const affixStats = [
                ...(prefix ? prefix.stats.map((stat) => ({ ...stat, source: "prefix" })) : []),
                ...(suffix ? suffix.stats.map((stat) => ({ ...stat, source: "suffix" })) : [])
            ];
            const uniqueStats = (base.uniqueStats || []).map((stat) => ({ ...stat }));
            const effect = RoadLegendaryUniqueEffects[base.name];
            if (effect) {
                uniqueStats.push({ key: "bossUniqueEffect", value: 0, effect });
            }
            const item = {
                name: `${prefixStars}${prefix ? prefix.name : ""}${base.name}${suffix ? suffix.name : ""}${suffixStars}`,
                type: base.type,
                rarity: rarity.key,
                rarityMul: rarity.mul,
                baseStats,
                affixStats,
                uniqueStats,
                prefix,
                suffix,
                isRoadLegendary: true,
                originFloor
            };
            item.name = buildDxItemName(item.name, originFloor);
            if (item.type !== "potion") {
                item.enhancementLevel = 0;
                item.isBroken = false;
            }
            return item;
        };

        const normalizeEquipmentBaseStats = (item, floorFallback) => {
            if (!item || item.type === "potion") return;
            const statKeys = (item.baseStats || []).map((stat) => ({ key: stat.key }));
            if (statKeys.length === 0) return;
            const rarityMul = item.rarityMul ?? (RarityDefs.find((def) => def.key === item.rarity)?.mul ?? 1);
            const fallbackFloor = Math.max(1, floorFallback ?? Game.floor ?? 1);
            const originFloor = Math.max(1, item.originFloor ?? fallbackFloor);
            item.originFloor = originFloor;
            item.baseStats = buildEquipmentBaseStats(statKeys, originFloor, rarityMul, item.type);
        };

        const normalizeEquipmentBaseStatsForPlayer = () => {
            if (!Game.player) return;
            const fallbackFloor = Math.max(1, Game.floor || 1);
            const inventory = Game.player.inventory || [];
            inventory.forEach((item) => normalizeEquipmentBaseStats(item, fallbackFloor));
            [
                Game.player.weapon,
                Game.player.armor,
                Game.player.head,
                Game.player.hands,
                Game.player.feet,
                Game.player.accessory1,
                Game.player.accessory2
            ].forEach((item) => normalizeEquipmentBaseStats(item, fallbackFloor));
        };

        const buildRoadLegendaryLoot = () => {
            const table = getRoadLegendaryTable(Game.floor);
            if (!table || !table.items || table.items.length === 0) return null;
            const base = pickRandom(table.items);
            return buildRoadLegendaryItem(base);
        };

        const MAX_WEAPON_ENHANCEMENT = 21;
        const WeaponEnhancementRates = {
            0: 1,
            1: 1,
            2: 1,
            3: 1,
            4: 0.9,
            5: 0.8,
            6: 0.6,
            7: 0.8,
            8: 0.9,
            9: 0.5,
            10: 0.259,
            11: 0.18,
            12: 0.127,
            13: 0.083,
            14: 0.056,
            15: 0.031,
            16: 0.017,
            17: 0.003,
            18: 0.002,
            19: 0.001,
            20: 0.0001
        };

        const EnhancementTargetTypes = new Set([
            "weapon",
            "armor",
            "head",
            "hands",
            "feet",
            "accessory"
        ]);

        const isEnhanceableItem = (item) => Boolean(item && EnhancementTargetTypes.has(item.type));

        const normalizeWeaponEnhancement = (item) => {
            if (!isEnhanceableItem(item)) return;
            if (!Number.isFinite(item.enhancementLevel)) item.enhancementLevel = 0;
            if (item.isBroken === undefined || item.isBroken === null) item.isBroken = false;
        };

        const getWeaponEnhancementLevel = (item) => {
            if (!isEnhanceableItem(item)) return 0;
            return Number.isFinite(item.enhancementLevel) ? item.enhancementLevel : 0;
        };

        const getWeaponEnhancementRate = (level) => WeaponEnhancementRates[level] ?? 0;

        const formatEnhancementRate = (rate) => {
            const percent = rate * 100;
            if (percent >= 1) return percent.toFixed(1);
            if (percent >= 0.1) return percent.toFixed(1);
            return percent.toFixed(2);
        };

        const getWeaponEnhancementCost = (item) => {
            const level = getWeaponEnhancementLevel(item);
            const rarityMul = item?.rarityMul ?? 1;
            const base = 220;
            const scaled = base * (level + 1) * (1 + level * 0.35) * rarityMul;
            return Math.max(1, Math.floor(scaled));
        };

        const getWeaponEnhancementColorClass = (level) => {
            if (level >= 20) return "enhance-white";
            if (level >= 17) return "enhance-gold";
            if (level >= 15) return "enhance-orange";
            if (level >= 13) return "enhance-pink";
            if (level >= 9) return "enhance-blue";
            if (level >= 7) return "enhance-yellow";
            if (level >= 1) return "enhance-green";
            return "";
        };

        const getWeaponEnhancementLabelHtml = (item) => {
            const level = getWeaponEnhancementLevel(item);
            if (!level) return "";
            const colorClass = getWeaponEnhancementColorClass(level);
            return `<span class="enhance-label ${colorClass}">+${level}</span>`;
        };

        const getWeaponBrokenLabelHtml = (item) => {
            if (!isEnhanceableItem(item) || !item.isBroken) return "";
            return `<span class="enhance-broken">ç ´æ</span>`;
        };

        const getEnhancementPreviewStat = (item) => {
            if (!isEnhanceableItem(item)) return null;
            return { value: 3 };
        };

        const getEnhancedBaseStats = (item) => {
            if (!item) return [];
            const baseStats = (item.baseStats || []).map((stat) => ({ ...stat }));
            if (!isEnhanceableItem(item)) return baseStats;
            const level = getWeaponEnhancementLevel(item);
            if (level <= 0 || item.isBroken) return baseStats;
            const multiplier = 1 + level * 0.03;
            return baseStats.map((stat) => ({
                ...stat,
                value: Math.max(1, Math.floor(stat.value * multiplier))
            }));
        };

        const getEnhancementRatePercent = (item) => {
            if (!isEnhanceableItem(item)) return 0;
            const level = getWeaponEnhancementLevel(item);
            if (level <= 0 || item.isBroken) return 0;
            return Math.round(level * 3);
        };

        const getItemStats = (item) => {
            if (!item) return [];
            return [
                ...getEnhancedBaseStats(item),
                ...(item.affixStats || []),
                ...(item.uniqueStats || [])
            ];
        };

        const sumStats = (stats) => {
            return stats.reduce((acc, stat) => {
                acc[stat.key] = (acc[stat.key] || 0) + stat.value;
                return acc;
            }, {});
        };

        const getItemStatValue = (item, key) => {
            return getItemStats(item).filter((stat) => stat.key === key).reduce((sum, stat) => sum + stat.value, 0);
        };

        const getSellPrice = (item) => {
            if (!item) return 0;
            const base = SellBasePrices[item.rarity] ?? 0;
            const prefixMul = AffixRankMultipliers[item.prefix?.rank] ?? 1;
            const suffixMul = AffixRankMultipliers[item.suffix?.rank] ?? 1;
            return Math.floor(base * prefixMul * suffixMul);
        };

        const formatGold = (value) => Number(value ?? 0).toLocaleString('ja-JP');

        const getPotionDerived = (potion) => {
            if (!potion) return null;
            const totals = sumStats(getItemStats(potion));
            const maxCapacity = Math.max(1, totals.potionCapacity || 0);
            const cost = Math.max(1, (totals.potionCost || 0) - (totals.potionCostReduction || 0));
            return {
                maxCapacity,
                cost,
                healFlat: totals.potionHealFlat || 0,
                healPct: totals.potionHealPct || 0,
                chargeOnKill: totals.potionChargeOnKill || 0,
                cleanse: totals.potionCleanse || 0,
                autoRegen: totals.potionAutoRegen || 0,
                barrier: totals.potionBarrier || 0,
                resonance: totals.potionResonance || 0,
                nextHitBoost: totals.potionNextHitBoost || 0,
                leechBoost: totals.potionLeechBoost || 0,
                reflectGuard: totals.potionReflectGuard || 0,
                skillMpCut: totals.potionSkillMpCut || 0
            };
        };

        const syncPotionCapacity = (potion) => {
            if (!potion) return null;
            const derived = getPotionDerived(potion);
            if (potion.currentCapacity === undefined || potion.currentCapacity === null) {
                potion.currentCapacity = derived.maxCapacity;
            }
            potion.currentCapacity = Math.min(potion.currentCapacity, derived.maxCapacity);
            return derived;
        };

        const NegativeStatusEffectIds = new Set([
            "poison",
            "bleed",
            "weaken",
            "vulnerable",
            "attackDown",
            "defenseDown",
            "freeze",
            "blind",
            "silence",
            "taunt"
        ]);
        const BossRushRandomStatusPool = [
            "poison",
            "bleed",
            "weaken",
            "vulnerable",
            "attackDown",
            "defenseDown",
            "blind",
            "silence"
        ];

        const getEquipmentStats = () => {
            const weaponStats = getItemStats(Game.player.weapon);
            const armorStats = getItemStats(Game.player.armor);
            const headStats = getItemStats(Game.player.head);
            const handsStats = getItemStats(Game.player.hands);
            const feetStats = getItemStats(Game.player.feet);
            const accessory1Stats = getItemStats(Game.player.accessory1);
            const accessory2Stats = getItemStats(Game.player.accessory2);
            return sumStats([
                ...weaponStats,
                ...armorStats,
                ...headStats,
                ...handsStats,
                ...feetStats,
                ...accessory1Stats,
                ...accessory2Stats
            ]);
        };

        const getEquippedBossEffects = () => ([
            Game.player.weapon,
            Game.player.armor,
            Game.player.head,
            Game.player.hands,
            Game.player.feet,
            Game.player.accessory1,
            Game.player.accessory2
        ].flatMap((item) => (item?.uniqueStats || [])
            .filter((stat) => stat.key === "bossUniqueEffect" && stat.effect)
            .map((stat) => stat.effect)
        ));

        const getBossUniqueEffectByType = (type) => (
            getEquippedBossEffects().find((effect) => effect.type === type || effect.extraType === type) || null
        );

        const hasBossUniqueEffect = (type) => Boolean(getBossUniqueEffectByType(type));

        const resetBossUniqueCombatState = () => {
            if (!Game.player.bossUniqueState) {
                Game.player.bossUniqueState = {};
            }
            Game.player.bossUniqueState.martyrLight = 0;
            Game.player.bossUniqueState.damageReturnCharge = 0;
            Game.player.bossUniqueState.damageBufferCharge = 0;
            Game.player.bossUniqueState.guardianReturnCharge = 0;
            Game.player.bossUniqueState.defenseLayers = 0;
            Game.player.bossUniqueState.ironWallUsed = false;
            Game.player.bossUniqueState.shadowFirstStrikeUsed = false;
            Game.player.bossUniqueState.lastSkill = null;
        };

        const applyBossUniqueStatBonuses = (totals) => {
            const updated = { ...totals };
            const effects = getEquippedBossEffects();
            effects.forEach((effect) => {
                if (effect.type === "statBonus") {
                    (effect.stats || []).forEach((stat) => {
                        updated[stat.key] = (updated[stat.key] || 0) + stat.value;
                    });
                }
                if (effect.type === "statMultiplier") {
                    const multiplierKey = `${effect.stat}Multiplier`;
                    updated[multiplierKey] = (updated[multiplierKey] || 0) + effect.value;
                }
                if (effect.type === "levelRatioBoost") {
                    const step = effect.step || 1;
                    const gain = effect.gain || 0;
                    const bonus = Math.floor(Game.player.level / step) * gain;
                    if (bonus > 0) {
                        if (effect.stat) {
                            updated[effect.stat] = (updated[effect.stat] || 0) + bonus;
                        } else {
                            updated.str += bonus;
                            updated.vit += bonus;
                            updated.int += bonus;
                            updated.dex += bonus;
                            updated.luk += bonus;
                        }
                    }
                }
            });
            return updated;
        };

        const addMilestoneStats = (total, stats) => {
            if (!stats) return;
            Object.entries(stats).forEach(([key, value]) => {
                total[key] = (total[key] || 0) + value;
            });
        };

        const getPassiveMilestoneStats = () => {
            const total = {};
            JobKeys.forEach((job) => {
                const bonuses = PassiveMilestoneBonuses[job] || {};
                const levels = Game.player.skills[job]?.passive || [];
                Object.keys(bonuses).forEach((idx) => {
                    const level = levels[idx] || 0;
                    if (level <= 0) return;
                    const milestone = bonuses[idx];
                    SkillMilestoneLevels.forEach((threshold) => {
                        const milestoneKey = PassiveMilestoneKeyMap[threshold] ?? threshold;
                        if (level >= threshold && milestone[milestoneKey]) {
                            addMilestoneStats(total, milestone[milestoneKey].stats);
                        }
                    });
                });
            });
            return total;
        };

        const getTotalStats = () => {
            const equip = getEquipmentStats();
            const milestone = getPassiveMilestoneStats();
            const totals = {
                str: Game.player.str + (Game.player.levelStr || 0) + (equip.str || 0) + (milestone.str || 0),
                vit: Game.player.vit + (Game.player.levelVit || 0) + (equip.vit || 0) + (milestone.vit || 0),
                int: Game.player.int + (Game.player.levelInt || 0) + (equip.int || 0) + (milestone.int || 0),
                dex: Game.player.dex + (Game.player.levelDex || 0) + (equip.dex || 0) + (milestone.dex || 0),
                luk: Game.player.luk + (equip.luk || 0) + (milestone.luk || 0),
                maxHp: Game.player.maxHp + (equip.maxHp || 0) + (milestone.maxHp || 0),
                maxMp: Game.player.maxMp + (equip.maxMp || 0) + (milestone.maxMp || 0),
                maxHpFlat: Game.player.maxHpFlat + (equip.maxHpFlat || 0) + (milestone.maxHpFlat || 0),
                maxMpFlat: Game.player.maxMpFlat + (equip.maxMpFlat || 0) + (milestone.maxMpFlat || 0),
                attackFlat: Game.player.attackFlat + (equip.attackFlat || 0) + (milestone.attackFlat || 0),
                defenseFlat: Game.player.defenseFlat + (equip.defenseFlat || 0) + (milestone.defenseFlat || 0),
                hpRegen: Game.player.hpRegen + (equip.hpRegen || 0) + (milestone.hpRegen || 0),
                mpRegen: Game.player.mpRegen + (equip.mpRegen || 0) + (milestone.mpRegen || 0),
                goldBoost: Game.player.goldBoost + (equip.goldBoost || 0) + (milestone.goldBoost || 0),
                critRate: Game.player.critRate + (equip.critRate || 0) + (milestone.critRate || 0),
                evasionRate: Game.player.evasionRate + (equip.evasionRate || 0) + (milestone.evasionRate || 0),
                leechRate: Game.player.leechRate + (equip.leechRate || 0) + (milestone.leechRate || 0),
                expBoost: Game.player.expBoost + (equip.expBoost || 0) + (milestone.expBoost || 0),
                mPen: Game.player.mPen + (equip.mPen || 0) + (milestone.mPen || 0),
                luck: Game.player.luck + (equip.luck || 0) + (milestone.luck || 0),
                accuracy: Game.player.accuracy + (equip.accuracy || 0) + (milestone.accuracy || 0),
                critDamage: Game.player.critDamage + (equip.critDamage || 0) + (milestone.critDamage || 0),
                damageBoost: Game.player.damageBoost + (equip.damageBoost || 0) + (milestone.damageBoost || 0),
                damageReduction: Game.player.damageReduction + (equip.damageReduction || 0) + (milestone.damageReduction || 0),
                rareFind: Game.player.rareFind + (equip.rareFind || 0) + (milestone.rareFind || 0),
                affixFind: Game.player.affixFind + (equip.affixFind || 0) + (milestone.affixFind || 0),
                eliteEncounter: Game.player.eliteEncounter + (equip.eliteEncounter || 0) + (milestone.eliteEncounter || 0),
                skillPowerBoost: Game.player.skillPowerBoost + (equip.skillPowerBoost || 0),
                statusEffectStackBonus: Game.player.statusEffectStackBonus + (equip.statusEffectStackBonus || 0),
                statusEffectTurnBonus: Game.player.statusEffectTurnBonus + (equip.statusEffectTurnBonus || 0),
                poisonMaxStacksBonus: Game.player.poisonMaxStacksBonus + (equip.poisonMaxStacksBonus || 0),
                poisonMinPctBonus: Game.player.poisonMinPctBonus + (equip.poisonMinPctBonus || 0),
                skillMpDiscount: Game.player.skillMpDiscount + (equip.skillMpDiscount || 0),
                strMultiplier: Game.player.strMultiplier + (equip.strMultiplier || 0),
                intMultiplier: Game.player.intMultiplier + (equip.intMultiplier || 0),
                vitMultiplier: Game.player.vitMultiplier + (equip.vitMultiplier || 0),
                dexMultiplier: Game.player.dexMultiplier + (equip.dexMultiplier || 0),
                lukMultiplier: Game.player.lukMultiplier + (equip.lukMultiplier || 0)
            };
            const adjusted = applyBossUniqueStatBonuses(totals);
            adjusted.damageReduction = Math.min(80, adjusted.damageReduction);
            return adjusted;
        };

        function getStatusEffect(target, effectId) {
            if (!target || !Array.isArray(target.statusEffects)) return null;
            return target.statusEffects.find(effect => effect.id === effectId) || null;
        }

        function removeStatusEffect(target, effectId) {
            if (!target || !Array.isArray(target.statusEffects)) return;
            target.statusEffects = target.statusEffects.filter(effect => effect.id !== effectId);
        }

        function getStatusModifiers(target) {
            const effects = Array.isArray(target?.statusEffects) ? target.statusEffects : [];
            const mods = {
                atkMul: 1,
                defMul: 1,
                accuracyMul: 1,
                critMul: 1,
                evasionMul: 1,
                damageDoneMul: 1,
                damageTakenMul: 1,
                reflectPct: 0,
                silence: false,
                frozen: false
            };
            effects.forEach(effect => {
                const def = StatusDefs[effect.id];
                if (!def) return;
                const stacks = Math.max(1, effect.stacks || 1);
                if (def.effectType === 'attackUp') {
                    mods.atkMul += 0.1 * stacks;
                }
                if (def.effectType === 'attackDown') {
                    mods.atkMul -= 0.1 * stacks;
                }
                if (def.effectType === 'defenseUp') {
                    mods.defMul += 0.12 * stacks;
                    mods.damageTakenMul *= Math.max(0.2, 1 - 0.08 * stacks);
                }
                if (def.effectType === 'defenseDown') {
                    mods.defMul -= 0.12 * stacks;
                    mods.damageTakenMul *= 1 + 0.08 * stacks;
                }
                if (def.effectType === 'buff') {
                    mods.damageDoneMul *= 1 + 0.1 * stacks;
                }
                if (def.effectType === 'weaken') {
                    mods.damageDoneMul *= Math.max(0.2, 1 - 0.1 * stacks);
                }
                if (def.effectType === 'vulnerable') {
                    mods.damageTakenMul *= 1 + 0.15 * stacks;
                }
                if (def.effectType === 'blind') {
                    mods.accuracyMul *= Math.max(0.2, 1 - 0.15 * stacks);
                    mods.critMul *= Math.max(0.2, 1 - 0.2 * stacks);
                }
                if (def.effectType === 'haste') {
                    mods.accuracyMul *= 1 + 0.08 * stacks;
                    mods.evasionMul *= 1 + 0.1 * stacks;
                }
                if (def.effectType === 'silence') {
                    mods.silence = true;
                }
                if (def.effectType === 'freeze') {
                    mods.frozen = true;
                }
                if (def.effectType === 'reflect') {
                    mods.reflectPct += 0.08 * stacks;
                }
                if (def.effectType === 'taunt') {
                    mods.damageTakenMul *= 1 + 0.05 * stacks;
                    mods.evasionMul *= Math.max(0.2, 1 - 0.05 * stacks);
                }
            });
            mods.atkMul = Math.max(0.1, mods.atkMul);
            mods.defMul = Math.max(0.1, mods.defMul);
            mods.accuracyMul = Math.max(0.2, mods.accuracyMul);
            mods.critMul = Math.max(0.2, mods.critMul);
            mods.evasionMul = Math.max(0.2, mods.evasionMul);
            mods.damageDoneMul = Math.max(0.2, mods.damageDoneMul);
            mods.damageTakenMul = Math.max(0.2, mods.damageTakenMul);
            mods.reflectPct = Math.min(0.6, mods.reflectPct);
            return mods;
        }

        const checkBossUniqueCondition = (condition, context) => {
            if (!condition) return true;
            const { player, enemy, derived } = context;
            if (condition.type === "enemyStatus") {
                return Boolean(getStatusEffect(enemy, condition.status));
            }
            if (condition.type === "playerHpBelow") {
                return player.hp <= derived.maxHp * condition.threshold;
            }
            if (condition.type === "playerHpAbove") {
                return player.hp >= derived.maxHp * condition.threshold;
            }
            if (condition.type === "playerMpBelow") {
                return player.mp <= derived.maxMp * condition.threshold;
            }
            if (condition.type === "playerMpZero") {
                return player.mp <= 0;
            }
            if (condition.type === "enemyHpAbove") {
                return enemy.hp >= enemy.maxHp * condition.threshold;
            }
            if (condition.type === "enemyHpBelow") {
                return enemy.hp <= enemy.maxHp * condition.threshold;
            }
            return false;
        };

        const getBossUniqueCombatModifiers = (context) => {
            const mods = {
                damageMultiplier: 1,
                accuracyBonus: 0,
                critRateBonus: 0,
                bonusHits: 0,
                bonusHitMultiplier: 1,
                damageTakenMultiplier: 1,
                logs: []
            };
            const effects = getEquippedBossEffects();
            effects.forEach((effect) => {
                if (!checkBossUniqueCondition(effect.condition, context)) return;
                if (effect.type === "damageBoost") {
                    mods.damageMultiplier *= 1 + effect.value / 100;
                }
                if (effect.type === "riskBoost") {
                    mods.damageMultiplier *= 1 + effect.value / 100;
                    mods.damageTakenMultiplier *= 1 + (effect.penalty || 0) / 100;
                }
                if (effect.type === "bonusHitsChance") {
                    const chance = effect.chance ?? 0;
                    if (Math.random() * 100 < chance) {
                        mods.bonusHits += effect.hits || 1;
                        mods.bonusHitMultiplier = effect.hitMultiplier || mods.bonusHitMultiplier;
                        mods.logs.push(effect.label);
                    }
                }
                if (effect.type === "extraTurnChance") {
                    const chance = effect.chance ?? 0;
                    if (Math.random() * 100 < chance) {
                        mods.bonusHits += context.baseHits || 0;
                        mods.bonusHitMultiplier = effect.hitMultiplier || mods.bonusHitMultiplier;
                        mods.logs.push(effect.label);
                    }
                }
                if (effect.type === "accuracyBoost") {
                    mods.accuracyBonus += effect.value || 0;
                }
                if (effect.type === "critBoost") {
                    mods.critRateBonus += effect.value || 0;
                }
                if (effect.type === "damageTakenReduction") {
                    mods.damageTakenMultiplier *= Math.max(0, 1 - (effect.value || 0) / 100);
                }
            });
            return mods;
        };

        const getBossUniqueDamageTakenMultiplier = (context) => (
            getBossUniqueCombatModifiers(context).damageTakenMultiplier
        );

        const CustomStatRenderers = {
            potionCapacity: (stat) => `å®¹é‡ ${stat.source ? "+" : ""}${stat.value}`,
            potionCost: (stat) => `æ¶ˆè²»é‡ ${stat.value}`,
            potionCostReduction: (stat) => `æ¶ˆè²»é‡ -${stat.value}`,
            potionHealFlat: (stat) => `å›å¾©é‡ ${stat.source ? "+" : ""}${stat.value}`,
            potionHealPct: (stat) => `å›å¾©é‡ ${stat.source ? "+" : ""}${stat.value}%`,
            potionChargeOnKill: (stat) => `è¨ä¼å›å¾© ${stat.source ? "+" : ""}${stat.value}`,
            potionCleanse: (stat) => `çŠ¶æ…‹ç•°å¸¸å›å¾© ${stat.source ? "+" : ""}${stat.value}`,
            potionAutoRegen: (stat) => `å†ç”Ÿä»˜ä¸ ${stat.source ? "+" : ""}${stat.value}ã‚¹ã‚¿ãƒƒã‚¯`,
            potionBarrier: (stat) => `ãƒãƒªã‚¢ä»˜ä¸ ${stat.source ? "+" : ""}${stat.value}`,
            potionResonance: () => "å…±é³´ä»˜ä¸",
            potionNextHitBoost: (stat) => `æ¬¡æ’ƒå¼·åŒ– +${stat.value}%`,
            potionLeechBoost: (stat) => `å¸åå¼·åŒ– +${stat.value}%`,
            potionReflectGuard: (stat) => `åå°„ç„¡åŠ¹ +${stat.value}å›`,
            potionSkillMpCut: (stat) => `ã‚¹ã‚­ãƒ«MPè»½æ¸› +${stat.value}%`,
            skillPowerBoost: (stat) => `ã‚¹ã‚­ãƒ«å¨åŠ› +${stat.value}%`,
            statusEffectStackBonus: (stat) => `çŠ¶æ…‹ç•°å¸¸ä»˜ä¸ã‚¹ã‚¿ãƒƒã‚¯ +${stat.value}`,
            statusEffectTurnBonus: (stat) => `çŠ¶æ…‹ç•°å¸¸ä»˜ä¸ã‚¿ãƒ¼ãƒ³ +${stat.value}`,
            poisonMaxStacksBonus: (stat) => `æ¯’ä¸Šé™ã‚¹ã‚¿ãƒƒã‚¯ +${stat.value}`,
            poisonMinPctBonus: (stat) => `æ¯’æœ€ä½ä¿è¨¼ +${stat.value}%`,
            skillMpDiscount: (stat) => `ã‚¹ã‚­ãƒ«MPæ¶ˆè²» -${stat.value}%`,
            strMultiplier: (stat) => `STRå€ç‡ +${stat.value}%`,
            vitMultiplier: (stat) => `VITå€ç‡ +${stat.value}%`,
            intMultiplier: (stat) => `INTå€ç‡ +${stat.value}%`,
            dexMultiplier: (stat) => `DEXå€ç‡ +${stat.value}%`,
            lukMultiplier: (stat) => `LUKå€ç‡ +${stat.value}%`,
            bossUniqueEffect: (stat) => stat.effect?.label || "å›ºæœ‰åŠ¹æœ"
        };

        const renderStatLines = (stats) => {
            return stats.map((stat) => {
                const custom = CustomStatRenderers[stat.key];
                if (custom) return custom(stat);
                const suffix = PercentStats.has(stat.key) ? "%" : "";
                return `${StatLabels[stat.key] || stat.key} +${stat.value}${suffix}`;
            });
        };

        const renderItemStatsHtml = (item) => {
            const stats = renderStatLines(getItemStats(item));
            return stats.map((line) => `<div class="text-[10px] text-slate-400 font-bold">${line}</div>`).join('');
        };

        const renderStatGroupHtml = (title, icon, lines) => {
            if (!lines.length) return '';
            const items = lines.map((line) => `<div class="text-[10px] text-slate-400 font-bold">${line}</div>`).join('');
            return `
                <div class="item-stat-group">
                    <div class="item-stat-group-title"><i class="fas ${icon}"></i>${title}</div>
                    <div class="space-y-0.5">${items}</div>
                </div>
            `;
        };

        const renderItemStatsGroupedHtml = (item) => {
            if (!item) return '';
            const isPotion = item.type === "potion";
            const baseStats = isPotion
                ? (() => {
                    const totals = sumStats(getItemStats(item));
                    const derived = getPotionDerived(item);
                    const valueMap = {
                        potionCapacity: derived?.maxCapacity ?? totals.potionCapacity ?? 0,
                        potionCost: derived?.cost ?? totals.potionCost ?? 0,
                        potionHealFlat: derived?.healFlat ?? totals.potionHealFlat ?? 0,
                        potionHealPct: derived?.healPct ?? totals.potionHealPct ?? 0,
                        potionChargeOnKill: derived?.chargeOnKill ?? totals.potionChargeOnKill ?? 0,
                        potionCleanse: derived?.cleanse ?? totals.potionCleanse ?? 0,
                        potionAutoRegen: derived?.autoRegen ?? totals.potionAutoRegen ?? 0,
                        potionBarrier: derived?.barrier ?? totals.potionBarrier ?? 0
                    };
                    return (item.baseStats || []).map((stat) => ({
                        ...stat,
                        value: valueMap[stat.key] ?? totals[stat.key] ?? stat.value
                    }));
                })()
                : getEnhancedBaseStats(item);
            const baseLines = renderStatLines(baseStats);
            const prefixLines = renderStatLines((item.affixStats || []).filter((stat) => stat.source === "prefix"));
            const suffixLines = renderStatLines((item.affixStats || []).filter((stat) => stat.source === "suffix"));
            const uniqueLines = renderStatLines(item.uniqueStats || []);
            const enhancementRate = getEnhancementRatePercent(item);
            const baseLabel = isPotion
                ? "åŸºç¤(Affixåæ˜ æ¸ˆã¿)"
                : `åŸºç¤${enhancementRate > 0 ? ` (å¼·åŒ–å€¤${enhancementRate}%)` : ""}`;
            const groups = [
                renderStatGroupHtml(baseLabel, "fa-layer-group", baseLines),
                renderStatGroupHtml("Prefix", "fa-arrow-up-wide-short", prefixLines),
                renderStatGroupHtml("Suffix", "fa-arrow-down-wide-short", suffixLines)
            ].filter(Boolean);
            const groupHtml = groups.length ? `<div class="item-stat-categories">${groups.join('')}</div>` : '';
            const uniqueHtml = uniqueLines.length
                ? `
                    <div class="item-unique-block">
                        <div class="item-stat-group-title text-amber-600"><i class="fas fa-crown"></i>å›ºæœ‰åŠ¹æœ</div>
                        <div class="space-y-0.5">
                            ${uniqueLines.map((line) => `<div class="text-[10px] text-amber-700 font-bold">${line}</div>`).join('')}
                        </div>
                    </div>
                `
                : '';
            return `${groupHtml}${uniqueHtml}`;
        };

        const updateEquipNameDisplay = (elementId, item) => {
            const el = document.getElementById(elementId);
            if (!el) return;
            const name = item?.name || "ãªã—";
            const rarity = item?.rarity || "normal";
            const isLong = name.length >= 16;
            if (item) normalizeWeaponEnhancement(item);
            const enhancementHtml = getWeaponEnhancementLabelHtml(item);
            const brokenHtml = getWeaponBrokenLabelHtml(item);
            el.innerHTML = `${name}${enhancementHtml ? ` ${enhancementHtml}` : ""}${brokenHtml ? ` ${brokenHtml}` : ""}`.trim();
            el.className = `font-black text-[11px] leading-tight whitespace-normal break-words rarity-${rarity} ${isLong ? "text-[10px]" : ""}`.trim();
        };

        const createStarterPotion = (name) => {
            const base = PotionBases.find((potion) => potion.name === name);
            if (!base) return null;
            const potion = buildPotion(base, { forceRarityKey: "normal", noAffix: true });
            const derived = syncPotionCapacity(potion);
            potion.currentCapacity = derived.maxCapacity;
            return potion;
        };

        const initializeStarterPotions = () => {
            if (!Game.player.potion1) {
                Game.player.potion1 = createStarterPotion("HPå›å¾©è–¬(å°)");
            }
            if (!Game.player.potion2) {
                Game.player.potion2 = createStarterPotion("MPå›å¾©è–¬(å°)");
            }
            syncPotionCapacity(Game.player.potion1);
            syncPotionCapacity(Game.player.potion2);
        };

        const ensureWarpState = () => {
            if (!Number.isFinite(Game.maxFloor)) {
                Game.maxFloor = Game.floor || 1;
            }
            Game.maxFloor = Math.min(MaxFloorLimit, Math.max(1, Game.maxFloor));
            if (!Number.isFinite(Game.floor)) {
                Game.floor = 1;
            }
            Game.floor = Math.min(MaxFloorLimit, Math.max(1, Game.floor));
            if (!Number.isFinite(Game.maxBossRushFloor)) {
                Game.maxBossRushFloor = Game.isBossRush ? (Game.floor || BossRushStartFloor) : 0;
            }
            if (typeof Game.endMessageShown !== 'boolean') {
                Game.endMessageShown = false;
            }
            if (!Array.isArray(Game.defeatedBossFloors)) {
                Game.defeatedBossFloors = [];
            }
            if (!Array.isArray(Game.defeatedBossRushMilestones)) {
                Game.defeatedBossRushMilestones = [];
            }
            if (!Game.isBossRush) {
                Game.maxFloor = Math.max(1, Game.maxFloor, Game.floor);
            }
            if (Game.isBossRush) {
                Game.maxBossRushFloor = Math.max(Game.maxBossRushFloor, Game.floor);
            }
        };

        const getWarpMaxFloor = () => {
            ensureWarpState();
            return Game.maxFloor;
        };

        const normalizeWarpFloor = (value, options = {}) => {
            const isBossRush = options.isBossRush ?? false;
            const maxFloor = isBossRush ? Math.max(BossRushStartFloor, Game.maxBossRushFloor || BossRushStartFloor) : getWarpMaxFloor();
            const upperLimit = maxFloor;
            const parsed = Number.parseInt(value, 10);
            if (Number.isNaN(parsed)) return null;
            const lowerLimit = isBossRush ? BossRushStartFloor : 1;
            return Math.min(upperLimit, Math.max(lowerLimit, parsed));
        };

        const renderWarpBossButtons = () => {
            const container = document.getElementById('warp-boss-buttons');
            const empty = document.getElementById('warp-boss-empty');
            if (!container) return;
            container.innerHTML = '';
            const floors = (Game.defeatedBossFloors || []).filter((floor) => BossDefs[floor]).sort((a, b) => a - b);
            if (floors.length === 0) {
                if (empty) empty.classList.remove('hidden');
                return;
            }
            if (empty) empty.classList.add('hidden');
            floors.forEach((floor) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'bg-slate-100 text-slate-600 text-[10px] font-black px-2 py-2 rounded-xl flex items-center justify-center gap-1 hover:bg-slate-200 transition';
                button.innerHTML = `<i class="fas fa-crown"></i> ${floor}F`;
                button.addEventListener('click', () => performWarp(floor));
                container.appendChild(button);
            });
        };

        const renderWarpBossRushButtons = () => {
            const container = document.getElementById('warp-bossrush-buttons');
            const empty = document.getElementById('warp-bossrush-empty');
            if (!container) return;
            container.innerHTML = '';
            const floors = (Game.defeatedBossRushMilestones || []).sort((a, b) => a - b);
            if (floors.length === 0) {
                if (empty) empty.classList.remove('hidden');
                return;
            }
            if (empty) empty.classList.add('hidden');
            floors.forEach((floor) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'bg-amber-50 text-amber-700 text-[10px] font-black px-2 py-2 rounded-xl flex items-center justify-center gap-1 hover:bg-amber-100 transition';
                button.innerHTML = `<i class="fas fa-flag-checkered"></i> ${floor}F`;
                button.addEventListener('click', () => performWarp(floor, { isBossRush: true }));
                container.appendChild(button);
            });
        };

        const syncWarpModal = () => {
            const maxFloor = getWarpMaxFloor();
            const maxFloorEl = document.getElementById('warp-max-floor');
            const input = document.getElementById('warp-input');
            const infoButton = document.getElementById('warp-bossrush-info');
            const bossRushEnter = document.getElementById('warp-bossrush-enter');
            if (maxFloorEl) {
                maxFloorEl.textContent = maxFloor;
            }
            if (input) {
                input.max = maxFloor;
                const normalized = normalizeWarpFloor(input.value || Game.floor, { isBossRush: false });
                if (normalized !== null) {
                    input.value = normalized;
                }
            }
            if (infoButton) {
                infoButton.classList.toggle('hidden', maxFloor < 5000);
            }
            if (bossRushEnter) {
                bossRushEnter.classList.toggle('hidden', maxFloor < 5000);
            }
            renderWarpBossButtons();
            renderWarpBossRushButtons();
        };

        const updateWarpButtonState = () => {
            const warpBtn = document.getElementById('warp-btn');
            if (!warpBtn) return;
            const disabled = Game.state === 'combat';
            warpBtn.disabled = disabled;
            warpBtn.classList.toggle('opacity-40', disabled);
            warpBtn.classList.toggle('cursor-not-allowed', disabled);
        };

        const openWarpModal = () => {
            if (Game.state === 'combat') return;
            const modal = document.getElementById('warp-modal');
            if (!modal) return;
            syncWarpModal();
            modal.style.display = 'flex';
        };

        const closeWarpModal = () => {
            const modal = document.getElementById('warp-modal');
            if (!modal) return;
            modal.style.display = 'none';
        };

        const recordBossDefeat = (floor) => {
            if (!floor) return;
            ensureWarpState();
            if (Game.isBossRush) {
                const milestones = Game.defeatedBossRushMilestones;
                if (floor % 50 === 0 && !milestones.includes(floor)) {
                    milestones.push(floor);
                }
                return;
            }
            if (!Game.defeatedBossFloors.includes(floor)) {
                Game.defeatedBossFloors.push(floor);
            }
        };

        const performWarp = (value, options = {}) => {
            if (Game.state === 'combat') return;
            const target = normalizeWarpFloor(value, options);
            if (!target) return;
            Game.floor = target;
            Game.isBossRush = Boolean(options.isBossRush);
            if (Game.isBossRush) {
                Game.maxBossRushFloor = Math.max(Game.maxBossRushFloor || BossRushStartFloor, Game.floor);
            } else {
                Game.maxFloor = Math.max(Game.maxFloor, Game.floor);
                Game.bossRushCarryoverDamage = 0;
            }
            closeWarpModal();
            spawn();
            addLog(`B${Game.floor}ã¸ãƒ¯ãƒ¼ãƒ—...`, "text-sky-500");
            updateUI();
            triggerAutosave();
        };

        const enterBossRush = () => {
            if (Game.state === 'combat') return;
            if (getWarpMaxFloor() < 5000) return;
            Game.isBossRush = true;
            Game.floor = BossRushStartFloor;
            Game.maxBossRushFloor = Math.max(Game.maxBossRushFloor || BossRushStartFloor, Game.floor);
            Game.bossRushCarryoverDamage = 0;
            closeWarpModal();
            spawn();
            addLog("ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã«æŒ‘æˆ¦ï¼", "text-rose-500 font-black");
            updateUI();
            triggerAutosave();
        };

        const setupWarpControls = () => {
            const warpBtn = document.getElementById('warp-btn');
            const warpClose = document.getElementById('warp-close');
            const warpConfirm = document.getElementById('warp-confirm');
            const warpInput = document.getElementById('warp-input');
            const warpModal = document.getElementById('warp-modal');
            const warpBossRushInfo = document.getElementById('warp-bossrush-info');
            const warpBossRushEnter = document.getElementById('warp-bossrush-enter');
            if (warpBtn) {
                warpBtn.addEventListener('click', openWarpModal);
            }
            if (warpClose) {
                warpClose.addEventListener('click', closeWarpModal);
            }
            if (warpConfirm) {
                warpConfirm.addEventListener('click', () => performWarp(warpInput ? warpInput.value : ''));
            }
            if (warpInput) {
                warpInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        performWarp(warpInput.value);
                    }
                });
                warpInput.addEventListener('blur', () => {
                    const normalized = normalizeWarpFloor(warpInput.value, { isBossRush: false });
                    if (normalized !== null) {
                        warpInput.value = normalized;
                    }
                });
            }
            if (warpModal) {
                warpModal.addEventListener('click', (event) => {
                    if (event.target === warpModal) {
                        closeWarpModal();
                    }
                });
            }
            if (warpBossRushInfo) {
                warpBossRushInfo.addEventListener('click', openBossRushModal);
            }
            if (warpBossRushEnter) {
                warpBossRushEnter.addEventListener('click', enterBossRush);
            }
        };

        const setupRematchToggle = () => {
            const rematchToggle = document.getElementById('rematch-toggle');
            if (!rematchToggle) return;
            rematchToggle.addEventListener('change', (event) => {
                Game.stayOnFloor = event.target.checked;
                updateUI();
            });
        };

        // --- CORE LOGIC ---
        window.onload = () => {
            setupSaveControls();
            setupExportImportControls();
            setupWarpControls();
            setupRematchToggle();
            startAutosaveTimer();
            window.addEventListener('beforeunload', () => {
                triggerAutosave();
            });
            const autosaveSlot = getAutosaveSlot();
            const raw = localStorage.getItem(getSaveKey(autosaveSlot));
            if (raw) {
                loadFromSlot(autosaveSlot);
                return;
            }
            initializeStarterPotions();
            ensureWarpState();
            spawn();
            updateUI();
            switchJob('warrior');
            switchSkillType('active');
        };

        function switchPage(p) {
            document.querySelectorAll('.page').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('nav button').forEach(el => el.classList.remove('active'));
            document.getElementById(`page-${p}`).classList.add('active');
            document.getElementById(`nav-${p}`).classList.add('active');
            if (p === 'skill') {
                document.getElementById('nav-sp-dot').classList.add('hidden');
                renderSkillList();
            }
            if (p === 'log') {
                requestAnimationFrame(() => {
                    const full = document.getElementById('full-log-container');
                    if (full) full.scrollTop = full.scrollHeight;
                });
            }
        }

        function switchJob(job) {
            Game.currentJobTab = job;
            const selector = document.getElementById('job-select');
            if (selector && selector.value !== job) {
                selector.value = job;
            }
            renderSkillList();
        }

        function getSkillLevel(job, type, idx) {
            return Game.player.skills[job]?.[type]?.[idx] || 0;
        }

        function getPassiveLevel(job, idx) {
            return Game.player.skills[job]?.passive?.[idx] || 0;
        }

        const SkillMaxLevel = 150;
        const SkillMilestoneLevels = [10, 30, 50, 70, 100, 150];
        const SkillPointCostTiers = [
            { max: 10, cost: 1 },
            { max: 30, cost: 2 },
            { max: 50, cost: 3 },
            { max: 70, cost: 4 },
            { max: 100, cost: 5 },
            { max: 150, cost: 10 }
        ];
        const PassiveMilestoneKeyMap = {
            70: 10,
            100: 30,
            150: 50
        };

        const getSkillPointCostForLevel = (level) => {
            const tier = SkillPointCostTiers.find((entry) => level <= entry.max);
            return tier ? tier.cost : SkillPointCostTiers[SkillPointCostTiers.length - 1].cost;
        };

        const getSkillPointCostRange = (startLevel, endLevel) => {
            let total = 0;
            for (let lv = startLevel; lv <= endLevel; lv += 1) {
                total += getSkillPointCostForLevel(lv);
            }
            return total;
        };

        const getSkillPointSpendForIncrease = (current, maxLevel, desiredLevels, availableSp) => {
            let levels = 0;
            let cost = 0;
            for (let step = 1; step <= desiredLevels; step += 1) {
                const nextLevel = current + step;
                if (nextLevel > maxLevel) break;
                const stepCost = getSkillPointCostForLevel(nextLevel);
                if (cost + stepCost > availableSp) break;
                cost += stepCost;
                levels += 1;
            }
            return { levels, cost };
        };

        const getSkillPointRefundForDecrease = (current, desiredLevels) => {
            let levels = 0;
            let refund = 0;
            for (let step = 0; step < desiredLevels; step += 1) {
                const level = current - step;
                if (level <= 0) break;
                refund += getSkillPointCostForLevel(level);
                levels += 1;
            }
            return { levels, refund };
        };

        const cloneSkillEffects = (effects) => (
            Array.isArray(effects) ? effects.map(effect => ({ ...effect })) : []
        );

        const ensureEffectTurns = (effect) => {
            if (effect.turns !== undefined && effect.turns !== null) return effect.turns;
            return StatusDefs[effect.id]?.defaultTurns ?? 1;
        };

        const addEffectIfMissing = (effects, entry) => {
            const exists = effects.some(effect => effect.id === entry.id && effect.target === entry.target);
            if (!exists) effects.push(entry);
        };

        const upsertEffect = (effects, entry, stackBonus = 0, turnBonus = 0) => {
            const existing = effects.find(effect => effect.id === entry.id && effect.target === entry.target);
            if (existing) {
                const baseStacks = existing.stacks ?? 1;
                const baseTurns = ensureEffectTurns(existing);
                existing.stacks = Math.max(1, baseStacks + stackBonus);
                existing.turns = Math.max(1, baseTurns + turnBonus);
                return;
            }
            effects.push(entry);
        };

        const applyActiveSkillMilestones = (base, skill) => {
            let effects = cloneSkillEffects(base.effects);
            const level = skill.level;
            if (effects.length > 0 && level >= 10) {
                effects.forEach((effect) => {
                    const stacks = effect.stacks ?? 1;
                    if (effect.target === 'self' && NegativeStatusEffectIds.has(effect.id)) {
                        effect.stacks = Math.max(1, stacks);
                    } else {
                        effect.stacks = stacks + 1;
                    }
                });
            }
            if (effects.length > 0 && level >= 30) {
                effects.forEach((effect) => {
                    const baseTurns = ensureEffectTurns(effect);
                    if (effect.target === 'self' && NegativeStatusEffectIds.has(effect.id)) {
                        effect.turns = Math.max(1, baseTurns - 1);
                    } else {
                        effect.turns = baseTurns + 1;
                    }
                });
            }
            if (level >= 50) {
                if (skill.type === 'heal') {
                    upsertEffect(effects, { target: "self", id: "potionRegenHp", stacks: 2, turns: 3 }, 1, 1);
                    upsertEffect(effects, { target: "self", id: "barrier", stacks: 2, turns: 3 }, 1, 1);
                    addEffectIfMissing(effects, { target: "self", id: "potionRegenMp", stacks: 1, turns: 3 });
                } else if (effects.some(effect => effect.target !== 'self')) {
                    if (skill.isMagic) {
                        upsertEffect(
                            effects,
                            { target: "enemy", id: "weaken", stacks: 2, turns: 3, log: "é­”åŠ›ã§å‹¢ã„ã‚’å‰Šã„ã ï¼" },
                            1,
                            1
                        );
                    } else {
                        upsertEffect(
                            effects,
                            { target: "enemy", id: "vulnerable", stacks: 2, turns: 3, log: "æ·±ã„å‚·ãŒæ®‹ã£ãŸï¼" },
                            1,
                            1
                        );
                    }
                } else if (effects.some(effect => effect.target === 'self')) {
                    upsertEffect(effects, { target: "self", id: "attackUp", stacks: 2, turns: 3 }, 1, 1);
                    addEffectIfMissing(effects, { target: "self", id: "haste", stacks: 1, turns: 2 });
                }
            }
            if (effects.length > 0 && level >= 70) {
                effects.forEach((effect) => {
                    const stacks = effect.stacks ?? 1;
                    if (effect.target === 'self' && NegativeStatusEffectIds.has(effect.id)) {
                        effect.stacks = Math.max(1, stacks);
                    } else {
                        effect.stacks = stacks + 1;
                    }
                });
            }
            if (effects.length > 0 && level >= 100) {
                effects.forEach((effect) => {
                    const baseTurns = ensureEffectTurns(effect);
                    if (effect.target === 'self' && NegativeStatusEffectIds.has(effect.id)) {
                        effect.turns = Math.max(1, baseTurns - 1);
                    } else {
                        effect.turns = baseTurns + 1;
                    }
                });
            }
            if (level >= 150) {
                if (skill.type === 'heal') {
                    upsertEffect(effects, { target: "self", id: "potionRegenHp", stacks: 2, turns: 3 }, 1, 1);
                    upsertEffect(effects, { target: "self", id: "barrier", stacks: 2, turns: 3 }, 1, 1);
                    addEffectIfMissing(effects, { target: "self", id: "potionRegenMp", stacks: 1, turns: 3 });
                } else if (effects.some(effect => effect.target !== 'self')) {
                    if (skill.isMagic) {
                        upsertEffect(
                            effects,
                            { target: "enemy", id: "weaken", stacks: 2, turns: 3, log: "é­”åŠ›ã§å‹¢ã„ã‚’å‰Šã„ã ï¼" },
                            1,
                            1
                        );
                    } else {
                        upsertEffect(
                            effects,
                            { target: "enemy", id: "vulnerable", stacks: 2, turns: 3, log: "æ·±ã„å‚·ãŒæ®‹ã£ãŸï¼" },
                            1,
                            1
                        );
                    }
                } else if (effects.some(effect => effect.target === 'self')) {
                    upsertEffect(effects, { target: "self", id: "attackUp", stacks: 2, turns: 3 }, 1, 1);
                    addEffectIfMissing(effects, { target: "self", id: "haste", stacks: 1, turns: 2 });
                }
            }
            if (skill.type !== 'heal' && effects.length === 0) {
                if (level >= 10) skill.accuracyBonus = (skill.accuracyBonus || 0) + 5;
                if (level >= 30) skill.critBonus = (skill.critBonus || 0) + 5;
                if (level >= 50) {
                    if (skill.pow !== undefined) skill.pow = Math.round(skill.pow * 1.2 * 100) / 100;
                    if (skill.hits !== undefined) skill.hits = skill.hits + 1;
                    if (skill.isMagic) {
                        addEffectIfMissing(effects, { target: "self", id: "buff", stacks: 1, turns: 2 });
                    } else {
                        addEffectIfMissing(effects, { target: "self", id: "attackUp", stacks: 1, turns: 2 });
                    }
                }
                if (level >= 70) skill.accuracyBonus = (skill.accuracyBonus || 0) + 5;
                if (level >= 100) skill.critBonus = (skill.critBonus || 0) + 5;
                if (level >= 150) {
                    if (skill.pow !== undefined) skill.pow = Math.round(skill.pow * 1.35 * 100) / 100;
                    if (skill.hits !== undefined) skill.hits = skill.hits + 1;
                    if (skill.isMagic) {
                        addEffectIfMissing(effects, { target: "self", id: "buff", stacks: 1, turns: 2 });
                    } else {
                        addEffectIfMissing(effects, { target: "self", id: "attackUp", stacks: 1, turns: 2 });
                    }
                }
            }
            skill.effects = effects.length > 0 ? effects : undefined;
        };

        function buildActiveSkill(job, idx, level) {
            const base = JobData[job].active[idx];
            const lv = Math.max(1, level);
            const scale = lv - 1;
            const skill = { ...base, level: lv, maxLevel: base.maxLevel || SkillMaxLevel };
            if (base.mp !== undefined) {
                const baseMp = Math.max(0, Math.round(base.mp + (base.mpGrowth || 0) * scale));
                if (baseMp > 0) {
                    const levelBonus = Math.floor(Math.max(0, lv - 1) * 0.8);
                    skill.mp = baseMp + levelBonus;
                } else {
                    skill.mp = baseMp;
                }
            }
            if (base.pow !== undefined) skill.pow = Math.max(0, base.pow + (base.powGrowth || 0) * scale);
            if (base.val !== undefined) skill.val = Math.max(0, Math.round(base.val + (base.valGrowth || 0) * scale));
            if (base.hits !== undefined) skill.hits = Math.max(1, Math.round(base.hits + (base.hitsGrowth || 0) * scale));
            if (base.mpHeal !== undefined) skill.mpHeal = Math.max(0, base.mpHeal + (base.mpHealGrowth || 0) * scale);
            if (base.expBonus !== undefined) skill.expBonus = Math.max(0, Math.round(base.expBonus + (base.expBonusGrowth || 0) * scale));
            if (base.accuracyBonus !== undefined) skill.accuracyBonus = Math.round(base.accuracyBonus + (base.accuracyGrowth || 0) * scale);
            if (base.critBonus !== undefined) skill.critBonus = Math.round(base.critBonus + (base.critGrowth || 0) * scale);
            if (base.leech !== undefined) skill.leech = Math.max(0, base.leech + (base.leechGrowth || 0) * scale);
            applyActiveSkillMilestones(base, skill);
            return skill;
        }

        function getSlotSkill(slot) {
            if (!slot) return null;
            const level = getSkillLevel(slot.job, 'active', slot.idx);
            if (level <= 0) return null;
            return buildActiveSkill(slot.job, slot.idx, level);
        }

        function getNextSlotSkill() {
            const slots = Game.player.skillSlots;
            const start = Game.player.skillSlotIndex ?? 0;
            const totalSlots = slots.length;
            const findNextIndex = (currentIndex) => {
                for (let i = 1; i <= totalSlots; i++) {
                    const idx = (currentIndex + i) % totalSlots;
                    if (getSlotSkill(slots[idx])) return idx;
                }
                return currentIndex;
            };
            for (let i = 0; i < totalSlots; i++) {
                const idx = (start + i) % totalSlots;
                const skill = getSlotSkill(slots[idx]);
                if (skill) {
                    return { skill, slotIndex: idx, nextIndex: findNextIndex(idx) };
                }
            }
            return { skill: null, slotIndex: start, nextIndex: start };
        }

        function setSkillSlotTarget(idx) {
            Game.player.skillSlotTarget = idx;
            renderSkillList();
            updateUI();
        }

        function assignSkillToSlot(job, idx) {
            const level = getSkillLevel(job, 'active', idx);
            if (level <= 0) return;
            Game.player.skillSlots = Game.player.skillSlots.map((slot, slotIndex) => {
                if (slotIndex === Game.player.skillSlotTarget) return slot;
                if (slot && slot.job === job && slot.idx === idx) return null;
                return slot;
            });
            Game.player.skillSlots[Game.player.skillSlotTarget] = { job, idx };
            updateUI();
            triggerAutosave();
        }

        function clearSkillSlot(idx) {
            Game.player.skillSlots[idx] = null;
            updateUI();
            triggerAutosave();
        }

        function getDerivedStats() {
            const p = Game.player;
            const totals = getTotalStats();
            const statusMods = getStatusModifiers(p);
            const strMultiplier = 1 + (totals.strMultiplier || 0) / 100;
            const vitMultiplier = 1 + (totals.vitMultiplier || 0) / 100;
            const intMultiplier = 1 + (totals.intMultiplier || 0) / 100;
            const dexMultiplier = 1 + (totals.dexMultiplier || 0) / 100;
            const lukMultiplier = 1 + (totals.lukMultiplier || 0) / 100;
            const boostedTotals = {
                ...totals,
                str: Math.floor(totals.str * strMultiplier),
                vit: Math.floor(totals.vit * vitMultiplier),
                int: Math.floor(totals.int * intMultiplier),
                dex: Math.floor(totals.dex * dexMultiplier),
                luk: Math.floor(totals.luk * lukMultiplier)
            };
            const maxHpBase = totals.maxHp + totals.maxHpFlat;
            const maxMpBase = totals.maxMp + totals.maxMpFlat;
            const maxHp = Math.max(1, Math.floor(maxHpBase));
            const maxMp = Math.max(0, Math.floor(maxMpBase));
            const atkBase = boostedTotals.str + totals.attackFlat;
            const atk = Math.max(0, Math.floor(atkBase * statusMods.atkMul));
            const defBase = boostedTotals.vit + totals.defenseFlat;
            const def = Math.max(0, Math.floor(defBase * statusMods.defMul));
            const dexAccuracyBonus = Math.floor(boostedTotals.dex * 0.2);
            const dexEvasionBonus = Math.floor(boostedTotals.dex * 0.15);
            const dexCritRateBonus = Math.floor(boostedTotals.dex * 0.05);
            const dexCritDamageBonus = Math.floor(boostedTotals.dex * 0.2);
            const lukBonus = Math.floor(boostedTotals.luk * 0.5);
            const modifiedTotals = {
                ...boostedTotals,
                accuracy: Math.max(0, Math.floor((totals.accuracy + dexAccuracyBonus) * statusMods.accuracyMul)),
                critRate: Math.max(0, Math.floor((totals.critRate + dexCritRateBonus) * statusMods.critMul)),
                evasionRate: Math.max(0, Math.floor((totals.evasionRate + dexEvasionBonus) * statusMods.evasionMul)),
                critDamage: Math.max(0, Math.floor(totals.critDamage + dexCritDamageBonus)),
                expBoost: totals.expBoost + lukBonus,
                luck: totals.luck + lukBonus,
                rareFind: totals.rareFind + lukBonus,
                affixFind: totals.affixFind + lukBonus,
                eliteEncounter: totals.eliteEncounter + lukBonus,
                goldBoost: totals.goldBoost + lukBonus
            };
            return { maxHp, maxMp, atk, def, totals: modifiedTotals };
        }

        function applyDamage(target, amount, source = null, options = {}) {
            const safeAmount = Math.max(0, Math.floor(amount));
            if (!target || safeAmount <= 0) return 0;
            let remaining = safeAmount;
            if (target === Game.enemy && !options.ignoreBossRushNullify) {
                const threshold = getBossRushDamageNullifyThreshold(target);
                if (threshold > 0 && remaining < threshold) {
                    return 0;
                }
            }
            if (target === Game.enemy && !options.ignoreBossRushDamageReduction) {
                remaining = Math.floor(remaining * getBossRushDamageTakenMultiplier(target, Game.player));
            }
            const barrierEffect = getStatusEffect(target, 'barrier');
            if (barrierEffect) {
                const def = StatusDefs.barrier;
                if (barrierEffect.shield === undefined) {
                    barrierEffect.shield = (def.shieldPerStack || 0) * (barrierEffect.stacks || 1);
                }
                const absorbed = Math.min(remaining, barrierEffect.shield);
                barrierEffect.shield -= absorbed;
                remaining -= absorbed;
                if (barrierEffect.shield <= 0) {
                    removeStatusEffect(target, 'barrier');
                } else if (def.shieldPerStack) {
                    barrierEffect.stacks = Math.max(1, Math.ceil(barrierEffect.shield / def.shieldPerStack));
                }
            }
            if (target === Game.player && remaining > 0 && hasBossUniqueEffect("damageBuffer")) {
                const bossState = Game.player.bossUniqueState;
                const derived = getDerivedStats();
                const absorb = Math.floor(remaining * BossUniqueEffectConfig.damageBufferAbsorbRate);
                if (absorb > 0) {
                    remaining -= absorb;
                    const cap = Math.floor(derived.atk * BossUniqueEffectConfig.damageBufferCapRate);
                    bossState.damageBufferCharge = Math.min(cap, (bossState.damageBufferCharge || 0) + absorb);
                    addLog("å²©æ ¸ã®å¤§ç›¾ãŒè¡æ’ƒã‚’è“„ç©ï¼", "text-amber-400");
                }
            }
            if (remaining > 0 && target === Game.enemy && hasBossRushBuff(target, "br_blue_spread") && !options.ignoreBossRushSpread) {
                const spread = Math.floor(remaining * BossRushBuffConfig.damageSpreadPct);
                if (spread > 0) {
                    remaining -= spread;
                    Game.bossRushCarryoverDamage = Math.max(0, (Game.bossRushCarryoverDamage || 0) + spread);
                }
            }
            if (target === Game.player && remaining > 0 && hasBossUniqueEffect("lethalGuard")) {
                const bossState = Game.player.bossUniqueState;
                if (!bossState.ironWallUsed && remaining >= target.hp) {
                    bossState.ironWallUsed = true;
                    remaining = Math.max(0, target.hp - 1);
                    addLog("é‰„å£ã®é§ãŒè‡´æ­»ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’é˜²ã„ã ï¼", "text-amber-400");
                }
            }
            if (remaining > 0) {
                target.hp = Math.max(0, target.hp - remaining);
                removeStatusEffect(target, 'freeze');
            }
            if (target === Game.player && remaining > 0) {
                const bossState = Game.player.bossUniqueState;
                const guardEffect = getBossUniqueEffectByType("returnDoubleGuard");
                if (guardEffect && checkBossUniqueCondition(guardEffect.condition, { player: Game.player, enemy: Game.enemy, derived: getDerivedStats() })) {
                    bossState.guardianReturnCharge = Math.max(0, (bossState.guardianReturnCharge || 0) + remaining * 2);
                }
                if (hasBossUniqueEffect("damageReturnCharge")) {
                    const derived = getDerivedStats();
                    const charge = Math.floor(remaining * BossUniqueEffectConfig.damageReturnRate);
                    const cap = Math.floor(derived.atk * BossUniqueEffectConfig.damageReturnCapRate);
                    bossState.damageReturnCharge = Math.min(cap, (bossState.damageReturnCharge || 0) + charge);
                }
                if (hasBossUniqueEffect("defenseLayers")) {
                    bossState.defenseLayers = Math.max(0, (bossState.defenseLayers || 0) + 1);
                }
                if (hasBossUniqueEffect("martyrLight")) {
                    const derived = getDerivedStats();
                    const threshold = Math.max(1, Math.floor(derived.maxHp * BossUniqueEffectConfig.martyrLightThresholdRate));
                    bossState.martyrLight = Math.max(0, (bossState.martyrLight || 0) + remaining);
                    while (bossState.martyrLight >= threshold) {
                        bossState.martyrLight -= threshold;
                        const blastDamage = Math.max(1, Math.floor(threshold * BossUniqueEffectConfig.martyrLightDamageRate));
                        if (Game.enemy && Game.enemy.hp > 0) {
                            const applied = applyDamage(Game.enemy, blastDamage, Game.player, { ignoreBossRushNullify: true, ignoreBossRushDamageReduction: true, ignoreReflect: true });
                            addLog(`å—é›£ã®å…‰ãŒçˆ†ç™ºï¼ ${applied}ãƒ€ãƒ¡ãƒ¼ã‚¸`, "text-amber-400");
                        }
                    }
                }
            }
            if (remaining > 0 && target === Game.enemy) {
                const state = getBossRushBuffState(target);
                if (state) {
                    state.hitsTaken = Math.max(0, state.hitsTaken || 0) + 1;
                }
                if (target.hp <= 0 && hasBossRushBuff(target, "br_red_revive") && !state?.revived) {
                    if (state) state.revived = true;
                    target.hp = Math.max(1, Math.floor(target.maxHp * BossRushBuffConfig.reviveHpPct));
                    addLog(`${target.name}ãŒå¾©æ´»ã—ãŸï¼`, "text-rose-400 font-black");
                }
            }
            if (!options.ignoreReflect && remaining > 0 && source) {
                const mods = getStatusModifiers(target);
                let reflectPct = mods.reflectPct;
                if (target === Game.enemy && hasBossRushBuff(target, "br_blue_reflect")) {
                    reflectPct += BossRushBuffConfig.reflectPct;
                }
                reflectPct = Math.min(0.8, Math.max(0, reflectPct));
                if (reflectPct > 0) {
                    const reflectDamage = Math.max(1, Math.floor(remaining * reflectPct));
                    const guardEffect = getStatusEffect(source, 'potionReflectGuard');
                    if (guardEffect && guardEffect.stacks > 0) {
                        guardEffect.stacks -= 1;
                        if (guardEffect.stacks <= 0) {
                            removeStatusEffect(source, 'potionReflectGuard');
                        }
                        addLog("åå°„ã‚’ç„¡åŠ¹åŒ–ï¼", "text-slate-500");
                    } else {
                        applyDamage(source, reflectDamage, null, { ignoreReflect: true });
                        addLog(`åå°„ãƒ€ãƒ¡ãƒ¼ã‚¸ ${reflectDamage}`, "text-purple-400");
                    }
                }
            }
            return remaining;
        }

        function applyBossRushOnHitEffects(appliedDamage) {
            if (!Game.enemy || appliedDamage <= 0) return;
            if (hasBossRushBuff(Game.enemy, "br_blue_leech")) {
                const heal = Math.max(1, Math.floor(appliedDamage * BossRushBuffConfig.leechPct));
                const before = Game.enemy.hp;
                Game.enemy.hp = Math.min(Game.enemy.maxHp, Game.enemy.hp + heal);
                const actual = Game.enemy.hp - before;
                if (actual > 0) {
                    addLog(`${Game.enemy.name}ã¯HPã‚’${actual}å¸åï¼`, "text-emerald-400");
                }
            }
            if (hasBossRushBuff(Game.enemy, "br_orange_random") && Math.random() < BossRushBuffConfig.statusRandomChance) {
                const statusId = pickRandom(BossRushRandomStatusPool);
                if (statusId) {
                    applyStatusEffect(Game.player, statusId, 1, StatusDefs[statusId]?.defaultTurns ?? 2);
                    addLog(`${Game.enemy.name}ã®ç•°å¸¸ä»˜ä¸ï¼`, "text-purple-400");
                }
            }
        }

        function performPlayerSkillAction(currentSkill, context, options = {}) {
            const {
                derived,
                enemyStatusMods,
                enemyEvasion,
                enemyDefense,
                playerStatusMods
            } = context;
            const {
                labelPrefix = "",
                applyStatusEffects = true
            } = options;
            const bossState = Game.player.bossUniqueState;
            const skillLabel = labelPrefix ? `${labelPrefix}${currentSkill.name}` : currentSkill.name;
            let totalDamage = 0;
            let totalLeechApplied = 0;
            let landedHit = false;
            let nullifiedHit = false;

            if (currentSkill.type === 'heal') {
                let amt = Math.floor(currentSkill.val + (derived.totals.int * 1.2));
                if (derived.totals.skillPowerBoost > 0) {
                    amt = Math.floor(amt * (1 + derived.totals.skillPowerBoost / 100));
                }
                Game.player.hp = Math.min(derived.maxHp, Game.player.hp + amt);
                addLog(`ã€å›å¾©ã€‘${amt}HP`, "text-green-500");
                dmgText(amt, true);
                triggerBossRushHealReaction(amt, "å›å¾©åæ’ƒ");
            } else {
                const bossMods = getBossUniqueCombatModifiers({
                    player: Game.player,
                    enemy: Game.enemy,
                    derived,
                    baseHits: currentSkill.hits || 1
                });
                if (bossMods.logs.length) {
                    bossMods.logs.forEach((line) => addLog(line, "text-amber-400"));
                }
                const baseHits = currentSkill.hits || 1;
                let adjustedBaseHits = baseHits;
                let amplifyFinalHit = false;
                if (hasBossUniqueEffect("multiHitAmplifyDex")) {
                    const extraHits = Math.min(
                        BossUniqueEffectConfig.multiHitMaxExtra,
                        Math.floor(derived.totals.dex / BossUniqueEffectConfig.multiHitDexStep)
                    );
                    adjustedBaseHits = Math.max(adjustedBaseHits, BossUniqueEffectConfig.multiHitBase + extraHits);
                    amplifyFinalHit = true;
                }
                const barrierSplitActive = hasBossUniqueEffect("barrierSplitHits") && Boolean(getStatusEffect(Game.player, 'barrier'));
                if (barrierSplitActive) {
                    adjustedBaseHits *= BossUniqueEffectConfig.barrierSplitHits;
                }
                const defenseLayerHits = Math.max(0, bossState.defenseLayers || 0);
                let hits = adjustedBaseHits + (bossMods.bonusHits || 0) + defenseLayerHits;
                let nextHitConsumed = false;
                let storedBonusApplied = false;
                let killRecorded = false;
                const nextHitEffect = getStatusEffect(Game.player, 'potionNextHitBoost');
                const nextHitBoost = nextHitEffect?.bonusPct || 0;
                const leechBoost = getStatusEffect(Game.player, 'potionLeechBoost')?.bonusPct || 0;
                const defenseLayerStart = adjustedBaseHits + (bossMods.bonusHits || 0);

                for (let i = 0; i < hits; i++) {
                    if (Game.enemy.hp <= 0) break;
                    const sureHitEffect = getBossUniqueEffectByType("sureHitHighHp");
                    const sureHit = Boolean(sureHitEffect && checkBossUniqueCondition(sureHitEffect.condition, { player: Game.player, enemy: Game.enemy, derived }));
                    const baseAccuracy = Math.max(0, derived.totals.accuracy + (currentSkill.accuracyBonus || 0) + bossMods.accuracyBonus);
                    const evasionValue = Math.max(0, enemyEvasion);
                    const baseHit = 78;
                    const hitScale = 0.28;
                    let hitChance = baseHit + (baseAccuracy - evasionValue) * hitScale;
                    hitChance = Math.min(97, Math.max(15, hitChance));
                    if (!sureHit && Math.random() * 100 > hitChance) {
                        continue;
                    }
                    landedHit = true;
                    let atkBase = currentSkill.isMagic ? (derived.totals.int * 2) : derived.atk;
                    let isCrit = Math.random() * 100 < (derived.totals.critRate + (currentSkill.critBonus || 0) + bossMods.critRateBonus);
                    let forceFirstStrike = false;
                    const shadowEffect = getBossUniqueEffectByType("shadowFirstStrike");
                    if (shadowEffect && !bossState.shadowFirstStrikeUsed && Game.enemy.hp === Game.enemy.maxHp) {
                        if (checkBossUniqueCondition(shadowEffect.condition, { player: Game.player, enemy: Game.enemy, derived })) {
                            isCrit = true;
                            forceFirstStrike = true;
                            bossState.shadowFirstStrikeUsed = true;
                        }
                    }
                    const powerScale = currentSkill.name === 'é€šå¸¸æ”»æ’ƒ' ? CombatBalance.playerNormalPow : CombatBalance.playerSkillPow;
                    let dmg = Math.floor(currentSkill.pow * powerScale * atkBase * (0.9 + Math.random() * 0.2));
                    if (isCrit) dmg = Math.floor(dmg * (derived.totals.critDamage / 100));
                    if (forceFirstStrike) {
                        dmg = Math.floor(dmg * BossUniqueEffectConfig.shadowFirstStrikeMultiplier);
                    }
                    if (isCrit && hasBossRushBuff(Game.enemy, "br_yellow_crit_def")) {
                        const state = getBossRushBuffState(Game.enemy);
                        if (state) {
                            state.defenseBoostPct = Math.min(100, (state.defenseBoostPct || 0) + BossRushBuffConfig.critDefBoost * 100);
                        }
                    }

                    if (currentSkill.name !== 'é€šå¸¸æ”»æ’ƒ' && derived.totals.skillPowerBoost > 0) {
                        dmg = Math.floor(dmg * (1 + derived.totals.skillPowerBoost / 100));
                    }
                    if (i >= adjustedBaseHits && i < defenseLayerStart && bossMods.bonusHitMultiplier !== 1) {
                        dmg = Math.floor(dmg * bossMods.bonusHitMultiplier);
                    }
                    if (i >= defenseLayerStart && defenseLayerHits > 0) {
                        dmg = Math.floor(dmg * BossUniqueEffectConfig.defenseLayerMultiplier);
                    }

                    const lowHpLevel = getPassiveLevel('warrior', 5);
                    if (lowHpLevel > 0 && Game.player.hp < derived.maxHp * 0.3) {
                        dmg = Math.floor(dmg * (1 + 0.1 * lowHpLevel));
                    }
                    const firstHitLevel = getPassiveLevel('thief', 5);
                    if (firstHitLevel > 0 && Game.enemy.hp === Game.enemy.maxHp) {
                        dmg = Math.floor(dmg * (1 + 0.25 * firstHitLevel));
                    }

                    if (derived.totals.damageBoost > 0) {
                        dmg = Math.floor(dmg * (1 + derived.totals.damageBoost / 100));
                    }
                    if (bossMods.damageMultiplier !== 1) {
                        dmg = Math.floor(dmg * bossMods.damageMultiplier);
                    }
                    if (nextHitBoost > 0 && !nextHitConsumed) {
                        dmg = Math.floor(dmg * (1 + nextHitBoost / 100));
                        nextHitConsumed = true;
                        removeStatusEffect(Game.player, 'potionNextHitBoost');
                        addLog("çŒ›æ’ƒãŒç™ºå‹•ï¼", "text-amber-400");
                    }
                    if (barrierSplitActive) {
                        dmg = Math.floor(dmg * BossUniqueEffectConfig.barrierSplitMultiplier);
                    }
                    if (amplifyFinalHit && i === hits - 1) {
                        dmg = Math.floor(dmg * BossUniqueEffectConfig.multiHitFinalMultiplier);
                    }
                    if (!storedBonusApplied) {
                        const enemyHpBefore = Game.enemy.hp;
                        let bonus = 0;
                        if (bossState.damageBufferCharge > 0) {
                            bonus += bossState.damageBufferCharge;
                            bossState.damageBufferCharge = 0;
                            addLog("å²©æ ¸ã®å¤§ç›¾ãŒåæ’ƒã«è»¢åŒ–ï¼", "text-amber-400");
                        }
                        if (bossState.damageReturnCharge > 0) {
                            bonus += bossState.damageReturnCharge;
                            bossState.damageReturnCharge = 0;
                            addLog("é›·é³´ã®æˆ¦æ§ŒãŒè“„ç©ã‚’æ”¾ã£ãŸï¼", "text-amber-400");
                        }
                        if (bossState.guardianReturnCharge > 0) {
                            bonus += bossState.guardianReturnCharge;
                            bossState.guardianReturnCharge = 0;
                            addLog("é‰„å£åéŸ¿ãŒå€è¿”ã—ï¼", "text-amber-400");
                        }
                        if (bossState.overkillBank > 0) {
                            bonus += bossState.overkillBank;
                            bossState.overkillBank = 0;
                            addLog("ã‚ªãƒ¼ãƒãƒ¼ã‚­ãƒ«è²¯é‡‘ã‚’è§£æ”¾ï¼", "text-amber-400");
                        }
                        if (bossState.killOverflowCharge > 0 && enemyHpBefore === Game.enemy.maxHp) {
                            bonus += bossState.killOverflowCharge;
                            bossState.killOverflowCharge = 0;
                            addLog("éå‰°ç«åŠ›ãŒåˆæ’ƒã«ä¹—ã£ãŸï¼", "text-amber-400");
                        }
                        if (bonus > 0) {
                            dmg += bonus;
                            storedBonusApplied = true;
                        }
                    }
                    dmg = Math.floor(dmg * playerStatusMods.damageDoneMul);
                    dmg = Math.floor(dmg * enemyStatusMods.damageTakenMul);
                    dmg = Math.floor(dmg * getBossRushDamageTakenMultiplier(Game.enemy, Game.player));
                    const attackValue = Math.max(1, Math.floor(atkBase));
                    const defenseValue = Math.max(0, enemyDefense);
                    dmg = Math.floor(dmg * getDamageRatio(attackValue, defenseValue));
                    const nullifyThreshold = getBossRushDamageNullifyThreshold(Game.enemy);
                    if (nullifyThreshold > 0 && dmg > 0 && dmg < nullifyThreshold) {
                        nullifiedHit = true;
                        continue;
                    }
                    dmg = Math.max(1, dmg);
                    const enemyHpBefore = Game.enemy.hp;
                    const appliedDamage = applyDamage(Game.enemy, dmg, Game.player, { ignoreBossRushNullify: true, ignoreBossRushDamageReduction: true });
                    totalDamage += appliedDamage;

                    const totalLeech = derived.totals.leechRate + (currentSkill.leech || 0) + leechBoost;
                    if (totalLeech > 0 && appliedDamage > 0) {
                        let l = Math.floor(appliedDamage * (totalLeech / 100));
                        if (l > 0) {
                            const beforeHp = Game.player.hp;
                            Game.player.hp = Math.min(derived.maxHp, Game.player.hp + l);
                            totalLeechApplied += (Game.player.hp - beforeHp);
                        }
                    }
                    if (!killRecorded && enemyHpBefore > 0 && Game.enemy.hp <= 0) {
                        if (hasBossUniqueEffect("overkillBank")) {
                            const overkill = Math.max(0, appliedDamage - enemyHpBefore);
                            if (overkill > 0) {
                                const cap = Math.floor(derived.atk * BossUniqueEffectConfig.overkillCapRate);
                                bossState.overkillBank = Math.min(cap, (bossState.overkillBank || 0) + overkill);
                                addLog(`ã‚ªãƒ¼ãƒãƒ¼ã‚­ãƒ«è²¯é‡‘ +${overkill}`, "text-amber-400");
                            }
                        }
                        if (hasBossUniqueEffect("killOverflow")) {
                            const gain = Math.max(1, Math.floor(appliedDamage * BossUniqueEffectConfig.killOverflowRate));
                            const cap = Math.floor(derived.atk * BossUniqueEffectConfig.killOverflowCapRate);
                            bossState.killOverflowCharge = Math.min(cap, (bossState.killOverflowCharge || 0) + gain);
                            addLog(`éå‰°ç«åŠ›ã‚’ä¿å­˜ +${gain}`, "text-amber-400");
                        }
                        killRecorded = true;
                    }
                }

                if (defenseLayerHits > 0) {
                    bossState.defenseLayers = 0;
                }
                
                if (totalDamage === 0) {
                    if (landedHit) {
                        addLog(nullifiedHit ? "ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒç„¡åŠ¹åŒ–ã•ã‚ŒãŸï¼" : "ãƒãƒªã‚¢ã«é˜²ãŒã‚ŒãŸï¼", "text-slate-400");
                        dmgText(0, false);
                    } else {
                        addLog("æ”»æ’ƒãŒå¤–ã‚ŒãŸï¼", "text-slate-400");
                        dmgText("MISS", false);
                        triggerBossRushMistakeReaction();
                    }
                } else {
                    addLog(`${skillLabel}ï¼ ${totalDamage}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸`);
                    dmgText(totalDamage);
                }

                if (currentSkill.mpHeal && totalDamage > 0) {
                    const mHeal = Math.floor(totalDamage * currentSkill.mpHeal);
                    const beforeMp = Game.player.mp;
                    Game.player.mp = Math.min(derived.maxMp, Game.player.mp + mHeal);
                    const actual = Game.player.mp - beforeMp;
                    if (actual > 0) {
                        addLog(`MPå¸å +${actual}`, "text-blue-400");
                        triggerBossRushHealReaction(actual, "å›å¾©åæ’ƒ");
                    }
                }
                if (totalLeechApplied > 0) {
                    addLog(`å¸è¡€ã§HPãŒ${totalLeechApplied}å›å¾©`, "text-emerald-400");
                    triggerBossRushHealReaction(totalLeechApplied, "å›å¾©åæ’ƒ");
                }
                if (currentSkill.expBonus && totalDamage > 0) {
                    let b = Math.floor(Game.player.next * (currentSkill.expBonus / 100));
                    Game.player.exp += b;
                    addLog(`EXP +${b} å¥ªå–ï¼`);
                    applyLevelUps();
                }

                document.getElementById('enemy-visual').classList.add('shake');
                setTimeout(() => document.getElementById('enemy-visual').classList.remove('shake'), 200);
            }

            if (applyStatusEffects && currentSkill.effects) {
                const stackBonus = derived.totals.statusEffectStackBonus || 0;
                const turnBonus = derived.totals.statusEffectTurnBonus || 0;
                const singleStatusRule = hasBossUniqueEffect("singleStatusRule");
                const poisonUnlimited = hasBossUniqueEffect("poisonUnlimited");
                const poisonSurgeEffect = getBossUniqueEffectByType("poisonStackSurge");
                currentSkill.effects.forEach((effect) => {
                    const target = effect.target === "self" ? Game.player : Game.enemy;
                    let stacks = effect.stacks;
                    let turns = effect.turns;
                    if (effect.target !== "self" && NegativeStatusEffectIds.has(effect.id)) {
                        stacks = (stacks || 0) + stackBonus;
                        if (turnBonus > 0) {
                            const baseTurns = turns ?? (StatusDefs[effect.id]?.defaultTurns ?? 1);
                            turns = baseTurns + turnBonus;
                        }
                    }
                    const isFreeze = effect.id === "freeze" && effect.target !== "self";
                    const baseChance = effect.chance ?? 1;
                    const finalChance = isFreeze ? getFreezeDecayChance(target, baseChance) : baseChance;
                    if (!isFreeze || Math.random() < finalChance) {
                        const sourceStr = effect.target === "self" ? null : derived.totals.str;
                        const poisonMaxStacksBonus = effect.id === "poison" ? derived.totals.poisonMaxStacksBonus : 0;
                        const poisonMinPctBonus = effect.id === "poison" ? derived.totals.poisonMinPctBonus : 0;
                        if (effect.id === "poison" && effect.target !== "self" && poisonSurgeEffect) {
                            if (checkBossUniqueCondition(poisonSurgeEffect.condition, { player: Game.player, enemy: Game.enemy, derived })) {
                                stacks = (stacks || 0) + (poisonSurgeEffect.value || 0);
                            }
                        }
                        const source = (sourceStr || poisonMaxStacksBonus || poisonMinPctBonus || singleStatusRule || poisonUnlimited)
                            ? { sourceStr, poisonMaxStacksBonus, poisonMinPctBonus, singleStatusRule, poisonUnlimited }
                            : null;
                        applyStatusEffect(target, effect.id, stacks, turns, source);
                        if (isFreeze) {
                            recordFreezeApplied(target);
                        }
                        if (effect.log && effect.target !== "self") {
                            addLog(effect.log, "text-purple-400");
                        }
                    }
                });
            }

            return { totalDamage, landedHit, nullifiedHit };
        }

        function performEnemyPhysicalAttack({ derived, label = "", damageMultiplier = 1, canMiss = true, logTone = "text-red-400" }) {
            const enemyStatusMods = getStatusModifiers(Game.enemy);
            const playerStatusMods = getStatusModifiers(Game.player);
            if (canMiss) {
                const baseAccuracy = Math.max(0, Math.floor((Game.enemy.acc || 0) * enemyStatusMods.accuracyMul));
                const evasionValue = Math.max(0, derived.totals.evasionRate);
                const baseHit = 78;
                const hitScale = 0.28;
                let hitChance = baseHit + (baseAccuracy - evasionValue) * hitScale;
                hitChance = Math.min(97, Math.max(15, hitChance));
                if (Math.random() * 100 > hitChance) {
                    addLog("æ”»æ’ƒã‚’å›é¿ï¼", "text-blue-500 font-bold");
                    dmgText("MISS", false);
                    return { appliedDamage: 0, landedHit: false, isCrit: false };
                }
            }
            const ignoreDefense = shouldBossRushIgnoreDefense(Game.enemy);
            let enemyAtk = Game.enemy.str * enemyStatusMods.atkMul;
            let d = Math.floor(enemyAtk * CombatBalance.enemyNormalPow * (0.8 + Math.random() * 0.4) * damageMultiplier);
            d = Math.floor(d * getBossRushEnemyAttackMultiplier(Game.enemy));
            let isCrit = false;
            const critRate = getBossRushEnemyCritRate(Game.enemy);
            if (Math.random() * 100 < critRate) {
                isCrit = true;
                d = Math.floor(d * getBossRushEnemyCritMultiplier(Game.enemy));
            }
            if (!ignoreDefense) {
                let defenseValue = derived.def;
                const armorBoostLevel = getPassiveLevel('warrior', 4);
                if (armorBoostLevel > 0) {
                    defenseValue += Math.floor(getItemStatValue(Game.player.armor, "defenseFlat") * 0.15 * armorBoostLevel);
                }
                d = Math.floor(d * getDamageRatio(enemyAtk, defenseValue));
            }
            if (derived.totals.damageReduction > 0) {
                d = Math.floor(d * (1 - derived.totals.damageReduction / 100));
            }
            d = Math.floor(d * enemyStatusMods.damageDoneMul);
            d = Math.floor(d * playerStatusMods.damageTakenMul);
            d = Math.floor(d * getBossUniqueDamageTakenMultiplier({
                player: Game.player,
                enemy: Game.enemy,
                derived
            }));
            d = Math.max(1, d);
            const appliedDamage = applyDamage(Game.player, d, Game.enemy);
            if (label) {
                addLog(`${label}${appliedDamage}ãƒ€ãƒ¡`, logTone);
            }
            if (isCrit) {
                addLog("æ•µã®ä¼šå¿ƒï¼", "text-amber-400");
            }
            applyBossRushOnHitEffects(appliedDamage);
            return { appliedDamage, landedHit: true, isCrit };
        }

        function performBossRushCounterAttack(multiplier = BossRushBuffConfig.healCounterMultiplier, label = "åæ’ƒ") {
            if (Game.state !== 'combat' || !Game.enemy || Game.enemy.hp <= 0 || Game.player.hp <= 0) return;
            const derived = getDerivedStats();
            performEnemyPhysicalAttack({ derived, label: `${label}ï¼ `, damageMultiplier: multiplier, canMiss: false, logTone: "text-rose-400" });
        }

        function triggerBossRushHealReaction(healAmount, label = "å›å¾©åæ’ƒ") {
            if (Game.state !== 'combat' || !Game.enemy || healAmount <= 0) return;
            if (!hasBossRushBuff(Game.enemy, "br_yellow_heal_counter")) return;
            performBossRushCounterAttack(BossRushBuffConfig.healCounterMultiplier, label);
        }

        function triggerBossRushMistakeReaction() {
            if (Game.state !== 'combat' || !Game.enemy || !hasBossRushBuff(Game.enemy, "br_red_mistake")) return;
            performBossRushCounterAttack(BossRushBuffConfig.mistakeCounterMultiplier, "ãƒŸã‚¹åå¿œ");
        }

        function triggerBossRushDebuffReaction() {
            if (Game.state !== 'combat' || !Game.enemy || !hasBossRushBuff(Game.enemy, "br_yellow_debuff_counter")) return;
            performBossRushCounterAttack(BossRushBuffConfig.healCounterMultiplier, "ç•°å¸¸åæ’ƒ");
        }

        function applyAutoRegen() {
            const p = Game.player;
            const derived = getDerivedStats();
            if (p.hp <= 0) return;
            if (derived.totals.hpRegen > 0) {
                const beforeHp = p.hp;
                p.hp = Math.min(derived.maxHp, p.hp + derived.totals.hpRegen);
                const actual = p.hp - beforeHp;
                if (actual > 0) {
                    addLog(`è‡ªå‹•å›å¾©ã§HPãŒ${actual}å›å¾©`, "text-emerald-400");
                    triggerBossRushHealReaction(actual, "å›å¾©åæ’ƒ");
                }
            }
            if (derived.totals.mpRegen > 0) {
                const beforeMp = p.mp;
                p.mp = Math.min(derived.maxMp, p.mp + derived.totals.mpRegen);
                const actual = p.mp - beforeMp;
                if (actual > 0) {
                    addLog(`è‡ªå‹•å›å¾©ã§MPãŒ${actual}å›å¾©`, "text-blue-400");
                }
            }
            if (Array.isArray(p.statusEffects)) {
                p.statusEffects.forEach(effect => {
                    const def = StatusDefs[effect.id];
                    if (!def || def.effectType !== 'regen') return;
                    const stacks = Math.max(1, effect.stacks || 1);
                    const amount = (def.regenPerStack || 0) * stacks;
                    if (amount <= 0) return;
                    if (def.resource === 'hp') {
                        const beforeHp = p.hp;
                        p.hp = Math.min(derived.maxHp, p.hp + amount);
                        const actual = p.hp - beforeHp;
                        if (actual > 0) {
                            addLog(`å†ç”ŸåŠ¹æœã§HPãŒ${actual}å›å¾©`, "text-emerald-400");
                            triggerBossRushHealReaction(actual, "å›å¾©åæ’ƒ");
                        }
                    }
                    if (def.resource === 'mp') {
                        const beforeMp = p.mp;
                        p.mp = Math.min(derived.maxMp, p.mp + amount);
                        const actual = p.mp - beforeMp;
                        if (actual > 0) {
                            addLog(`å†ç”ŸåŠ¹æœã§MPãŒ${actual}å›å¾©`, "text-blue-400");
                            triggerBossRushHealReaction(actual, "å›å¾©åæ’ƒ");
                        }
                    }
                });
            }
        }

        function cleanseStatusEffects(target, count) {
            if (!target || !Array.isArray(target.statusEffects) || count <= 0) return 0;
            let remaining = count;
            const removed = [];
            target.statusEffects = target.statusEffects.filter(effect => {
                if (remaining > 0 && NegativeStatusEffectIds.has(effect.id)) {
                    remaining -= 1;
                    removed.push(effect);
                    return false;
                }
                return true;
            });
            return removed.length;
        }

        function restorePotionCapacity(potion) {
            if (!potion) return;
            const derived = syncPotionCapacity(potion);
            potion.currentCapacity = Math.min(derived.maxCapacity, potion.currentCapacity + derived.chargeOnKill);
        }

        function usePotion(slotIndex) {
            if (Game.state === 'dead') return;
            const slotKey = slotIndex === 0 ? 'potion1' : 'potion2';
            const potion = Game.player[slotKey];
            if (!potion) {
                addLog("ãƒãƒ¼ã‚·ãƒ§ãƒ³ãŒæœªè£…å‚™", "text-slate-400");
                return;
            }
            const potionDerived = syncPotionCapacity(potion);
            const potionEffectMultiplier = Game.isBossRush ? 0.5 : 1;
            if (potion.currentCapacity < potionDerived.cost) {
                addLog("ãƒãƒ¼ã‚·ãƒ§ãƒ³å®¹é‡ãŒè¶³ã‚Šãªã„ï¼", "text-slate-400");
                return;
            }
            potion.currentCapacity -= potionDerived.cost;
            const derived = getDerivedStats();
            const calcPotionHeal = (maxValue, currentValue) => {
                if (potion.healMode === "missing") {
                    const missingValue = Math.max(0, maxValue - currentValue);
                    return potionDerived.healFlat + Math.floor(missingValue * (potionDerived.healPct / 100));
                }
                if (potion.healMode === "hybridCap") {
                    const total = potionDerived.healFlat + Math.floor(maxValue * (potionDerived.healPct / 100));
                    if (Number.isFinite(potion.healCapPct)) {
                        const cap = Math.floor(maxValue * (potion.healCapPct / 100));
                        return Math.min(total, cap);
                    }
                    return total;
                }
                return potionDerived.healPct > 0
                    ? Math.floor(maxValue * (potionDerived.healPct / 100))
                    : potionDerived.healFlat;
            };
            if (potion.target === 'hp') {
                const before = Game.player.hp;
                const baseHeal = calcPotionHeal(derived.maxHp, Game.player.hp);
                const healAmount = Math.floor(baseHeal * potionEffectMultiplier);
                Game.player.hp = Math.min(derived.maxHp, Game.player.hp + healAmount);
                const actual = Game.player.hp - before;
                if (actual > 0) {
                    addLog(`HPãƒãƒ¼ã‚·ãƒ§ãƒ³ï¼ ${actual}å›å¾©`, "text-emerald-500");
                    dmgText(actual, true);
                    triggerBossRushHealReaction(actual, "å›å¾©åæ’ƒ");
                    if (potionDerived.resonance > 0) {
                        const beforeMp = Game.player.mp;
                        const bonus = Math.floor(actual * 0.5);
                        Game.player.mp = Math.min(derived.maxMp, Game.player.mp + bonus);
                        const mpActual = Game.player.mp - beforeMp;
                        if (mpActual > 0) {
                            addLog(`å…±é³´ã§MPãŒ${mpActual}å›å¾©`, "text-blue-400");
                        }
                    }
                } else {
                    addLog("HPãƒãƒ¼ã‚·ãƒ§ãƒ³ï¼ ã“ã‚Œä»¥ä¸Šå›å¾©ã§ããªã„", "text-slate-400");
                }
            }
            if (potion.target === 'mp') {
                const before = Game.player.mp;
                const baseHeal = calcPotionHeal(derived.maxMp, Game.player.mp);
                const healAmount = Math.floor(baseHeal * potionEffectMultiplier);
                Game.player.mp = Math.min(derived.maxMp, Game.player.mp + healAmount);
                const actual = Game.player.mp - before;
                if (actual > 0) {
                    addLog(`MPãƒãƒ¼ã‚·ãƒ§ãƒ³ï¼ ${actual}å›å¾©`, "text-blue-500");
                    triggerBossRushHealReaction(actual, "å›å¾©åæ’ƒ");
                    if (potionDerived.resonance > 0) {
                        const beforeHp = Game.player.hp;
                        const bonus = Math.floor(actual * 0.5);
                        Game.player.hp = Math.min(derived.maxHp, Game.player.hp + bonus);
                        const hpActual = Game.player.hp - beforeHp;
                        if (hpActual > 0) {
                            addLog(`å…±é³´ã§HPãŒ${hpActual}å›å¾©`, "text-emerald-400");
                            triggerBossRushHealReaction(hpActual, "å›å¾©åæ’ƒ");
                        }
                    }
                } else {
                    addLog("MPãƒãƒ¼ã‚·ãƒ§ãƒ³ï¼ ã“ã‚Œä»¥ä¸Šå›å¾©ã§ããªã„", "text-slate-400");
                }
            }
            const cleanseCount = Math.floor(potionDerived.cleanse * potionEffectMultiplier);
            if (cleanseCount > 0) {
                const removed = cleanseStatusEffects(Game.player, cleanseCount);
                if (removed > 0) {
                    addLog(`çŠ¶æ…‹ç•°å¸¸ã‚’${removed}å€‹å›å¾©`, "text-purple-400");
                }
            }
            const autoRegenStacks = Math.floor(potionDerived.autoRegen * potionEffectMultiplier);
            if (autoRegenStacks > 0) {
                const regenId = potion.target === 'mp' ? 'potionRegenMp' : 'potionRegenHp';
                applyStatusEffect(Game.player, regenId, autoRegenStacks);
                addLog("å†ç”ŸåŠ¹æœã‚’ä»˜ä¸ï¼", "text-emerald-400");
            }
            const barrierStacks = Math.floor(potionDerived.barrier * potionEffectMultiplier);
            if (barrierStacks > 0) {
                applyStatusEffect(Game.player, 'barrier', barrierStacks);
                addLog("ãƒãƒªã‚¢ã‚’ä»˜ä¸ï¼", "text-sky-400");
            }
            const nextHitBoost = Math.floor(potionDerived.nextHitBoost * potionEffectMultiplier);
            if (nextHitBoost > 0) {
                applyStatusEffect(Game.player, 'potionNextHitBoost', 1);
                const effect = getStatusEffect(Game.player, 'potionNextHitBoost');
                if (effect) effect.bonusPct = Math.max(effect.bonusPct || 0, nextHitBoost);
                addLog("æ¬¡æ’ƒå¼·åŒ–ã‚’ä»˜ä¸ï¼", "text-amber-400");
            }
            const leechBoost = Math.floor(potionDerived.leechBoost * potionEffectMultiplier);
            if (leechBoost > 0) {
                applyStatusEffect(Game.player, 'potionLeechBoost', 1);
                const effect = getStatusEffect(Game.player, 'potionLeechBoost');
                if (effect) effect.bonusPct = Math.max(effect.bonusPct || 0, leechBoost);
                addLog("å¸åå¼·åŒ–ã‚’ä»˜ä¸ï¼", "text-emerald-400");
            }
            const reflectGuardStacks = Math.floor(potionDerived.reflectGuard * potionEffectMultiplier);
            if (reflectGuardStacks > 0) {
                applyStatusEffect(Game.player, 'potionReflectGuard', reflectGuardStacks);
                addLog("åå°„ç„¡åŠ¹ã‚’ä»˜ä¸ï¼", "text-slate-500");
            }
            const skillMpCut = Math.floor(potionDerived.skillMpCut * potionEffectMultiplier);
            if (skillMpCut > 0) {
                applyStatusEffect(Game.player, 'potionSkillMpCut', 1);
                const effect = getStatusEffect(Game.player, 'potionSkillMpCut');
                if (effect) effect.bonusPct = Math.max(effect.bonusPct || 0, skillMpCut);
                addLog("ç¯€é­”ã®åŠ è­·ï¼", "text-blue-400");
            }
            updateUI();
            triggerAutosave();
        }

        function advanceStatusEffects(target, phase) {
            if (!target || !Array.isArray(target.statusEffects)) return;
            target.statusEffects = target.statusEffects.filter(effect => effect.turns > 0);
            if (phase === 'start') {
                const isPlayer = target === Game.player;
                const targetLabel = isPlayer ? 'è‡ªåˆ†' : (target.name || 'æ•µ');
                const derived = isPlayer ? getDerivedStats() : null;
                const maxHp = isPlayer ? derived.maxHp : target.maxHp;
                const strValue = isPlayer ? derived.totals.str : (target.str || 0);
                const defenseValue = isPlayer ? derived.def : (target.def || 0);
                target.statusEffects.forEach(effect => {
                    const def = StatusDefs[effect.id];
                    if (!def) return;
                    if (def.effectType === 'poison') {
                        const stacks = Math.max(1, effect.stacks || 1);
                        const baseHp = maxHp || target.hp || 0;
                        const defenseMitigation = 1 / (1 + defenseValue / 200);
                        const minPctBonus = Number.isFinite(effect.poisonMinPctBonus) ? effect.poisonMinPctBonus : 0;
                        const minPct = 0.01 + Math.max(0, minPctBonus) / 100;
                        const scaledDamage = Math.max(1, Math.floor(baseHp * 0.03 * stacks * defenseMitigation));
                        const guaranteedDamage = Math.max(1, Math.floor(baseHp * minPct * stacks));
                        const dmg = Math.max(scaledDamage, guaranteedDamage);
                        const appliedDamage = applyDamage(target, dmg, null, { ignoreReflect: true });
                        addLog(`${targetLabel}ã¯æ¯’ã§${appliedDamage}ãƒ€ãƒ¡ãƒ¼ã‚¸`, "text-purple-400");
                        if (target === Game.enemy && hasBossUniqueEffect("poisonOverload")) {
                            if (stacks >= BossUniqueEffectConfig.poisonOverloadStacks) {
                                const overloadDamage = Math.max(1, Math.floor(baseHp * BossUniqueEffectConfig.poisonOverloadRate * stacks));
                                const overloadApplied = applyDamage(target, overloadDamage, Game.player, { ignoreBossRushNullify: true, ignoreBossRushDamageReduction: true, ignoreReflect: true });
                                addLog(`æ¯’éç©è¼‰ãŒçˆ†ç™ºï¼ ${overloadApplied}ãƒ€ãƒ¡ãƒ¼ã‚¸`, "text-amber-400");
                            }
                        }
                    }
                    if (def.effectType === 'bleed') {
                        const stacks = Math.max(1, effect.stacks || 1);
                        const sourceStr = Number.isFinite(effect.sourceStr) ? effect.sourceStr : strValue;
                        const defenseMitigation = 1 / (1 + defenseValue / 200);
                        const rawDamage = (2 + sourceStr * 0.3) * stacks;
                        const dmg = Math.max(1, Math.floor(rawDamage * defenseMitigation));
                        const appliedDamage = applyDamage(target, dmg, null, { ignoreReflect: true });
                        addLog(`${targetLabel}ã¯å‡ºè¡€ã§${appliedDamage}ãƒ€ãƒ¡ãƒ¼ã‚¸`, "text-purple-400");
                    }
                });
            }
            if (phase === 'end') {
                target.statusEffects.forEach(effect => {
                    effect.turns -= 1;
                });
                target.statusEffects = target.statusEffects.filter(effect => effect.turns > 0);
            }
        }

        function applyStatusEffect(target, effectId, stacks = 1, turns = null, source = null) {
            const def = StatusDefs[effectId];
            if (!def) return;
            const isEnemyTarget = target === Game.enemy;
            const isNegative = NegativeStatusEffectIds.has(effectId);
            if (isEnemyTarget && isNegative) {
                if (hasBossRushBuff(target, "br_orange_immune")) {
                    return;
                }
                if (source?.singleStatusRule) {
                    const existingNegative = (target.statusEffects || []).find((effect) => NegativeStatusEffectIds.has(effect.id));
                    if (existingNegative && existingNegative.id !== effectId) {
                        return;
                    }
                    if (def.stackable) {
                        stacks = Math.max(stacks, 2);
                    }
                }
                if (hasBossRushBuff(target, "br_yellow_status_limit")) {
                    const existingNegative = (target.statusEffects || []).find((effect) => NegativeStatusEffectIds.has(effect.id));
                    if (existingNegative && existingNegative.id !== effectId) {
                        return;
                    }
                }
                if (hasBossRushBuff(target, "br_yellow_debuff_counter")) {
                    const state = getBossRushBuffState(target);
                    if (hasBossRushBuff(target, "br_orange_gain") && state) {
                        state.statusBoostPct = Math.min(100, (state.statusBoostPct || 0) + BossRushBuffConfig.statusGainBoost * 100);
                    }
                    triggerBossRushDebuffReaction();
                    return;
                }
            }
            if (!Array.isArray(target.statusEffects)) {
                target.statusEffects = [];
            }
            const duration = turns ?? def.defaultTurns ?? 1;
            const bonusMaxStacks = def.effectType === 'poison'
                ? (Number.isFinite(source?.poisonMaxStacksBonus) ? source.poisonMaxStacksBonus : 0)
                : 0;
            const unlimitedPoisonStacks = def.effectType === 'poison' && source?.poisonUnlimited ? 999 : 0;
            const maxStacks = def.effectType === 'poison'
                ? (def.maxStacks ?? stacks) + Math.max(0, bonusMaxStacks) + unlimitedPoisonStacks
                : (def.maxStacks ?? stacks);
            const existing = target.statusEffects.find(effect => effect.id === effectId);
            if (existing) {
                if (def.stackable) {
                    existing.stacks = Math.min(maxStacks, existing.stacks + stacks);
                } else {
                    existing.stacks = 1;
                }
                existing.turns = Math.max(existing.turns, duration);
                if (Number.isFinite(source?.sourceStr)) {
                    existing.sourceStr = source.sourceStr;
                }
                if (Number.isFinite(source?.poisonMinPctBonus)) {
                    existing.poisonMinPctBonus = source.poisonMinPctBonus;
                }
                if (def.effectType === 'barrier') {
                    const perStack = def.shieldPerStack || 0;
                    existing.shield = (existing.shield || 0) + perStack * stacks;
                    const maxShield = perStack * (existing.stacks || 1);
                    if (maxShield > 0) {
                        existing.shield = Math.min(maxShield, existing.shield);
                    }
                }
            } else {
                const entry = {
                    id: effectId,
                    stacks: def.stackable ? Math.min(maxStacks, stacks) : 1,
                    turns: duration
                };
                if (Number.isFinite(source?.sourceStr)) {
                    entry.sourceStr = source.sourceStr;
                }
                if (Number.isFinite(source?.poisonMinPctBonus)) {
                    entry.poisonMinPctBonus = source.poisonMinPctBonus;
                }
                if (def.effectType === 'barrier') {
                    const perStack = def.shieldPerStack || 0;
                    entry.shield = perStack * entry.stacks;
                }
                target.statusEffects.push(entry);
            }
            if (isEnemyTarget && isNegative && hasBossRushBuff(target, "br_orange_gain")) {
                const state = getBossRushBuffState(target);
                if (state) {
                    state.statusBoostPct = Math.min(100, (state.statusBoostPct || 0) + BossRushBuffConfig.statusGainBoost * 100);
                }
            }
        }

        function tickFreezeDecay(target) {
            if (!target || !Number.isFinite(target.freezeDecayTimer)) return;
            target.freezeDecayTimer = Math.max(0, target.freezeDecayTimer - 1);
            if (target.freezeDecayTimer === 0) {
                target.freezeChain = 0;
            }
        }

        function tickFreezeDecayForCombatants() {
            tickFreezeDecay(Game.player);
            if (Game.enemy) {
                tickFreezeDecay(Game.enemy);
            }
        }

        function getFreezeDecayChance(target, baseChance = 1) {
            const chain = Math.max(0, target?.freezeChain || 0);
            const decayed = baseChance * (FreezeDecayConfig.multiplier ** chain);
            return Math.max(0, Math.min(1, decayed));
        }

        function recordFreezeApplied(target) {
            if (!target) return;
            target.freezeChain = Math.max(0, target.freezeChain || 0) + 1;
            target.freezeDecayTimer = FreezeDecayConfig.windowTurns;
        }

        const infoModal = document.getElementById('status-info-modal');
        const openInfoModal = () => {
            infoModal.classList.remove('hidden');
            infoModal.classList.add('flex');
        };
        const closeInfoModal = () => {
            infoModal.classList.add('hidden');
            infoModal.classList.remove('flex');
        };
        document.getElementById('secondary-info-btn').addEventListener('click', openInfoModal);
        document.getElementById('status-info-close').addEventListener('click', closeInfoModal);
        document.getElementById('status-info-close-bottom').addEventListener('click', closeInfoModal);
        infoModal.addEventListener('click', (event) => {
            if (event.target === infoModal) closeInfoModal();
        });

        const statusEffectModal = document.getElementById('status-effect-modal');
        const statusEffectTitle = document.getElementById('status-effect-title');
        const statusEffectDesc = document.getElementById('status-effect-desc');
        const statusEffectStacks = document.getElementById('status-effect-stacks');
        const statusEffectTurns = document.getElementById('status-effect-turns');
        const openStatusEffectModal = (def, effect) => {
            if (!def || !effect) return;
            statusEffectTitle.innerHTML = `<i class="fa-solid ${def.icon} text-slate-500"></i> ${def.name}`;
            statusEffectDesc.textContent = def.desc || 'åŠ¹æœèª¬æ˜ãŒã‚ã‚Šã¾ã›ã‚“ã€‚';
            statusEffectStacks.textContent = `ã‚¹ã‚¿ãƒƒã‚¯: ${effect.stacks || 1}`;
            const turnsText = Number.isFinite(effect.turns) ? effect.turns : 'âˆ';
            statusEffectTurns.textContent = `æ®‹ã‚Šã‚¿ãƒ¼ãƒ³: ${turnsText}`;
            statusEffectModal.classList.remove('hidden');
            statusEffectModal.classList.add('flex');
        };
        const closeStatusEffectModal = () => {
            statusEffectModal.classList.add('hidden');
            statusEffectModal.classList.remove('flex');
        };
        document.getElementById('status-effect-close').addEventListener('click', closeStatusEffectModal);
        document.getElementById('status-effect-close-bottom').addEventListener('click', closeStatusEffectModal);
        statusEffectModal.addEventListener('click', (event) => {
            if (event.target === statusEffectModal) closeStatusEffectModal();
        });

        const skillDetailModal = document.getElementById('skill-detail-modal');
        const skillDetailTitle = document.getElementById('skill-detail-title');
        const skillDetailMeta = document.getElementById('skill-detail-meta');
        const skillDetailDesc = document.getElementById('skill-detail-desc');
        const skillDetailStats = document.getElementById('skill-detail-stats');
        const skillDetailEffects = document.getElementById('skill-detail-effects');
        const skillDetailMilestones = document.getElementById('skill-detail-milestones');
        const openSkillDetailModal = (job, type, idx, level) => {
            const base = JobData[job][type][idx];
            if (!base) return;
            const maxLevel = base.maxLevel || SkillMaxLevel;
            const currentLevel = Math.max(0, level || 0);
            const label = type === 'active' ? 'ã‚¢ã‚¯ãƒ†ã‚£ãƒ–' : 'ãƒ‘ãƒƒã‚·ãƒ–';
            const displaySkill = type === 'active'
                ? buildActiveSkill(job, idx, Math.max(1, currentLevel || 1))
                : base;
            skillDetailTitle.innerHTML = `<i class="fas fa-circle-info text-slate-500"></i> ${displaySkill.name}`;
            skillDetailMeta.textContent = `${label} / Lv ${currentLevel}/${maxLevel}`;
            skillDetailDesc.textContent = displaySkill.desc || 'èª¬æ˜ãŒã‚ã‚Šã¾ã›ã‚“ã€‚';

            const stats = [];
            if (type === 'active') {
                if (displaySkill.mp !== undefined) stats.push(`MPæ¶ˆè²»: ${displaySkill.mp}`);
                if (displaySkill.pow !== undefined) stats.push(`å¨åŠ›å€ç‡: ${displaySkill.pow}`);
                if (displaySkill.hits) stats.push(`ãƒ’ãƒƒãƒˆæ•°: ${displaySkill.hits}`);
                if (displaySkill.accuracyBonus) stats.push(`å‘½ä¸­è£œæ­£: +${displaySkill.accuracyBonus}%`);
                if (displaySkill.critBonus) stats.push(`ä¼šå¿ƒè£œæ­£: +${displaySkill.critBonus}%`);
                if (displaySkill.mpHeal) stats.push(`MPå¸åç‡: ${Math.round(displaySkill.mpHeal * 100)}%`);
                if (displaySkill.expBonus) stats.push(`è¿½åŠ EXP: +${displaySkill.expBonus}%`);
                if (displaySkill.leech) stats.push(`å¸è¡€ç‡: ${displaySkill.leech}%`);
                if (displaySkill.hpCost) stats.push(`HPæ¶ˆè²»: ${Math.round(displaySkill.hpCost * 100)}%`);
                if (displaySkill.type === 'heal') stats.push('åŠ¹æœ: å›å¾©');
            } else if (base.apply) {
                stats.push('åŠ¹æœ: å¸¸æ™‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¼·åŒ–');
            } else if (base.logic) {
                stats.push('åŠ¹æœ: æ¡ä»¶ä»˜ããƒœãƒ¼ãƒŠã‚¹');
            }
            skillDetailStats.innerHTML = stats.length
                ? stats.map((line) => `<div>${line}</div>`).join('')
                : '<div>æ•°å€¤æƒ…å ±ãªã—</div>';

            const effectLines = [];
            if (type === 'active' && Array.isArray(displaySkill.effects) && displaySkill.effects.length > 0) {
                displaySkill.effects.forEach((effect) => {
                    const def = StatusDefs[effect.id];
                    const name = def ? def.name : effect.id;
                    const target = effect.target === 'self' ? 'è‡ªåˆ†' : 'æ•µ';
                    const stacks = effect.stacks ?? 1;
                    const turns = effect.turns ?? def?.defaultTurns ?? 1;
                    effectLines.push(`${target}: ${name} ${stacks}ã‚¹ã‚¿ãƒƒã‚¯ / ${turns}ã‚¿ãƒ¼ãƒ³`);
                });
            }
            skillDetailEffects.innerHTML = effectLines.length
                ? effectLines.map((line) => `<div>${line}</div>`).join('')
                : '<div>è¿½åŠ åŠ¹æœãªã—</div>';

            const milestoneLines = [];
            if (type === 'active') {
                const hasEffects = Array.isArray(base.effects) && base.effects.length > 0;
                const hasEnemyEffect = hasEffects && base.effects.some((effect) => effect.target !== 'self');
                const hasSelfEffect = hasEffects && base.effects.some((effect) => effect.target === 'self');
                SkillMilestoneLevels.forEach((threshold) => {
                    const reached = currentLevel >= threshold;
                    let detail = '';
                    if (threshold === 10) {
                        if (hasEffects) {
                            detail = 'æ—¢å­˜åŠ¹æœã®ã‚¹ã‚¿ãƒƒã‚¯+1';
                        } else if (displaySkill.type === 'heal') {
                            detail = 'è¿½åŠ åŠ¹æœãªã—';
                        } else {
                            detail = 'å‘½ä¸­+5%';
                        }
                    }
                    if (threshold === 30) {
                        if (hasEffects) {
                            detail = 'æ—¢å­˜åŠ¹æœã®ç¶™ç¶š+1ã‚¿ãƒ¼ãƒ³';
                        } else if (displaySkill.type === 'heal') {
                            detail = 'è¿½åŠ åŠ¹æœãªã—';
                        } else {
                            detail = 'ä¼šå¿ƒ+5%';
                        }
                    }
                    if (threshold === 50) {
                        if (displaySkill.type === 'heal') {
                            detail = 'å†ç”Ÿ(HP/MP)ä»˜ä¸ + ãƒãƒªã‚¢å¼·åŒ–';
                        } else if (hasEnemyEffect) {
                            detail = displaySkill.isMagic ? 'æ•µã«å¼±ä½“ã‚’è¿½åŠ ' : 'æ•µã«è„†å¼±ã‚’è¿½åŠ ';
                        } else if (hasSelfEffect) {
                            detail = 'è‡ªå·±å¼·åŒ–(é—˜å¿—) + è¿…é€Ÿä»˜ä¸';
                        } else {
                            detail = 'å¨åŠ›+20% / ãƒ’ãƒƒãƒˆ+1 / è‡ªå·±å¼·åŒ–ä»˜ä¸';
                        }
                    }
                    if (threshold === 70) {
                        detail = hasEffects ? 'æ—¢å­˜åŠ¹æœã®ã‚¹ã‚¿ãƒƒã‚¯+1' : 'å‘½ä¸­+5%';
                    }
                    if (threshold === 100) {
                        detail = hasEffects ? 'æ—¢å­˜åŠ¹æœã®ç¶™ç¶š+1ã‚¿ãƒ¼ãƒ³' : 'ä¼šå¿ƒ+5%';
                    }
                    if (threshold === 150) {
                        if (displaySkill.type === 'heal') {
                            detail = 'å†ç”Ÿ(HP/MP)ä»˜ä¸ + ãƒãƒªã‚¢å¼·åŒ–';
                        } else if (hasEffects) {
                            detail = displaySkill.isMagic ? 'æ•µã«å¼·åŒ–å¼±ä½“ã‚’è¿½åŠ ' : 'æ•µã«å¼·åŒ–è„†å¼±ã‚’è¿½åŠ ';
                        } else {
                            detail = 'å¨åŠ›+35% / ãƒ’ãƒƒãƒˆ+1 / è‡ªå·±å¼·åŒ–ä»˜ä¸';
                        }
                    }
                    if (threshold === 70) {
                        detail = hasEffects ? 'æ—¢å­˜åŠ¹æœã®ã‚¹ã‚¿ãƒƒã‚¯+1' : 'å‘½ä¸­+5%';
                    }
                    if (threshold === 100) {
                        detail = hasEffects ? 'æ—¢å­˜åŠ¹æœã®ç¶™ç¶š+1ã‚¿ãƒ¼ãƒ³' : 'ä¼šå¿ƒ+5%';
                    }
                    if (threshold === 150) {
                        if (displaySkill.type === 'heal') {
                            detail = 'å†ç”Ÿ(HP/MP)ä»˜ä¸ + ãƒãƒªã‚¢å¼·åŒ–';
                        } else if (hasEffects) {
                            detail = displaySkill.isMagic ? 'æ•µã«å¼·åŒ–å¼±ä½“ã‚’è¿½åŠ ' : 'æ•µã«å¼·åŒ–è„†å¼±ã‚’è¿½åŠ ';
                        } else {
                            detail = 'å¨åŠ›+35% / ãƒ’ãƒƒãƒˆ+1 / è‡ªå·±å¼·åŒ–ä»˜ä¸';
                        }
                    }
                    milestoneLines.push(`${reached ? 'â˜…' : 'â˜†'} Lv${threshold}: ${detail}`);
                });
            } else {
                const milestone = PassiveMilestoneBonuses?.[job]?.[idx] || {};
                SkillMilestoneLevels.forEach((threshold) => {
                    const reached = currentLevel >= threshold;
                    const milestoneKey = PassiveMilestoneKeyMap[threshold] ?? threshold;
                    const statsBonus = milestone[milestoneKey]?.stats;
                    const detail = statsBonus
                        ? Object.entries(statsBonus).map(([key, value]) => {
                            const labelText = StatLabels[key] || key;
                            const suffix = PercentStats.has(key) ? '%' : '';
                            return `${labelText}+${value}${suffix}`;
                        }).join(' / ')
                        : 'è¿½åŠ åŠ¹æœãªã—';
                    milestoneLines.push(`${reached ? 'â˜…' : 'â˜†'} Lv${threshold}: ${detail}`);
                });
            }
            skillDetailMilestones.innerHTML = milestoneLines.length
                ? milestoneLines.map((line) => `<div>${line}</div>`).join('')
                : '<div>ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ãªã—</div>';

            skillDetailModal.classList.remove('hidden');
            skillDetailModal.classList.add('flex');
        };
        const closeSkillDetailModal = () => {
            skillDetailModal.classList.add('hidden');
            skillDetailModal.classList.remove('flex');
        };
        document.getElementById('skill-detail-close').addEventListener('click', closeSkillDetailModal);
        document.getElementById('skill-detail-close-bottom').addEventListener('click', closeSkillDetailModal);
        skillDetailModal.addEventListener('click', (event) => {
            if (event.target === skillDetailModal) closeSkillDetailModal();
        });
        const skillResetButton = document.getElementById('skill-reset-btn');
        if (skillResetButton) {
            skillResetButton.addEventListener('click', resetSkillAllocation);
        }
        const skillPointModeButton = document.getElementById('skill-point-mode');
        if (skillPointModeButton) {
            skillPointModeButton.addEventListener('click', cycleSkillPointMode);
        }

        const lootFilterModal = document.getElementById('loot-filter-modal');
        const lootFilterOpenBtn = document.getElementById('loot-filter-open');
        const lootFilterCloseBtn = document.getElementById('loot-filter-close');
        const lootFilterCloseBottomBtn = document.getElementById('loot-filter-close-bottom');
        const lootFilterCheckboxes = Array.from(document.querySelectorAll('.loot-filter-checkbox'));

        const syncLootFilterUI = () => {
            lootFilterCheckboxes.forEach((checkbox) => {
                const rarity = checkbox.dataset.rarity;
                checkbox.checked = Boolean(Game.lootFilter?.[rarity]);
            });
        };

        const openLootFilterModal = () => {
            syncLootFilterUI();
            lootFilterModal.classList.remove('hidden');
            lootFilterModal.classList.add('flex');
        };

        const closeLootFilterModal = () => {
            lootFilterModal.classList.add('hidden');
            lootFilterModal.classList.remove('flex');
        };

        lootFilterOpenBtn.addEventListener('click', openLootFilterModal);
        lootFilterCloseBtn.addEventListener('click', closeLootFilterModal);
        lootFilterCloseBottomBtn.addEventListener('click', closeLootFilterModal);
        lootFilterModal.addEventListener('click', (event) => {
            if (event.target === lootFilterModal) closeLootFilterModal();
        });
        lootFilterCheckboxes.forEach((checkbox) => {
            checkbox.addEventListener('change', (event) => {
                const rarity = event.target.dataset.rarity;
                Game.lootFilter[rarity] = event.target.checked;
            });
        });

        const bulkSellModal = document.getElementById('bulk-sell-modal');
        const bulkSellOpenBtn = document.getElementById('bulk-sell-open');
        const bulkSellCloseBtn = document.getElementById('bulk-sell-close');
        const bulkSellCloseBottomBtn = document.getElementById('bulk-sell-close-bottom');
        const bulkSellConfirmBtn = document.getElementById('bulk-sell-confirm');
        const bulkSellCheckboxes = Array.from(document.querySelectorAll('.bulk-sell-checkbox'));

        const syncBulkSellUI = () => {
            bulkSellCheckboxes.forEach((checkbox) => {
                const rarity = checkbox.dataset.rarity;
                checkbox.checked = Boolean(Game.bulkSellFilter?.[rarity]);
            });
        };

        const openBulkSellModal = () => {
            syncBulkSellUI();
            bulkSellModal.classList.remove('hidden');
            bulkSellModal.classList.add('flex');
        };

        const closeBulkSellModal = () => {
            bulkSellModal.classList.add('hidden');
            bulkSellModal.classList.remove('flex');
        };

        bulkSellOpenBtn.addEventListener('click', openBulkSellModal);
        bulkSellCloseBtn.addEventListener('click', closeBulkSellModal);
        bulkSellCloseBottomBtn.addEventListener('click', closeBulkSellModal);
        bulkSellModal.addEventListener('click', (event) => {
            if (event.target === bulkSellModal) closeBulkSellModal();
        });
        bulkSellCheckboxes.forEach((checkbox) => {
            checkbox.addEventListener('change', (event) => {
                const rarity = event.target.dataset.rarity;
                Game.bulkSellFilter[rarity] = event.target.checked;
            });
        });
        bulkSellConfirmBtn.addEventListener('click', () => {
            const selected = bulkSellCheckboxes
                .filter((checkbox) => checkbox.checked)
                .map((checkbox) => checkbox.dataset.rarity);
            closeBulkSellModal();
            bulkSellByRarity(selected);
        });

        const equipSlotModal = document.getElementById('equip-slot-modal');
        const equipSlotTitle = document.getElementById('equip-slot-title');
        const equipSlotLabel1 = document.getElementById('equip-slot-1-label');
        const equipSlotLabel2 = document.getElementById('equip-slot-2-label');
        const equipSlotButton1 = document.getElementById('equip-slot-1');
        const equipSlotButton2 = document.getElementById('equip-slot-2');
        const equipSlotCompare1 = document.getElementById('equip-slot-1-compare');
        const equipSlotCompare2 = document.getElementById('equip-slot-2-compare');
        const closeEquipSlotModal = () => {
            equipSlotModal.classList.add('hidden');
            equipSlotModal.classList.remove('flex');
            Game.pendingEquip = null;
        };
        const openEquipSlotModal = (item, idx) => {
            if (!item) return;
            const isPotion = item.type === 'potion';
            const titleIcon = isPotion ? 'fa-flask' : 'fa-gem';
            equipSlotTitle.innerHTML = `<i class="fas ${titleIcon} text-slate-500"></i> è£…å‚™ã‚¹ãƒ­ãƒƒãƒˆé¸æŠ`;
            const slot1Item = isPotion ? Game.player.potion1 : Game.player.accessory1;
            const slot2Item = isPotion ? Game.player.potion2 : Game.player.accessory2;
            const slotLabel = isPotion ? 'ãƒãƒ¼ã‚·ãƒ§ãƒ³' : 'è£…é£¾å“';
            const label1 = slot1Item ? slot1Item.name : 'ç©ºã';
            const label2 = slot2Item ? slot2Item.name : 'ç©ºã';
            equipSlotLabel1.innerHTML = `<span>${slotLabel}1</span><span class="text-[10px] text-slate-400 truncate">${label1}</span>`;
            equipSlotLabel2.innerHTML = `<span>${slotLabel}2</span><span class="text-[10px] text-slate-400 truncate">${label2}</span>`;
            Game.pendingEquip = { idx, itemType: item.type };
            const compareDisabledClass = 'text-slate-300 border-slate-200 bg-slate-100 cursor-not-allowed';
            const compareEnabledClass = 'text-slate-600 border-slate-200 bg-white';
            const canCompare1 = Boolean(slot1Item);
            const canCompare2 = Boolean(slot2Item);
            equipSlotCompare1.disabled = !canCompare1;
            equipSlotCompare2.disabled = !canCompare2;
            equipSlotCompare1.className = `w-full border font-black py-2 rounded-2xl shadow text-[11px] flex items-center justify-center gap-2 ${canCompare1 ? compareEnabledClass : compareDisabledClass}`;
            equipSlotCompare2.className = `w-full border font-black py-2 rounded-2xl shadow text-[11px] flex items-center justify-center gap-2 ${canCompare2 ? compareEnabledClass : compareDisabledClass}`;
            equipSlotModal.classList.remove('hidden');
            equipSlotModal.classList.add('flex');
        };
        const equipToSlot = (slotNumber) => {
            const pending = Game.pendingEquip;
            if (!pending) return;
            const item = Game.player.inventory[pending.idx];
            if (!item || isItemEquipped(item)) {
                closeEquipSlotModal();
                return;
            }
            if (pending.itemType === 'accessory') {
                const slotKey = slotNumber === 1 ? 'accessory1' : 'accessory2';
                Game.player[slotKey] = item;
            }
            if (pending.itemType === 'potion') {
                const slotKey = slotNumber === 1 ? 'potion1' : 'potion2';
                Game.player[slotKey] = item;
                syncPotionCapacity(item);
            }
            closeEquipSlotModal();
            updateUI();
            triggerAutosave();
        };
        const compareToSlot = (slotNumber) => {
            const pending = Game.pendingEquip;
            if (!pending) return;
            const item = Game.player.inventory[pending.idx];
            if (!item) {
                closeEquipSlotModal();
                return;
            }
            const slotKey = pending.itemType === 'potion'
                ? (slotNumber === 1 ? 'potion1' : 'potion2')
                : (slotNumber === 1 ? 'accessory1' : 'accessory2');
            const equippedItem = Game.player[slotKey];
            if (!equippedItem) return;
            closeEquipSlotModal();
            openCompareModal(pending.idx, slotKey);
        };
        equipSlotButton1.addEventListener('click', () => equipToSlot(1));
        equipSlotButton2.addEventListener('click', () => equipToSlot(2));
        equipSlotCompare1.addEventListener('click', () => compareToSlot(1));
        equipSlotCompare2.addEventListener('click', () => compareToSlot(2));
        document.getElementById('equip-slot-close').addEventListener('click', closeEquipSlotModal);
        document.getElementById('equip-slot-close-bottom').addEventListener('click', closeEquipSlotModal);
        equipSlotModal.addEventListener('click', (event) => {
            if (event.target === equipSlotModal) closeEquipSlotModal();
        });

        const compareModal = document.getElementById('compare-modal');
        const compareModalCloseBtn = document.getElementById('compare-modal-close');
        const compareModalCloseBottomBtn = document.getElementById('compare-modal-close-bottom');
        const compareModalEquipBtn = document.getElementById('compare-modal-equip');
        const compareModalIncrease = document.getElementById('compare-modal-increase');
        const compareModalDecrease = document.getElementById('compare-modal-decrease');
        const compareModalEquipped = document.getElementById('compare-modal-equipped');
        const compareModalCandidate = document.getElementById('compare-modal-candidate');
        const closeCompareModal = () => {
            compareModal.classList.add('hidden');
            compareModal.classList.remove('flex');
            Game.compareModal = null;
        };
        const openCompareModal = (idx, slotKey = null) => {
            const item = Game.player.inventory[idx];
            if (!item) return;
            const equippedItem = slotKey ? Game.player[slotKey] : Game.player[item.type];
            if (!equippedItem) return;
            const candidateTotals = sumStats(getItemStats(item));
            const equippedTotals = sumStats(getItemStats(equippedItem));
            const keys = new Set([...Object.keys(candidateTotals), ...Object.keys(equippedTotals)]);
            const increases = [];
            const decreases = [];
            keys.forEach((key) => {
                const diff = (candidateTotals[key] || 0) - (equippedTotals[key] || 0);
                if (diff > 0) increases.push({ key, value: diff });
                if (diff < 0) decreases.push({ key, value: diff });
            });
            const formatDiffLines = (items, colorClass, sign) => {
                if (!items.length) {
                    return `<div class="text-[10px] text-slate-300 font-bold">å¤‰åŒ–ãªã—</div>`;
                }
                return items
                    .map((stat) => {
                        const label = StatLabels[stat.key] || stat.key;
                        const suffix = PercentStats.has(stat.key) ? '%' : '';
                        const value = Math.abs(stat.value);
                        return `<div class="text-[10px] ${colorClass} font-bold">${label} ${sign}${value}${suffix}</div>`;
                    })
                    .join('');
            };
            compareModalIncrease.innerHTML = formatDiffLines(increases, 'text-emerald-600', '+');
            compareModalDecrease.innerHTML = formatDiffLines(decreases, 'text-rose-600', '-');
            compareModalEquipped.textContent = equippedItem.name;
            compareModalCandidate.textContent = item.name;
            Game.compareModal = { idx, slotKey };
            compareModal.classList.remove('hidden');
            compareModal.classList.add('flex');
        };
        const equipItemToSlotKey = (item, slotKey) => {
            if (!item || !slotKey) return;
            Game.player[slotKey] = item;
            if (slotKey === 'potion1' || slotKey === 'potion2') {
                syncPotionCapacity(item);
            }
            updateUI();
            triggerAutosave();
        };
        compareModalEquipBtn.addEventListener('click', () => {
            const context = Game.compareModal;
            if (!context) {
                closeCompareModal();
                return;
            }
            const item = Game.player.inventory[context.idx];
            if (!item) {
                closeCompareModal();
                return;
            }
            if (context.slotKey) {
                equipItemToSlotKey(item, context.slotKey);
            } else if (['accessory', 'potion'].includes(item.type)) {
                openEquipSlotModal(item, context.idx);
            } else {
                equipItemToSlotKey(item, item.type);
            }
            closeCompareModal();
        });
        compareModalCloseBtn.addEventListener('click', closeCompareModal);
        compareModalCloseBottomBtn.addEventListener('click', closeCompareModal);
        compareModal.addEventListener('click', (event) => {
            if (event.target === compareModal) closeCompareModal();
        });

        const bossRushModal = document.getElementById('bossrush-modal');
        const bossRushCloseBtn = document.getElementById('bossrush-modal-close');
        const bossRushOkBtn = document.getElementById('bossrush-modal-ok');
        const closeBossRushModal = () => {
            if (!bossRushModal) return;
            bossRushModal.classList.add('hidden');
            bossRushModal.classList.remove('flex');
        };
        const openBossRushModal = () => {
            if (!bossRushModal) return;
            bossRushModal.classList.remove('hidden');
            bossRushModal.classList.add('flex');
        };
        bossRushCloseBtn.addEventListener('click', closeBossRushModal);
        bossRushOkBtn.addEventListener('click', closeBossRushModal);
        bossRushModal.addEventListener('click', (event) => {
            if (event.target === bossRushModal) closeBossRushModal();
        });

        const confirmModal = document.getElementById('confirm-modal');
        const confirmModalMessage = document.getElementById('confirm-modal-message');
        const confirmModalOk = document.getElementById('confirm-modal-ok');
        const confirmModalCancel = document.getElementById('confirm-modal-cancel');
        let confirmModalAction = null;

        const closeConfirmModal = () => {
            if (!confirmModal) return;
            confirmModal.classList.add('hidden');
            confirmModal.classList.remove('flex');
            confirmModalAction = null;
        };

        const openConfirmModal = (message, onConfirm) => {
            if (!confirmModal) return;
            if (confirmModalMessage) confirmModalMessage.textContent = message;
            confirmModalAction = typeof onConfirm === 'function' ? onConfirm : null;
            confirmModal.classList.remove('hidden');
            confirmModal.classList.add('flex');
        };

        confirmModalOk.addEventListener('click', () => {
            if (confirmModalAction) confirmModalAction();
            closeConfirmModal();
        });
        confirmModalCancel.addEventListener('click', closeConfirmModal);
        confirmModal.addEventListener('click', (event) => {
            if (event.target === confirmModal) closeConfirmModal();
        });

        const enhanceModal = document.getElementById('enhance-modal');
        const enhanceModalCloseBtn = document.getElementById('enhance-modal-close');
        const enhanceModalStartBtn = document.getElementById('enhance-modal-start');
        const enhanceModalRepeatBtn = document.getElementById('enhance-modal-repeat');
        enhanceModalCloseBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            closeEnhanceModal();
        });
        enhanceModalStartBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            runEnhancement();
        });
        enhanceModalRepeatBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            setEnhanceModalWarning('');
            runEnhancement();
        });
        enhanceModal.addEventListener('click', (event) => {
            if (Game.enhanceModal.stage === 'confirm') {
                if (event.target === enhanceModal) closeEnhanceModal();
                return;
            }
            handleEnhanceModalTap();
        });

        function switchSkillType(type) {
            Game.currentSkillType = type;
            document.querySelectorAll('.type-tab').forEach(el => el.classList.remove('active'));
            document.getElementById(`tab-${type}`).classList.add('active');
            renderSkillList();
        }

        const SkillPointModes = [
            { value: 1, label: '+1', tone: 'text-slate-600' },
            { value: 10, label: '+10', tone: 'text-emerald-600' },
            { value: -1, label: '-1', tone: 'text-rose-600' },
            { value: -10, label: '-10', tone: 'text-rose-700' }
        ];

        function getSkillPointModeValue() {
            const mode = SkillPointModes[Game.skillPointModeIndex] || SkillPointModes[0];
            return mode.value;
        }

        function updateSkillPointModeButton() {
            const button = document.getElementById('skill-point-mode');
            if (!button) return;
            const mode = SkillPointModes[Game.skillPointModeIndex] || SkillPointModes[0];
            button.innerHTML = `<i class="fas fa-sliders"></i><span class="${mode.tone}">${mode.label}</span>`;
        }

        function cycleSkillPointMode() {
            Game.skillPointModeIndex = (Game.skillPointModeIndex + 1) % SkillPointModes.length;
            updateSkillPointModeButton();
            renderSkillList();
        }

        function resetSkillAllocation() {
            openConfirmModal('å…¨ã¦ã®ã‚¹ã‚­ãƒ«æŒ¯ã‚Šã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ', () => {
                let refund = 0;
                JobKeys.forEach((job) => {
                    ['active', 'passive'].forEach((type) => {
                        const skillList = Game.player.skills[job]?.[type] || [];
                        skillList.forEach((level, idx) => {
                            if (level <= 0) return;
                            refund += getSkillPointCostRange(1, level);
                            if (type === 'passive') {
                                const skill = JobData[job][type][idx];
                                if (skill?.apply) {
                                    skill.apply(-level);
                                }
                            }
                            Game.player.skills[job][type][idx] = 0;
                        });
                    });
                });
                Game.player.sp = Math.min(MAX_SKILL_POINTS, Game.player.sp + refund);
                renderSkillList();
                updateUI();
                triggerAutosave();
            });
        }

        function renderSkillList() {
            const list = document.getElementById('skill-list');
            list.innerHTML = '';
            const data = JobData[Game.currentJobTab][Game.currentSkillType];
            const modeValue = getSkillPointModeValue();
            const modeAbs = Math.abs(modeValue);
            
            data.forEach((skill, idx) => {
                const level = getSkillLevel(Game.currentJobTab, Game.currentSkillType, idx);
                const maxLevel = skill.maxLevel || SkillMaxLevel;
                const isLearned = level > 0;
                const isMax = level >= maxLevel;
                const card = document.createElement('div');
                card.className = `p-4 rounded-2xl border-2 transition-all shadow-sm ${isLearned ? 'bg-white border-slate-800' : 'bg-slate-100 border-slate-200 opacity-60'}`;
                
                let actionPart = '';
                if (modeValue < 0) {
                    if (level > 0) {
                        const refundPlan = getSkillPointRefundForDecrease(level, modeAbs);
                        actionPart = refundPlan.levels > 0
                            ? `<button onclick="event.stopPropagation(); learnSkill('${Game.currentJobTab}', '${Game.currentSkillType}', ${idx})" class="shrink-0 px-4 py-2 bg-rose-500 text-white text-[10px] font-black rounded-xl">${refundPlan.refund}SPæˆ»ã™</button>`
                            : `<span class="shrink-0 text-xs font-black text-slate-400">æˆ»ã™SPãªã—</span>`;
                    } else {
                        actionPart = `<span class="shrink-0 text-xs font-black text-slate-400">æˆ»ã™SPãªã—</span>`;
                    }
                } else if (!isLearned) {
                    const addPlan = getSkillPointSpendForIncrease(level, maxLevel, modeAbs, Game.player.sp);
                    actionPart = addPlan.levels > 0
                        ? `<button onclick="event.stopPropagation(); learnSkill('${Game.currentJobTab}', '${Game.currentSkillType}', ${idx})" class="shrink-0 px-4 py-2 bg-slate-800 text-white text-[10px] font-black rounded-xl">${addPlan.cost}SPç¿’å¾—</button>`
                        : `<span class="shrink-0 text-xs font-black text-slate-400">SPä¸è¶³</span>`;
                } else if (!isMax) {
                    const addPlan = getSkillPointSpendForIncrease(level, maxLevel, modeAbs, Game.player.sp);
                    actionPart = addPlan.levels > 0
                        ? `<button onclick="event.stopPropagation(); learnSkill('${Game.currentJobTab}', '${Game.currentSkillType}', ${idx})" class="shrink-0 px-4 py-2 bg-amber-500 text-white text-[10px] font-black rounded-xl">${addPlan.cost}SPå¼·åŒ–</button>`
                        : `<span class="shrink-0 text-xs font-black text-slate-400">SPä¸è¶³</span>`;
                } else {
                    actionPart = `<span class="shrink-0 text-xs font-black text-slate-400"><i class="fas fa-check-circle"></i></span>`;
                }

                if (Game.currentSkillType === 'active' && isLearned) {
                    const targetSlot = Game.player.skillSlotTarget + 1;
                    actionPart = `
                        <div class="flex items-center gap-2">
                            <button onclick="event.stopPropagation(); assignSkillToSlot('${Game.currentJobTab}', ${idx})" class="shrink-0 px-3 py-2 bg-blue-600 text-white text-[10px] font-black rounded-xl">S${targetSlot}ã‚»ãƒƒãƒˆ</button>
                            ${actionPart}
                        </div>
                    `;
                }

                const displaySkill = (Game.currentSkillType === 'active')
                    ? buildActiveSkill(Game.currentJobTab, idx, Math.max(1, level || 1))
                    : skill;

                card.innerHTML = `
                    <div class="flex justify-between items-center gap-4">
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2 mb-0.5">
                                <span class="font-black text-sm truncate">${displaySkill.name}</span>
                                ${displaySkill.mp !== undefined ? `<span class="text-[9px] bg-blue-50 text-blue-600 px-1.5 py-0.5 rounded-full font-bold">MP ${displaySkill.mp}</span>` : ''}
                                <span class="text-[9px] bg-slate-100 text-slate-500 px-1.5 py-0.5 rounded-full font-bold">Lv ${level}/${maxLevel}</span>
                            </div>
                            <p class="text-[10px] text-slate-500 leading-tight">${displaySkill.desc}</p>
                        </div>
                        ${actionPart}
                    </div>
                `;
                card.addEventListener('click', () => {
                    openSkillDetailModal(Game.currentJobTab, Game.currentSkillType, idx, level);
                });
                list.appendChild(card);
            });
        }

        function learnSkill(job, type, idx) {
            const skill = JobData[job][type][idx];
            const current = getSkillLevel(job, type, idx);
            const maxLevel = skill.maxLevel || SkillMaxLevel;
            const modeValue = getSkillPointModeValue();
            if (modeValue === 0) return;
            if (modeValue > 0) {
                if (Game.player.sp <= 0 || current >= maxLevel) return;
                const addPlan = getSkillPointSpendForIncrease(current, maxLevel, modeValue, Game.player.sp);
                if (addPlan.levels <= 0) return;
                Game.player.sp -= addPlan.cost;
                Game.player.skills[job][type][idx] = current + addPlan.levels;
                if (type === 'passive' && skill.apply) {
                    skill.apply(addPlan.levels);
                }
            } else {
                if (current <= 0) return;
                const removePlan = getSkillPointRefundForDecrease(current, Math.abs(modeValue));
                if (removePlan.levels <= 0) return;
                Game.player.sp += removePlan.refund;
                Game.player.skills[job][type][idx] = current - removePlan.levels;
                if (type === 'passive' && skill.apply) {
                    skill.apply(-removePlan.levels);
                }
            }

            renderSkillList();
            updateUI();
            triggerAutosave();
        }

        function spawn() {
            let bossDef = null;
            let bossBase = null;
            let bossScale = 1;
            if (Game.isBossRush) {
                const pool = Object.values(BossDefs);
                const picked = pickRandom(pool);
                bossDef = picked ? { ...picked, originFloor: picked.floor } : null;
                bossBase = BossRushBaseStats;
                bossScale = getBossRushScale(Game.floor);
            } else {
                bossDef = BossDefs[Game.floor];
                bossScale = getBossScale(Game.floor);
            }
            if (bossDef) {
                const baseStats = bossBase || bossDef;
                const baseBossStats = calcEnemyStatsByFloor(Game.floor, baseStats, "balanced");
                const floorBossStats = applyBossFloorGrowth(baseBossStats, Game.floor);
                const bossStats = Game.isBossRush
                    ? {
                        maxHp: Math.floor(floorBossStats.maxHp * bossScale),
                        hp: Math.floor(floorBossStats.hp * bossScale),
                        str: Math.floor(floorBossStats.str * bossScale),
                        def: Math.floor(floorBossStats.def * bossScale),
                        acc: Math.floor(floorBossStats.acc * bossScale),
                        eva: Math.floor(floorBossStats.eva * bossScale),
                        exp: Math.floor(floorBossStats.exp * bossScale)
                    }
                    : floorBossStats;
                Game.enemy = {
                    ...bossDef,
                    floor: Game.floor,
                    ...bossStats,
                    statusEffects: [],
                    isBoss: true,
                    skillCooldown: bossDef.skillInterval,
                    skillRotation: 0,
                    critRate: 0,
                    critDamage: Math.floor(BossRushBuffConfig.baseCritMultiplier * 100),
                    bossRushBuffs: [],
                    bossRushBuffState: null
                };
                Game.enemy.skills = buildEnemySkillSet("balanced", Game.enemy.skills || [], { pool: BossExtraSkillPool });
                if (!Number.isFinite(Game.enemy.skillInterval)) {
                    Game.enemy.skillInterval = 3;
                    Game.enemy.skillCooldown = Game.enemy.skillInterval;
                }
                applyDxEnemyScaling(Game.enemy, Game.floor);
                if (Game.isBossRush) {
                    Game.enemy.bossRushBuffs = rollBossRushBuffs(Game.floor);
                    Game.enemy.bossRushBuffState = null;
                    applyBossRushBuffStats(Game.enemy, Game.enemy.bossRushBuffs);
                    applyBossRushCarryoverDamage(Game.enemy);
                } else {
                    Game.bossRushCarryoverDamage = 0;
                }
                addLog(`BOSS ${bossDef.name}ãŒå‡ºç¾ï¼`, "text-amber-500 font-black");
            } else {
                const basePool = getEnemyPool(Game.floor);
                const base = pickRandom(basePool);
                const archetypeId = getEnemyArchetypeId(base);
                const scaled = calcEnemyStatsByFloor(Game.floor, base, archetypeId);
                Game.enemy = { 
                    ...base,
                    ...scaled,
                    statusEffects: [],
                    isBoss: false,
                    critRate: 0,
                    critDamage: Math.floor(BossRushBuffConfig.baseCritMultiplier * 100),
                    bossRushBuffs: [],
                    bossRushBuffState: null
                };
                Game.enemy.skills = buildEnemySkillSet(archetypeId, Game.enemy.skills || []);
                Game.enemy.skillInterval = getEnemySkillInterval(archetypeId);
                Game.enemy.skillCooldown = Game.enemy.skillInterval;
                Game.enemy.skillRotation = 0;
                applyDxEnemyScaling(Game.enemy, Game.floor);
                Game.bossRushCarryoverDamage = 0;
            }
            const derived = getDerivedStats();
            const eliteRank = rollEliteRank(derived.totals.eliteEncounter);
            if (eliteRank > 0) {
                Game.enemy = buildEliteEnemy(Game.enemy, eliteRank);
                addLog(`ã‚¨ãƒªãƒ¼ãƒˆãƒ©ãƒ³ã‚¯${eliteRank} ${Game.enemy.name}ãŒå‡ºç¾ï¼`, "text-purple-500 font-black");
            }
            Game.state = 'combat';
            resetBossUniqueCombatState();
        }

        function performEnemySkill(skill, derived) {
            const enemyStatusMods = getStatusModifiers(Game.enemy);
            const playerStatusMods = getStatusModifiers(Game.player);
            const bossDefenseMultiplier = getBossUniqueDamageTakenMultiplier({
                player: Game.player,
                enemy: Game.enemy,
                derived
            });
            let totalDamage = 0;
            let landedHit = false;

            if (skill.pow !== undefined && skill.pow !== null) {
                const hits = skill.hits || 1;
                for (let i = 0; i < hits; i++) {
                    const baseAccuracy = Math.max(0, Math.floor(((skill.accuracy ?? 100) + (Game.enemy.acc || 0)) * enemyStatusMods.accuracyMul));
                    const evasionValue = Math.max(0, derived.totals.evasionRate);
                    const baseHit = 78;
                    const hitScale = 0.28;
                    let hitChance = baseHit + (baseAccuracy - evasionValue) * hitScale;
                    hitChance = Math.min(97, Math.max(15, hitChance));
                    if (Math.random() * 100 > hitChance) {
                        continue;
                    }
                    landedHit = true;
                    const ignoreDefense = shouldBossRushIgnoreDefense(Game.enemy);
                    let enemyAtk = Game.enemy.str * enemyStatusMods.atkMul;
                    let d = Math.floor((skill.pow ?? 1) * CombatBalance.enemySkillPow * enemyAtk * (0.8 + Math.random() * 0.4));
                    d = Math.floor(d * getBossRushEnemyAttackMultiplier(Game.enemy));
                    let isCrit = false;
                    const critRate = getBossRushEnemyCritRate(Game.enemy);
                    if (Math.random() * 100 < critRate) {
                        isCrit = true;
                        d = Math.floor(d * getBossRushEnemyCritMultiplier(Game.enemy));
                    }
                    if (!ignoreDefense) {
                        let defenseValue = derived.def;
                        // Passive: Armor Boost
                        const armorBoostLevel = getPassiveLevel('warrior', 4);
                        if (armorBoostLevel > 0) {
                            defenseValue += Math.floor(getItemStatValue(Game.player.armor, "defenseFlat") * 0.15 * armorBoostLevel);
                        }
                        d = Math.floor(d * getDamageRatio(enemyAtk, defenseValue));
                    }
                    if (derived.totals.damageReduction > 0) {
                        d = Math.floor(d * (1 - derived.totals.damageReduction / 100));
                    }
                    d = Math.floor(d * enemyStatusMods.damageDoneMul);
                    d = Math.floor(d * playerStatusMods.damageTakenMul);
                    d = Math.floor(d * bossDefenseMultiplier);
                    d = Math.max(1, d);
                    const applied = applyDamage(Game.player, d, Game.enemy);
                    totalDamage += applied;
                    if (isCrit) {
                        addLog(`${Game.enemy.name}ã®ä¼šå¿ƒï¼`, "text-amber-400");
                    }
                    applyBossRushOnHitEffects(applied);
                }
            }

            if (skill.pow !== undefined && skill.pow !== null) {
                if (totalDamage > 0) {
                    addLog(`${Game.enemy.name}ã®${skill.name}ï¼ ${totalDamage}ãƒ€ãƒ¡ãƒ¼ã‚¸`, "text-red-400");
                    dmgText(totalDamage);
                } else if (landedHit) {
                    addLog(`${Game.enemy.name}ã®${skill.name}ï¼ ãƒãƒªã‚¢ã«é˜²ãŒã‚ŒãŸï¼`, "text-slate-400");
                    dmgText(0, false);
                } else {
                    addLog(`${Game.enemy.name}ã®${skill.name}ã¯å¤–ã‚ŒãŸï¼`, "text-slate-400");
                    dmgText("MISS", false);
                }
            } else {
                addLog(`${Game.enemy.name}ã®${skill.name}ï¼`, "text-amber-500");
            }

            if (skill.healPct) {
                const healAmount = Math.floor(Game.enemy.maxHp * skill.healPct);
                Game.enemy.hp = Math.min(Game.enemy.maxHp, Game.enemy.hp + healAmount);
                addLog(`${Game.enemy.name}ã¯HPã‚’${healAmount}å›å¾©ï¼`, "text-emerald-500");
            }

            if (skill.effects) {
                skill.effects.forEach((effect) => {
                    const target = effect.target === "self" ? Game.enemy : Game.player;
                    const isFreeze = effect.id === "freeze" && effect.target === "player";
                    const baseChance = effect.chance ?? 1;
                    const finalChance = isFreeze ? getFreezeDecayChance(target, baseChance) : baseChance;
                    if (!isFreeze || Math.random() < finalChance) {
                        const sourceStr = effect.target === "self" ? null : (Game.enemy?.str || 0);
                        applyStatusEffect(target, effect.id, effect.stacks, effect.turns, sourceStr ? { sourceStr } : null);
                        if (isFreeze) {
                            recordFreezeApplied(target);
                        }
                        if (effect.log && effect.target === "player") {
                            addLog(effect.log, "text-purple-400");
                        }
                    }
                });
            }

            if (skill.log) {
                addLog(skill.log, "text-amber-500");
            }
        }

        const actionButton = document.getElementById('action-btn');
        let actionRepeatTimer = null;
        let actionRepeatActive = false;
        let actionCooldown = false;
        const actionCooldownMs = 100;

        const handleAction = () => {
            if (Game.state === 'dead') return;
            if (actionCooldown) return;
            actionCooldown = true;
            setTimeout(() => {
                actionCooldown = false;
            }, actionCooldownMs);
            if (Game.state === 'idle') {
                const reachedFloorLimit = !Game.isBossRush && Game.floor >= MaxFloorLimit;
                const stayOnFloor = Game.stayOnFloor || reachedFloorLimit;
                if (!stayOnFloor) {
                    Game.floor++;
                    if (Game.isBossRush) {
                        Game.maxBossRushFloor = Math.max(Game.maxBossRushFloor || BossRushStartFloor, Game.floor);
                    } else {
                        Game.maxFloor = Math.max(Game.maxFloor, Game.floor);
                    }
                } else if (reachedFloorLimit) {
                    Game.maxFloor = Math.max(Game.maxFloor, Game.floor);
                }
                spawn();
                addLog(stayOnFloor ? `B${Game.floor}ã¸å†æˆ¦...` : `B${Game.floor}ã¸æ½œå…¥...`);
                updateUI();
                triggerAutosave();
                return;
            }

            tickFreezeDecayForCombatants();
            advanceStatusEffects(Game.player, 'start');
            if (Game.player.hp <= 0) {
                die();
                updateUI();
                return;
            }
            const playerStatusMods = getStatusModifiers(Game.player);
            if (playerStatusMods.frozen) {
                addLog("å‡çµã§è¡Œå‹•ä¸èƒ½ï¼", "text-sky-400");
                advanceStatusEffects(Game.player, 'end');
                applyAutoRegen();
                setTimeout(enemyTurn, 300);
                updateUI();
                return;
            }

            const buildCombatContext = () => {
                const derived = getDerivedStats();
                const enemyStatusMods = getStatusModifiers(Game.enemy);
                const enemyEvasion = Math.max(0, Math.floor((Game.enemy.eva || 0) * enemyStatusMods.evasionMul));
                const bossRushDefenseMul = getBossRushEnemyDefenseMultiplier(Game.enemy);
                const enemyDefense = Math.max(0, Math.floor((Game.enemy.def || 0) * enemyStatusMods.defMul * bossRushDefenseMul));
                const playerStatusMods = getStatusModifiers(Game.player);
                return { derived, enemyStatusMods, enemyEvasion, enemyDefense, playerStatusMods };
            };

            let combatContext = buildCombatContext();
            if (hasBossUniqueEffect("repeatMemory") && Game.player.bossUniqueState.lastSkill && !combatContext.playerStatusMods.silence) {
                addLog("åå¾©è¨˜æ†¶ãŒç™ºå‹•ï¼", "text-amber-400");
                performPlayerSkillAction(Game.player.bossUniqueState.lastSkill, combatContext, { labelPrefix: "åå¾©è¨˜æ†¶ï¼š" });
                if (Game.enemy.hp <= 0) {
                    victory();
                    updateUI();
                    triggerAutosave();
                    return;
                }
                combatContext = buildCombatContext();
            }

            const slotResult = getNextSlotSkill();
            let currentSkill = { name: 'é€šå¸¸æ”»æ’ƒ', mp: 0, pow: 0.9 };
            let isMagic = false;
            
            if (slotResult.skill) {
                currentSkill = slotResult.skill;
                if (currentSkill.isMagic) isMagic = true;
            }

            const derived = combatContext.derived;
            let adjustedMpCost = currentSkill.mp || 0;
            if (currentSkill.name !== 'é€šå¸¸æ”»æ’ƒ') {
                const skillMpDiscount = derived.totals.skillMpDiscount || 0;
                if (skillMpDiscount > 0) {
                    adjustedMpCost = Math.max(0, Math.floor(adjustedMpCost * (1 - skillMpDiscount / 100)));
                }
                const skillMpCutEffect = getStatusEffect(Game.player, 'potionSkillMpCut');
                const skillMpCutPct = skillMpCutEffect?.bonusPct || 0;
                if (skillMpCutPct > 0) {
                    adjustedMpCost = Math.max(0, Math.floor(adjustedMpCost * (1 - skillMpCutPct / 100)));
                    if ((currentSkill.mp || 0) > 0) {
                        adjustedMpCost = Math.max(1, adjustedMpCost);
                    }
                }
            } else {
                adjustedMpCost = 0;
            }

            if (Game.player.mp < adjustedMpCost) {
                addLog("MPä¸è¶³ï¼é€šå¸¸æ”»æ’ƒ", "text-blue-400");
                currentSkill = { name: 'é€šå¸¸æ”»æ’ƒ', mp: 0, pow: 0.9 };
                isMagic = false;
                adjustedMpCost = 0;
            }
            if (playerStatusMods.silence && currentSkill.name !== 'é€šå¸¸æ”»æ’ƒ') {
                addLog("æ²ˆé»™ã§ã‚¹ã‚­ãƒ«ä¸å¯ï¼é€šå¸¸æ”»æ’ƒã«å¤‰æ›´", "text-slate-400");
                currentSkill = { name: 'é€šå¸¸æ”»æ’ƒ', mp: 0, pow: 0.9 };
                isMagic = false;
                adjustedMpCost = 0;
            }

            Game.player.skillSlotIndex = slotResult.nextIndex;
            const {
                enemyStatusMods,
                enemyEvasion,
                enemyDefense,
                playerStatusMods: actionPlayerStatusMods
            } = combatContext;

            if (currentSkill.hpCost) {
                const cost = Math.floor(derived.maxHp * currentSkill.hpCost);
                Game.player.hp = Math.max(1, Game.player.hp - cost);
                if (cost > 0) {
                    addLog(`HPæ¶ˆè²» ${cost}`, "text-rose-400");
                }
            }

            Game.player.mp -= adjustedMpCost;
            if (adjustedMpCost > 0) {
                addLog(`MPæ¶ˆè²» ${adjustedMpCost}`, "text-slate-400");
            }
            if (currentSkill.name !== 'é€šå¸¸æ”»æ’ƒ' && getStatusEffect(Game.player, 'potionSkillMpCut')) {
                removeStatusEffect(Game.player, 'potionSkillMpCut');
            }

            performPlayerSkillAction(currentSkill, {
                derived,
                enemyStatusMods,
                enemyEvasion,
                enemyDefense,
                playerStatusMods: actionPlayerStatusMods
            });

            Game.player.bossUniqueState.lastSkill = currentSkill.name !== 'é€šå¸¸æ”»æ’ƒ' ? { ...currentSkill } : null;

            if (currentSkill.name !== 'é€šå¸¸æ”»æ’ƒ') {
                const restoreEffect = getBossUniqueEffectByType("mpRestoreAfterSkill");
                if (restoreEffect && checkBossUniqueCondition(restoreEffect.condition, { player: Game.player, enemy: Game.enemy, derived })) {
                    const beforeMp = Game.player.mp;
                    Game.player.mp = Math.min(derived.maxMp, Game.player.mp + BossUniqueEffectConfig.holyStaffMpRestore);
                    const actual = Game.player.mp - beforeMp;
                    if (actual > 0) {
                        addLog(`ç¥ˆã‚Šã®åéŸ¿ã§MPãŒ${actual}å›å¾©`, "text-blue-400");
                    }
                }
            }

            if (hasBossUniqueEffect("recastSkill") && currentSkill.name !== 'é€šå¸¸æ”»æ’ƒ') {
                const recastContext = buildCombatContext();
                if (Game.enemy.hp > 0 && !recastContext.playerStatusMods.silence && Math.random() < BossUniqueEffectConfig.recastChance) {
                    addLog("å†è© å”±ãŒç™ºå‹•ï¼", "text-amber-400");
                    performPlayerSkillAction(currentSkill, recastContext, { labelPrefix: "å†è© å”±ï¼š" });
                    if (Game.enemy.hp <= 0) {
                        victory();
                        updateUI();
                        triggerAutosave();
                        return;
                    }
                }
            }

            advanceStatusEffects(Game.player, 'end');
            applyAutoRegen();
            if (Game.enemy.hp <= 0) {
                victory();
            } else {
                setTimeout(enemyTurn, 300);
            }
            updateUI();
            triggerAutosave();
        };

        const stopActionRepeat = () => {
            if (actionRepeatTimer) {
                clearInterval(actionRepeatTimer);
                actionRepeatTimer = null;
            }
            actionRepeatActive = false;
        };

        const startActionRepeat = () => {
            if (actionRepeatActive) return;
            actionRepeatActive = true;
            handleAction();
            actionRepeatTimer = setInterval(handleAction, actionCooldownMs);
        };

        actionButton.addEventListener('pointerdown', startActionRepeat);
        actionButton.addEventListener('pointerup', stopActionRepeat);
        actionButton.addEventListener('pointercancel', stopActionRepeat);
        actionButton.addEventListener('mouseleave', stopActionRepeat);

        function enemyTurn() {
            if (Game.state !== 'combat') return;

            tickFreezeDecayForCombatants();
            advanceStatusEffects(Game.enemy, 'start');
            if (Game.enemy.hp <= 0) {
                victory();
                updateUI();
                return;
            }
            const enemyStatusMods = getStatusModifiers(Game.enemy);
            if (enemyStatusMods.frozen) {
                addLog(`${Game.enemy.name}ã¯å‡çµã§å‹•ã‘ãªã„ï¼`, "text-sky-400");
                advanceStatusEffects(Game.enemy, 'end');
                applyAutoRegen();
                updateUI();
                return;
            }
            const derived = getDerivedStats();
            const bossRushState = getBossRushBuffState(Game.enemy);
            if (bossRushState) {
                bossRushState.turnCount = Math.max(0, bossRushState.turnCount || 0) + 1;
            }

            let usedBossSkill = false;
            let actionCount = 1;
            if (hasBossRushBuff(Game.enemy, "br_purple_double")) actionCount += 1;
            if (hasBossRushBuff(Game.enemy, "br_basic_extra_action") && Math.random() < BossRushBuffConfig.extraActionChance) actionCount += 1;
            if (hasBossRushBuff(Game.enemy, "br_green_hp30_extra") && Game.enemy.hp <= (Game.enemy.maxHp || 1) * 0.3) actionCount += 1;
            if (hasBossRushBuff(Game.enemy, "br_purple_start_bonus") && Math.random() < BossRushBuffConfig.startBonusActionChance) actionCount += 1;
            if (actionCount > 1) {
                addLog(`${Game.enemy.name}ãŒé€£ç¶šè¡Œå‹•ï¼`, "text-purple-400");
            }

            let skillReady = false;
            if (Array.isArray(Game.enemy.skills) && Game.enemy.skills.length > 0) {
                Game.enemy.skillCooldown = Math.max(0, (Game.enemy.skillCooldown ?? 0) - 1);
                if (Game.enemy.skillCooldown <= 0) {
                    skillReady = true;
                }
            }

            for (let actionIndex = 0; actionIndex < actionCount; actionIndex += 1) {
                let didSkill = false;
                if (!usedBossSkill && skillReady && Array.isArray(Game.enemy.skills) && Game.enemy.skills.length > 0) {
                    const skill = Game.enemy.skills[Game.enemy.skillRotation % Game.enemy.skills.length];
                    Game.enemy.skillRotation = (Game.enemy.skillRotation + 1) % Game.enemy.skills.length;
                    performEnemySkill(skill, derived);
                    Game.enemy.skillCooldown = Game.enemy.skillInterval;
                    usedBossSkill = true;
                    didSkill = true;
                    skillReady = false;
                }

                if (!didSkill) {
                    const result = performEnemyPhysicalAttack({ derived, label: `${Game.enemy.name}ï¼š`, damageMultiplier: 1 });
                    if (!result.landedHit) {
                        continue;
                    }
                    if (!Game.enemy.isBoss && result.appliedDamage > 0 && Array.isArray(Game.enemy.onHitEffects)) {
                        Game.enemy.onHitEffects.forEach((effect) => {
                            const chance = effect.chance ?? 1;
                            const isFreeze = effect.id === "freeze";
                            const finalChance = isFreeze ? getFreezeDecayChance(Game.player, chance) : chance;
                            if (!isFreeze || Math.random() < finalChance) {
                                const sourceStr = Game.enemy?.str || 0;
                                applyStatusEffect(Game.player, effect.id, effect.stacks, effect.turns, sourceStr ? { sourceStr } : null);
                                if (isFreeze) {
                                    recordFreezeApplied(Game.player);
                                }
                                if (effect.log) {
                                    addLog(effect.log, "text-purple-400");
                                }
                            }
                        });
                    }
                    if (hasBossRushBuff(Game.enemy, "br_purple_follow") && result.appliedDamage > 0) {
                        const followUpDamage = Math.max(1, Math.floor(result.appliedDamage * BossRushBuffConfig.followUpMultiplier));
                        const applied = applyDamage(Game.player, followUpDamage, Game.enemy, { ignoreBossRushNullify: true });
                        addLog(`è¿½æ’ƒï¼ ${applied}ãƒ€ãƒ¡`, "text-red-400");
                        applyBossRushOnHitEffects(applied);
                    }
                }

                if (Game.player.hp <= 0) break;
            }
            
            // Passive: MP Regen
            const mpRegenLevel = getPassiveLevel('mage', 2);
            if (mpRegenLevel > 0) {
                const beforeMp = Game.player.mp;
                Game.player.mp = Math.min(derived.maxMp, Game.player.mp + (2 * mpRegenLevel));
                const actual = Game.player.mp - beforeMp;
                if (actual > 0) {
                    addLog(`ç‘æƒ³ã§MPãŒ${actual}å›å¾©`, "text-blue-400");
                }
            }
            
            // Passive: Counter
            const counterLevel = getPassiveLevel('warrior', 3);
            if (counterLevel > 0 && Math.random() < (0.03 * counterLevel)) {
                const derived = getDerivedStats();
                let cdmg = Math.floor(derived.totals.str * (0.2 + 0.1 * counterLevel));
                Game.enemy.hp = Math.max(0, Game.enemy.hp - cdmg);
                addLog(`ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼ ${cdmg}ãƒ€ãƒ¡ãƒ¼ã‚¸`, "text-orange-500");
                dmgText(cdmg);
                if (Game.enemy.hp <= 0) victory();
            }

            advanceStatusEffects(Game.enemy, 'end');
            if (Game.player.hp <= 0) {
                die();
                updateUI();
                return;
            }
            applyAutoRegen();
            updateUI();
        }

        function victory() {

            console.log("[BOSS DROP CHECK]", {
              isBoss: Game.enemy?.isBoss,
              enemyFloor: Game.enemy?.floor,
              gameFloor: Game.floor,
              bossTableByEnemyFloor: BossLootTables?.[Game.enemy?.floor],
              bossTableByGameFloor: BossLootTables?.[Game.floor],
              bossRushTableByEnemyFloor: BossRushLootTables?.[Game.enemy?.floor],
              bossRushTableByGameFloor: BossRushLootTables?.[Game.floor],
            });

            
            Game.state = 'idle';
            const shouldOpenBossRushModal = Boolean(
                Game.enemy?.isBoss
                && Game.enemy.floor === 5000
                && !Game.defeatedBossFloors.includes(5000)
            );
            if (Game.enemy?.isBoss) {
                recordBossDefeat(Game.enemy.floor || Game.floor);
            }
            addLog(`è¨ä¼æˆåŠŸï¼`, "text-yellow-500 font-black");
            let gain = Game.enemy.exp;
            // Exp Boost Calculation
            const totals = getTotalStats();
            gain = Math.floor(gain * (1 + totals.expBoost / 100));
            if (Game.enemy?.elite?.rank) {
                gain = Math.floor(gain * (1 + 0.08 * Game.enemy.elite.rank));
            }
            Game.player.exp += gain;

            applyLevelUps();
            restorePotionCapacity(Game.player.potion1);
            restorePotionCapacity(Game.player.potion2);
            if (Array.isArray(Game.player.statusEffects)) {
                Game.player.statusEffects = Game.player.statusEffects.filter(
                    (effect) => !NegativeStatusEffectIds.has(effect.id)
                );
            }
            // Drop Luck Check
            if (!Game.isBossRush || Game.floor < BossRushNoDropStartFloor) {
                const eliteLootMultiplier = Game.enemy?.elite?.lootMultiplier ?? 1;
                const totals = getTotalStats();
                let dropChance = Math.min(0.95, totals.luck / 100);
                dropChance = Math.min(0.95, dropChance * eliteLootMultiplier);
                const rollBossDropMode = () => {
                    if (!Game.enemy?.isBoss) return false;
                    const roll = Math.random();
                    if (roll < BossDropChance) return true;
                    if (roll < BossDropChance + NormalDropChance) return false;
                    return false;
                };
                const rollRoadLegendaryMode = () => {
                    if (Game.enemy?.isBoss) return false;
                    const roll = Math.random();
                    if (roll < RoadLegendaryDropChance) return true;
                    if (roll < RoadLegendaryDropChance + RoadLegendaryNormalChance) return false;
                    return false;
                };
                if (Math.random() < dropChance) {
                    if (Game.enemy?.isBoss) {
                        const forceBossDrop = rollBossDropMode();
                        queueLoot(buildEquipmentLoot({ forceBossDrop }));
                    } else {
                        const isRoadLegendary = rollRoadLegendaryMode();
                        queueLoot(isRoadLegendary ? buildRoadLegendaryLoot() : buildEquipmentLoot({ forceBossDrop: false }));
                    }
                }
                if (Math.random() < dropChance) queueLoot(buildPotionLoot());
                const bonusRolls = Game.enemy?.elite ? Math.floor(Game.enemy.elite.rank / 2) : 0;
                for (let i = 0; i < bonusRolls; i++) {
                    if (Math.random() < dropChance) {
                        if (Game.enemy?.isBoss) {
                            const forceBossDrop = rollBossDropMode();
                            queueLoot(buildEquipmentLoot({ forceBossDrop }));
                        } else {
                            const isRoadLegendary = rollRoadLegendaryMode();
                            queueLoot(isRoadLegendary ? buildRoadLegendaryLoot() : buildEquipmentLoot({ forceBossDrop: false }));
                        }
                    }
                    if (Math.random() < dropChance) queueLoot(buildPotionLoot());
                }
            }
            openNextLoot();
            triggerAutosave();
            if (shouldOpenBossRushModal) {
                openBossRushModal();
            }
            if (!Game.isBossRush && Game.enemy?.floor === MaxFloorLimit && !Game.endMessageShown) {
                Game.endMessageShown = true;
                Game.maxFloor = Math.max(Game.maxFloor, MaxFloorLimit);
                openConfirmModal(
                    "10000éšåˆ°é”ã€ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚ã“ã“ã¾ã§éŠã‚“ã§ãã‚Œã¦æ„Ÿè¬ã—ã¦ã„ã¾ã™ã€‚ã‚ˆã‚ã—ã‘ã‚Œã°ã€ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã€Œæ„Ÿæƒ³ãƒ»è¦æœ›ã€ã‹ã‚‰ã”æ„è¦‹ã‚’ãŠèã‹ã›ãã ã•ã„ã€‚"
                );
            }
        }

        function die() {
            Game.state = 'dead';
            const lostExp = Math.floor(Game.player.next * 0.1);
            document.getElementById('lost-exp-val').innerText = lostExp;
            Game.player.exp = Math.max(0, Game.player.exp - lostExp);
            Game.floor = Math.max(1, Game.floor - 20);
            addLog("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", "text-rose-400");
            addLog("æˆ¦é—˜ä¸èƒ½â€¦", "text-rose-400 font-black");
            addLog("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", "text-rose-400");
            document.getElementById('death-overlay').style.display = 'flex';
            triggerAutosave();
        }

        function revive() {
            const derived = getDerivedStats();
            Game.player.hp = derived.maxHp;
            Game.player.mp = derived.maxMp;
            document.getElementById('death-overlay').style.display = 'none';
            addLog("å‘½ã‹ã‚‰ãŒã‚‰ç”Ÿé‚„ã—ãŸ...", "text-slate-400 italic");
            spawn();
            updateUI();
            switchPage('battle');
        }

        function addLog(m, c="") {
            const div = document.createElement('div');
            div.className = c;
            div.innerText = `> ${m}`;
            const full = document.getElementById('full-log-container');
            full.appendChild(div);
            if (full.children.length > 50) full.firstChild.remove();
            registerMiniLog(m, c);
        }

        function registerMiniLog(m, c="") {
            Game.logs.unshift({m, c});
            if (Game.logs.length > 10) Game.logs.pop();
            for(let i=0; i<10; i++) {
                const el = document.getElementById(`mini-log-${i}`);
                if (Game.logs[i]) {
                    el.innerText = Game.logs[i].m;
                    el.className = Game.logs[i].c || (i===0 ? 'text-slate-800 font-bold' : 'text-slate-400');
                }
            }
        }

        function addDropLog(item) {
            Game.dropLogs.unshift({ name: item.name, rarity: item.rarity });
            if (Game.dropLogs.length > 10) Game.dropLogs.pop();
            renderDropLog();
        }

        function renderDropLog() {
            const list = document.getElementById('drop-log-list');
            if (!list) return;
            list.innerHTML = '';
            Game.dropLogs.forEach((entry) => {
                const row = document.createElement('div');
                row.className = `drop-log-item rarity-${entry.rarity}`;
                const icon = entry.rarity === 'legendary' ? 'fa-crown' : 'fa-caret-right';
                row.innerHTML = `<i class="fas ${icon}"></i><span>${entry.name}</span>`;
                list.appendChild(row);
            });
        }

        function dmgText(v, isH=false) {
            const el = document.createElement('div');
            el.className = `damage-text ${isH?'text-green-500':'text-red-600'}`;
            el.innerText = v;
            el.style.left = (35 + Math.random()*30) + '%';
            el.style.top = (35 + Math.random()*30) + '%';
            document.getElementById('damage-layer').appendChild(el);
            setTimeout(()=>el.remove(), 800);
        }

        function buildEquipmentLoot(options = {}) {
            const forceBossDrop = options.forceBossDrop;
            const useBossTable = forceBossDrop === true
                ? true
                : (forceBossDrop === false ? false : (Game.enemy?.isBoss && Game.enemy.floor <= 5000));
            if (useBossTable) {

console.log("[BUILD LOOT]", {
  useBossTable,
  floor,
  bossTable: BossLootTables?.[floor] || BossRushLootTables?.[floor],
});
                
                const bossTable = BossRushLootTables[Game.enemy.floor] || BossLootTables[Game.enemy.floor];
                if (bossTable && bossTable.length > 0) {
                    const base = pickRandom(bossTable);
                    const index = Math.max(0, bossTable.indexOf(base));
                    return buildBossItem(base, Game.enemy.floor, index, { forceLegendary: true });
                }
            }
            const tier = EquipmentTiers[getTierIndex(Game.floor)];
            const types = Object.keys(EquipmentTypePools);
            const type = pickRandom(types);
            const poolKey = EquipmentTypePools[type];
            const base = pickRandom(tier[poolKey]);
            return buildItem(base, type, { maxRarityKey: "epic" });
        }

        function buildPotionLoot() {
            const base = pickRandom(PotionBases);
            const potion = buildPotion(base);
            const derived = syncPotionCapacity(potion);
            potion.currentCapacity = derived.maxCapacity;
            return potion;
        }

        function queueLoot(item) {
            if (!item) return;
            Game.lootQueue.push(item);
        }

        function openNextLoot() {
            if (Game.lootQueue.length === 0) return;
            while (Game.lootQueue.length > 0) {
                const nextItem = Game.lootQueue.shift();
                if (nextItem && nextItem.rarity === 'legendary' && nextItem.type !== 'potion') {
                    openLegendaryDropModal(nextItem);
                    return;
                }
                acquireLoot(nextItem);
            }
            updateUI();
        }

        function openLegendaryDropModal(item) {
            Game.tempLegendaryLoot = item;
            document.getElementById('legendary-drop-display').innerHTML = `
                <div class="text-[10px] text-amber-200/80 mb-1 uppercase font-black">${getEquipmentTypeLabel(Game.tempLegendaryLoot)} Found</div>
                <div class="text-xl font-black rarity-${Game.tempLegendaryLoot.rarity} legendary-glow">${Game.tempLegendaryLoot.name}</div>
                <div class="mt-2 space-y-1">${renderItemStatsHtml(Game.tempLegendaryLoot)}</div>
            `;
            document.getElementById('legendary-drop-modal').style.display = 'flex';
            Game.state = 'loot';
        }

        function closeLegendaryDropModal() {
            if (!Game.tempLegendaryLoot) return;
            acquireLoot(Game.tempLegendaryLoot);
            Game.tempLegendaryLoot = null;
            document.getElementById('legendary-drop-modal').style.display = 'none';
            Game.state = 'idle';
            updateUI();
            if (Game.lootQueue.length > 0) {
                openNextLoot();
            }
            triggerAutosave();
        }

        function acquireLoot(item) {
            if (!item) return;
            if (Game.lootFilter?.[item.rarity]) {
                Game.player.gold += getSellPrice(item);
                return;
            }
            item.acquiredAt = Game.inventoryCounter++;
            if (item.type === 'potion') {
                const derived = syncPotionCapacity(item);
                item.currentCapacity = derived.maxCapacity;
            }
            Game.player.inventory.push(item);
            addDropLog(item);
        }

        function openLootModal(item) {
            Game.tempLoot = item;
            document.getElementById('loot-display').innerHTML = `
                <div class="text-[10px] text-slate-400 mb-1 uppercase font-black">${getEquipmentTypeLabel(Game.tempLoot)} Found</div>
                <div class="text-xl font-black rarity-${Game.tempLoot.rarity}">${Game.tempLoot.name}</div>
                <div class="mt-2 space-y-1">${renderItemStatsHtml(Game.tempLoot)}</div>
            `;
            document.getElementById('loot-modal').style.display = 'flex';
            Game.state = 'loot';
        }

        function closeLoot(take) {
            if (take) {
                Game.tempLoot.acquiredAt = Game.inventoryCounter++;
                if (Game.tempLoot.type === 'potion') {
                    const derived = syncPotionCapacity(Game.tempLoot);
                    Game.tempLoot.currentCapacity = derived.maxCapacity;
                }
                if (Game.lootFilter?.[Game.tempLoot.rarity]) {
                    Game.player.gold += getSellPrice(Game.tempLoot);
                } else {
                    Game.player.inventory.push(Game.tempLoot);
                }
            } else {
                Game.player.gold += getSellPrice(Game.tempLoot);
            }
            document.getElementById('loot-modal').style.display = 'none';
            Game.state = 'idle';
            updateUI();
            if (Game.lootQueue.length > 0) {
                openNextLoot();
            }
            triggerAutosave();
        }

        function setInventoryFilter(type) {
            Game.inventoryFilter = type;
            updateUI();
        }

        function toggleInventorySort() {
            const order = ['acquired', 'rarity', 'affix'];
            const current = Game.inventorySort || 'acquired';
            const currentIndex = order.indexOf(current);
            const next = order[(currentIndex + 1) % order.length];
            Game.inventorySort = next;
            updateUI();
        }

        const EquippedSlots = [
            'weapon',
            'armor',
            'head',
            'hands',
            'feet',
            'accessory1',
            'accessory2',
            'potion1',
            'potion2'
        ];

        const syncEquippedItemIds = () => {
            const inventory = Game.player.inventory || [];
            inventory.forEach((invItem) => {
                if (invItem && (invItem.acquiredAt === undefined || invItem.acquiredAt === null)) {
                    invItem.acquiredAt = Game.inventoryCounter++;
                }
            });
            EquippedSlots.forEach((slot) => {
                const equipped = Game.player[slot];
                if (!equipped) return;
                if (equipped.acquiredAt !== undefined && equipped.acquiredAt !== null) return;
                const match = inventory.find((invItem) => (
                    invItem
                    && invItem.type === equipped.type
                    && invItem.name === equipped.name
                    && invItem.rarity === equipped.rarity
                    && invItem.rarityMul === equipped.rarityMul
                ));
                if (match && match.acquiredAt !== undefined && match.acquiredAt !== null) {
                    equipped.acquiredAt = match.acquiredAt;
                }
            });
        };

        const isSameItem = (a, b) => {
            if (!a || !b) return false;
            if (a === b) return true;
            if (a.acquiredAt !== undefined && b.acquiredAt !== undefined) {
                return a.acquiredAt === b.acquiredAt;
            }
            return false;
        };

        function isItemEquipped(item) {
            return EquippedSlots.some((slot) => isSameItem(Game.player[slot], item));
        }

        function removeInventoryItem(idx) {
            if (idx < 0 || idx >= Game.player.inventory.length) return false;
            const item = Game.player.inventory[idx];
            if (!item || isItemEquipped(item)) return false;
            Game.player.inventory.splice(idx, 1);
            return true;
        }

        function equip(idx) {
            const item = Game.player.inventory[idx];
            if (!item || isItemEquipped(item)) return;
            if (item.type === 'accessory') {
                openEquipSlotModal(item, idx);
                return;
            }
            if (item.type === 'potion') {
                openEquipSlotModal(item, idx);
                return;
            }
            if (item.type === 'potion') {
                let slotKey = 'potion1';
                if (!Game.player.potion1) {
                    slotKey = 'potion1';
                } else if (!Game.player.potion2) {
                    slotKey = 'potion2';
                }
                Game.player[slotKey] = item;
                syncPotionCapacity(item);
                updateUI();
                triggerAutosave();
                return;
            }
            Game.player[item.type] = item;
            updateUI();
            triggerAutosave();
        }

        function deleteItem(idx) {
            const item = Game.player.inventory[idx];
            if (!item || isItemEquipped(item) || item.favorite) return;
            const price = getSellPrice(item);
            if (removeInventoryItem(idx)) {
                Game.player.gold += price;
            }
            updateUI();
            triggerAutosave();
        }

        function toggleFavorite(idx) {
            const item = Game.player.inventory[idx];
            if (!item) return;
            item.favorite = !item.favorite;
            updateUI();
            triggerAutosave();
        }

        const openEnhanceModal = (idx) => {
            const item = Game.player.inventory[idx];
            if (!isEnhanceableItem(item)) return;
            normalizeWeaponEnhancement(item);
            Game.enhanceModal.index = idx;
            Game.enhanceModal.stage = 'confirm';
            Game.enhanceModal.result = null;
            if (Game.enhanceModal.timer) {
                clearTimeout(Game.enhanceModal.timer);
                Game.enhanceModal.timer = null;
            }
            syncEnhanceModal();
            const modal = document.getElementById('enhance-modal');
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        };

        const closeEnhanceModal = () => {
            const modal = document.getElementById('enhance-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            Game.enhanceModal.index = null;
            Game.enhanceModal.stage = 'confirm';
            Game.enhanceModal.result = null;
            if (Game.enhanceModal.timer) {
                clearTimeout(Game.enhanceModal.timer);
                Game.enhanceModal.timer = null;
            }
        };

        const syncEnhanceModal = () => {
            const idx = Game.enhanceModal.index;
            const item = Game.player.inventory[idx];
            const title = document.getElementById('enhance-modal-title');
            const levelEl = document.getElementById('enhance-modal-level');
            const costEl = document.getElementById('enhance-modal-cost');
            const previewEl = document.getElementById('enhance-modal-preview');
            const warningEl = document.getElementById('enhance-modal-warning');
            const startBtn = document.getElementById('enhance-modal-start');
            const repeatBtn = document.getElementById('enhance-modal-repeat');
            if (!item || !isEnhanceableItem(item)) return;
            const level = getWeaponEnhancementLevel(item);
            const cost = getWeaponEnhancementCost(item);
            const preview = getEnhancementPreviewStat(item);
            const previewLabel = preview ? `åŸºç¤ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ +${preview.value}%` : "ãªã—";
            const maxed = level >= MAX_WEAPON_ENHANCEMENT;
            title.innerHTML = `<i class="fas fa-hammer text-slate-500"></i> å¼·åŒ–`;
            levelEl.textContent = `+${level}`;
            costEl.textContent = maxed ? "MAX" : `${formatGold(cost)}G`;
            previewEl.textContent = maxed ? "å¼·åŒ–ä¸å¯" : previewLabel;
            warningEl.textContent = '';
            const canStart = !item.isBroken && !maxed && Game.player.gold >= cost;
            startBtn.disabled = !canStart;
            startBtn.className = `mt-4 w-full font-black py-3 rounded-2xl shadow-lg ${
                canStart ? 'bg-slate-800 text-white' : 'bg-slate-100 text-slate-300 cursor-not-allowed'
            }`;
            repeatBtn.disabled = !canStart;
            repeatBtn.className = `w-full font-black py-2.5 rounded-xl shadow flex items-center justify-center gap-2 ${
                canStart ? 'bg-slate-800 text-white' : 'bg-slate-100 text-slate-300 cursor-not-allowed'
            }`;
            const progress = document.getElementById('enhance-modal-progress');
            const result = document.getElementById('enhance-modal-result');
            progress.classList.add('hidden');
            result.classList.add('hidden');
            syncEnhanceModalStages();
        };

        const setEnhanceModalWarning = (message) => {
            const warningEl = document.getElementById('enhance-modal-warning');
            warningEl.textContent = message || '';
        };

        const runEnhancement = () => {
            const idx = Game.enhanceModal.index;
            const item = Game.player.inventory[idx];
            if (!isEnhanceableItem(item)) return;
            normalizeWeaponEnhancement(item);
            const level = getWeaponEnhancementLevel(item);
            if (item.isBroken) {
                setEnhanceModalWarning('ç ´æä¸­ã®ãŸã‚ä¿®ç†ãŒå¿…è¦ã§ã™ã€‚');
                return;
            }
            if (level >= MAX_WEAPON_ENHANCEMENT) {
                setEnhanceModalWarning('ã“ã‚Œä»¥ä¸Šã¯å¼·åŒ–ã§ãã¾ã›ã‚“ã€‚');
                return;
            }
            const cost = getWeaponEnhancementCost(item);
            if (Game.player.gold < cost) {
                setEnhanceModalWarning('å¼·åŒ–è²»ç”¨ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚');
                return;
            }
            Game.player.gold -= cost;
            const rate = getWeaponEnhancementRate(level);
            const success = Math.random() < rate;
            let resultType = 'success';
            let newLevel = level;
            if (success) {
                newLevel = level + 1;
                item.enhancementLevel = newLevel;
            } else if (level <= 5) {
                resultType = 'safe';
            } else if (level <= 9) {
                resultType = 'down';
                newLevel = Math.max(0, level - 1);
                item.enhancementLevel = newLevel;
            } else {
                resultType = 'broken';
                item.isBroken = true;
            }
            Game.enhanceModal.result = {
                success,
                resultType,
                oldLevel: level,
                newLevel,
                deltaRate: 3
            };
            Game.enhanceModal.stage = 'progress';
            syncEnhanceModalStages();
            Game.enhanceModal.timer = setTimeout(() => {
                showEnhancementResult();
            }, 1200);
            updateUI();
            triggerAutosave();
        };

        const syncEnhanceModalStages = () => {
            const progress = document.getElementById('enhance-modal-progress');
            const result = document.getElementById('enhance-modal-result');
            const startBtn = document.getElementById('enhance-modal-start');
            if (Game.enhanceModal.stage === 'progress') {
                progress.classList.remove('hidden');
                result.classList.add('hidden');
                startBtn.classList.add('hidden');
            } else if (Game.enhanceModal.stage === 'result') {
                progress.classList.add('hidden');
                result.classList.remove('hidden');
                startBtn.classList.add('hidden');
            } else {
                progress.classList.add('hidden');
                result.classList.add('hidden');
                startBtn.classList.remove('hidden');
            }
        };

        const showEnhancementResult = () => {
            if (Game.enhanceModal.timer) {
                clearTimeout(Game.enhanceModal.timer);
                Game.enhanceModal.timer = null;
            }
            Game.enhanceModal.stage = 'result';
            const result = Game.enhanceModal.result;
            const icon = document.getElementById('enhance-modal-result-icon');
            const title = document.getElementById('enhance-modal-result-title');
            const detail = document.getElementById('enhance-modal-result-detail');
            const extra = document.getElementById('enhance-modal-result-extra');
            if (!result) return;
            if (result.success) {
                icon.className = 'w-16 h-16 mx-auto rounded-2xl bg-emerald-100 text-emerald-600 flex items-center justify-center text-2xl enhance-glow-success';
                icon.innerHTML = '<i class="fas fa-sparkles"></i>';
                title.textContent = 'å¼·åŒ–æˆåŠŸï¼';
                detail.textContent = `+${result.newLevel} ã«ãªã£ãŸ`;
                extra.textContent = `åŸºç¤ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ +${result.deltaRate}%`;
                addLog(`å¼·åŒ–æˆåŠŸï¼ +${result.newLevel}`, "text-emerald-500 font-bold");
            } else if (result.resultType === 'safe') {
                icon.className = 'w-16 h-16 mx-auto rounded-2xl bg-slate-100 text-slate-500 flex items-center justify-center text-2xl enhance-glow-fail';
                icon.innerHTML = '<i class="fas fa-cloud-rain"></i>';
                title.textContent = 'å¼·åŒ–å¤±æ•—...';
                detail.textContent = 'å¤‰åŒ–ãªã—';
                extra.textContent = 'ãƒšãƒŠãƒ«ãƒ†ã‚£ãªã—';
                addLog('å¼·åŒ–å¤±æ•—ï¼ˆå¤‰åŒ–ãªã—ï¼‰', "text-slate-400 font-bold");
            } else if (result.resultType === 'down') {
                icon.className = 'w-16 h-16 mx-auto rounded-2xl bg-rose-100 text-rose-500 flex items-center justify-center text-2xl enhance-glow-fail';
                icon.innerHTML = '<i class="fas fa-heart-crack"></i>';
                title.textContent = 'å¼·åŒ–å¤±æ•—...';
                detail.textContent = `+${result.newLevel} ã«ä½ä¸‹`;
                extra.textContent = `åŸºç¤ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ -${result.deltaRate}%`;
                addLog('å¼·åŒ–å¤±æ•—ã§å¼·åŒ–å€¤ãŒä½ä¸‹', "text-rose-400 font-bold");
            } else {
                icon.className = 'w-16 h-16 mx-auto rounded-2xl bg-rose-100 text-rose-500 flex items-center justify-center text-2xl enhance-glow-fail';
                icon.innerHTML = '<i class="fas fa-skull-crossbones"></i>';
                title.textContent = 'å¼·åŒ–å¤±æ•—...';
                detail.textContent = 'è£…å‚™ãŒç ´æã—ãŸ';
                extra.textContent = 'ä¿®ç†ãŒå¿…è¦';
                addLog('å¼·åŒ–å¤±æ•—ã§è£…å‚™ãŒç ´æ', "text-rose-500 font-bold");
            }
            syncEnhanceModalStages();
            updateUI();
            syncEnhanceModal();
        };

        const handleEnhanceModalTap = () => {
            if (Game.enhanceModal.stage === 'progress') {
                showEnhancementResult();
                return;
            }
            if (Game.enhanceModal.stage === 'result') {
                closeEnhanceModal();
            }
        };

        function repairWeapon(idx) {
            const item = Game.player.inventory[idx];
            if (!isEnhanceableItem(item)) return;
            normalizeWeaponEnhancement(item);
            if (!item.isBroken) return;
            const cost = getWeaponEnhancementCost(item) * 2;
            if (Game.player.gold < cost) {
                addLog("ä¿®ç†è²»ç”¨ãŒè¶³ã‚Šãªã„ï¼", "text-slate-400");
                return;
            }
            Game.player.gold -= cost;
            item.isBroken = false;
            addLog(`${item.name} ã‚’ä¿®ç†ã—ãŸ`, "text-sky-500 font-bold");
            updateUI();
            triggerAutosave();
        }

        function bulkSellByRarity(rarities) {
            if (!Array.isArray(rarities) || rarities.length === 0) return;
            let totalGold = 0;
            const activeFilter = Game.inventoryFilter || 'all';
            for (let i = Game.player.inventory.length - 1; i >= 0; i--) {
                const item = Game.player.inventory[i];
                if (!item || isItemEquipped(item) || item.favorite) continue;
                if (activeFilter !== 'all' && item.type !== activeFilter) continue;
                if (!rarities.includes(item.rarity)) continue;
                totalGold += getSellPrice(item);
                Game.player.inventory.splice(i, 1);
            }
            if (totalGold > 0) {
                Game.player.gold += totalGold;
            }
            updateUI();
            triggerAutosave();
        }

        function updateUI() {
            ensureWarpState();
            const p = Game.player;
            const derived = getDerivedStats();
            const totals = derived.totals;
            syncEquippedItemIds();
            document.getElementById('floor-display').innerText = Game.floor;
            document.getElementById('header-lvl').innerText = p.level;
            document.getElementById('header-sp').innerText = p.sp;
            document.getElementById('header-gold').innerText = formatGold(p.gold);
            document.getElementById('skill-sp-display').innerText = p.sp;
            updateSkillPointModeButton();
            const rematchToggle = document.getElementById('rematch-toggle');
            if (rematchToggle) {
                rematchToggle.checked = Boolean(Game.stayOnFloor);
            }

            // Health/Mana/Exp
            p.hp = Math.min(p.hp, derived.maxHp);
            p.mp = Math.min(p.mp, derived.maxMp);
            document.getElementById('player-hp-text').innerText = `${p.hp}/${derived.maxHp}`;
            document.getElementById('player-hp-bar').style.width = (p.hp/derived.maxHp*100)+'%';
            document.getElementById('player-mp-text').innerText = `${p.mp}/${derived.maxMp}`;
            document.getElementById('player-mp-bar').style.width = (p.mp/derived.maxMp*100)+'%';
            document.getElementById('player-exp-text-battle').innerText = `${p.exp}/${p.next}`;
            document.getElementById('player-exp-bar-battle').style.width = (p.exp/p.next*100)+'%';

            const e = Game.enemy;
            if (e) {
                const enemyName = document.getElementById('enemy-name');
                const enemyVisual = document.getElementById('enemy-visual');
                const bossBadge = document.getElementById('enemy-boss-badge');
                enemyName.innerText = e.name;
                document.getElementById('enemy-hp-text').innerText = `${e.hp}/${e.maxHp}`;
                document.getElementById('enemy-hp-bar').style.width = (e.hp/e.maxHp*100)+'%';
                enemyVisual.innerHTML = `<i class="fas ${e.icon}"></i>`;
                if (e.isBoss) {
                    enemyVisual.classList.add('boss-visual');
                    enemyName.classList.add('boss-name');
                    if (bossBadge) {
                        bossBadge.classList.remove('hidden');
                        bossBadge.classList.add('flex');
                    }
                } else {
                    enemyVisual.classList.remove('boss-visual');
                    enemyName.classList.remove('boss-name');
                    if (bossBadge) {
                        bossBadge.classList.add('hidden');
                        bossBadge.classList.remove('flex');
                    }
                }
            }

            const renderBossRushBuffs = (enemy) => {
                const container = document.getElementById('enemy-bossrush-buffs');
                if (!container) return;
                container.innerHTML = '';
                const buffs = getBossRushBuffs(enemy);
                if (!buffs.length) {
                    return;
                }
                buffs.forEach((buff) => {
                    const badge = document.createElement('span');
                    badge.className = `flex items-center gap-1 px-2 py-0.5 rounded-full ${buff.colorClass || "bg-slate-100 text-slate-500"} text-[9px] font-bold`;
                    badge.innerHTML = `<i class="fa-solid ${buff.icon || "fa-star"}"></i><span>${buff.shortLabel}</span>`;
                    container.appendChild(badge);
                });
            };

            const renderStatusEffects = (target, containerId) => {
                const container = document.getElementById(containerId);
                if (!container) return;
                container.innerHTML = '';
                if (!target || !Array.isArray(target.statusEffects) || target.statusEffects.length === 0) {
                    container.innerHTML = '<span class="text-[10px] text-slate-400"></span>';
                    return;
                }
                target.statusEffects.forEach(effect => {
                    const def = StatusDefs[effect.id];
                    if (!def) return;
                    const badge = document.createElement('button');
                    badge.type = 'button';
                    badge.className = "flex items-center gap-1 bg-slate-100 text-slate-600 px-2 py-1 rounded-full hover:bg-slate-200 transition-colors";
                    badge.innerHTML = `
                        <i class="fa-solid ${def.icon}"></i>
                        <span class="text-[9px] font-bold">x${effect.stacks || 1}</span>
                        <span class="text-[9px]">${effect.turns}T</span>
                    `;
                    badge.addEventListener('click', () => openStatusEffectModal(def, effect));
                    container.appendChild(badge);
                });
            };
            renderBossRushBuffs(Game.enemy);
            renderStatusEffects(Game.player, 'player-status-effects');
            renderStatusEffects(Game.enemy, 'enemy-status-effects');

            // Skill Slots
            const battleSlots = document.getElementById('battle-skill-slots');
            if (battleSlots) {
                battleSlots.innerHTML = '';
                const slotResult = getNextSlotSkill();
                const nextSkill = slotResult.skill;
                const label = nextSkill ? `${nextSkill.name} MP ${nextSkill.mp}` : 'é€šå¸¸æ”»æ’ƒ MP 0';
                const card = document.createElement('div');
                card.className = "rounded-xl border px-3 py-2 text-center text-[10px] font-bold border-slate-200 bg-slate-50 text-slate-700";
                card.innerHTML = `<div class="truncate">${label}</div>`;
                battleSlots.appendChild(card);
            }

            const potionSlots = document.getElementById('battle-potion-slots');
            if (potionSlots) {
                potionSlots.innerHTML = '';
                ['potion1', 'potion2'].forEach((slotKey, index) => {
                    const potion = Game.player[slotKey];
                    const button = document.createElement('button');
                    button.type = 'button';
                    if (!potion) {
                        button.className = "w-full rounded-xl border border-dashed border-slate-200 bg-slate-50 text-slate-300 px-3 py-2 text-[10px] font-bold flex items-center justify-center gap-2";
                        button.innerHTML = `<i class="fas fa-plus"></i> ç©ºãã‚¹ãƒ­ãƒƒãƒˆ`;
                        button.disabled = true;
                    } else {
                        const potionDerived = syncPotionCapacity(potion);
                        const capPct = potionDerived.maxCapacity > 0 ? (potion.currentCapacity / potionDerived.maxCapacity) * 100 : 0;
                        let healText = potionDerived.healPct > 0 ? `${potionDerived.healPct}%` : `${potionDerived.healFlat}`;
                        if (potion.healMode === "hybridCap") {
                            const capText = Number.isFinite(potion.healCapPct) ? ` (ä¸Šé™${potion.healCapPct}%)` : "";
                            healText = `${potionDerived.healFlat}+${potionDerived.healPct}%${capText}`;
                        } else if (potion.healMode === "missing") {
                            healText = `${potionDerived.healFlat}+æ¬ æ${potionDerived.healPct}%`;
                        }
                        const canUse = potion.currentCapacity >= potionDerived.cost;
                        button.className = `w-full rounded-xl border px-3 py-2 text-[10px] font-bold flex items-center gap-2 transition-colors ${
                            canUse ? 'border-slate-200 bg-white text-slate-700 hover:bg-slate-50' : 'border-slate-200 bg-slate-50 text-slate-300'
                        }`;
                        button.innerHTML = `
                            <div class="w-8 h-8 rounded-lg bg-slate-100 flex items-center justify-center ${canUse ? 'text-emerald-500' : 'text-slate-300'}">
                                <i class="fas ${potion.icon || 'fa-flask'}"></i>
                            </div>
                            <div class="flex-1 min-w-0 text-left">
                                <div class="truncate">${potion.name}</div>
                                <div class="text-[9px] text-slate-400">å›å¾© ${healText} / æ¶ˆè²» ${potionDerived.cost}</div>
                                <div class="mt-1 h-1 w-full rounded-full bg-slate-200 overflow-hidden">
                                    <div class="h-full bg-emerald-400" style="width:${capPct}%;"></div>
                                </div>
                                <div class="text-[9px] text-slate-400">å®¹é‡ ${potion.currentCapacity}/${potionDerived.maxCapacity}</div>
                            </div>
                        `;
                        button.disabled = !canUse;
                        button.addEventListener('click', () => usePotion(index));
                    }
                    potionSlots.appendChild(button);
                });
            }

            const slotSettings = document.getElementById('skill-slot-settings');
            if (slotSettings) {
                slotSettings.innerHTML = '';
                Game.player.skillSlots.forEach((slot, idx) => {
                    const skill = getSlotSkill(slot);
                    const wrapper = document.createElement('div');
                    wrapper.className = "flex items-center gap-2";

                    const slotButton = document.createElement('button');
                    slotButton.className = `flex-1 text-left px-2 py-1.5 rounded-lg border text-[10px] font-bold ${
                        Game.player.skillSlotTarget === idx ? 'border-slate-800 bg-slate-800 text-white' : 'border-slate-200 bg-slate-50 text-slate-500'
                    }`;
                    slotButton.innerHTML = `
                        <div class="text-[9px] font-black">S${idx + 1}</div>
                        <div class="truncate">${skill ? skill.name : 'æœªè¨­å®š'}</div>
                    `;
                    slotButton.addEventListener('click', () => setSkillSlotTarget(idx));

                    const clearButton = document.createElement('button');
                    clearButton.className = `w-8 h-8 rounded-lg border flex items-center justify-center ${
                        skill ? 'border-slate-200 text-slate-500 bg-white' : 'border-slate-100 text-slate-300 bg-slate-50'
                    }`;
                    clearButton.innerHTML = '<i class="fas fa-xmark"></i>';
                    if (skill) {
                        clearButton.addEventListener('click', () => clearSkillSlot(idx));
                    } else {
                        clearButton.disabled = true;
                    }

                    wrapper.appendChild(slotButton);
                    wrapper.appendChild(clearButton);
                    slotSettings.appendChild(wrapper);
                });
            }

            // Button Control
            const btn = document.getElementById('action-btn');
            if (Game.state === 'combat') {
                btn.innerHTML = `<i class="fas fa-sword"></i> <span>æ”»æ’ƒ</span>`;
                btn.className = "w-full bg-slate-800 text-white font-black py-4 rounded-2xl shadow-lg active:scale-95 transition-transform text-lg flex items-center justify-center gap-2";
            } else {
                const idleLabel = Game.stayOnFloor ? 'å†æˆ¦' : 'æ¬¡ã®éšå±¤ã¸';
                const idleIcon = Game.stayOnFloor ? 'fa-rotate-right' : 'fa-shoe-prints';
                btn.innerHTML = `<i class="fas ${idleIcon}"></i> <span>${idleLabel}</span>`;
                btn.className = "w-full bg-blue-600 text-white font-black py-4 rounded-2xl shadow-lg active:scale-95 transition-transform text-lg flex items-center justify-center gap-2";
            }

            // Status Details
            document.getElementById('status-lvl').innerText = p.level;
            document.getElementById('status-atk').innerText = totals.str;
            document.getElementById('status-def').innerText = totals.vit;
            document.getElementById('status-int').innerText = totals.int;
            document.getElementById('status-dex').innerText = totals.dex;
            document.getElementById('status-luk').innerText = totals.luk;
            document.getElementById('status-exp').innerText = p.exp;
            document.getElementById('status-next').innerText = p.next;
            document.getElementById('status-exp-bar').style.width = (p.exp/p.next*100)+'%';
            
            // Secondary Stats Display
            const setStatusText = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.innerText = value;
            };
            setStatusText('stat-max-hp', totals.maxHpFlat);
            setStatusText('stat-max-mp', totals.maxMpFlat);
            setStatusText('stat-atk-flat', totals.attackFlat);
            setStatusText('stat-def-flat', totals.defenseFlat);
            setStatusText('stat-crit', `${totals.critRate}%`);
            setStatusText('stat-eva', `${totals.evasionRate}%`);
            setStatusText('stat-leech', `${totals.leechRate}%`);
            setStatusText('stat-exp-boost', `${totals.expBoost}%`);
            setStatusText('stat-m-pen', `${totals.mPen}%`);
            setStatusText('stat-luck', `${totals.luck}%`);
            setStatusText('stat-accuracy', `${totals.accuracy}%`);
            setStatusText('stat-hp-regen', totals.hpRegen);
            setStatusText('stat-mp-regen', totals.mpRegen);
            setStatusText('stat-crit-dmg', `${totals.critDamage}%`);
            setStatusText('stat-dmg-boost', `${totals.damageBoost}%`);
            setStatusText('stat-dmg-reduction', `${totals.damageReduction}%`);
            setStatusText('stat-rare-find', `${totals.rareFind}%`);
            setStatusText('stat-affix-find', `${totals.affixFind}%`);
            setStatusText('stat-elite-encounter', `${totals.eliteEncounter}%`);
            setStatusText('stat-gold-boost', `${totals.goldBoost}%`);

            updateEquipNameDisplay('equip-weapon', p.weapon);
            document.getElementById('weapon-val').innerHTML = p.weapon ? renderItemStatsGroupedHtml(p.weapon) : "";
            updateEquipNameDisplay('equip-armor', p.armor);
            document.getElementById('armor-val').innerHTML = p.armor ? renderItemStatsGroupedHtml(p.armor) : "";
            updateEquipNameDisplay('equip-head', p.head);
            document.getElementById('head-val').innerHTML = p.head ? renderItemStatsGroupedHtml(p.head) : "";
            updateEquipNameDisplay('equip-hands', p.hands);
            document.getElementById('hands-val').innerHTML = p.hands ? renderItemStatsGroupedHtml(p.hands) : "";
            updateEquipNameDisplay('equip-feet', p.feet);
            document.getElementById('feet-val').innerHTML = p.feet ? renderItemStatsGroupedHtml(p.feet) : "";
            updateEquipNameDisplay('equip-accessory1', p.accessory1);
            document.getElementById('accessory1-val').innerHTML = p.accessory1 ? renderItemStatsGroupedHtml(p.accessory1) : "";
            updateEquipNameDisplay('equip-accessory2', p.accessory2);
            document.getElementById('accessory2-val').innerHTML = p.accessory2 ? renderItemStatsGroupedHtml(p.accessory2) : "";

            // Inventory
            const invList = document.getElementById('inventory-list');
            invList.innerHTML = '';
            document.getElementById('inv-count').innerText = p.inventory.length;
            p.inventory.forEach((item) => {
                if (item.acquiredAt === undefined) {
                    item.acquiredAt = Game.inventoryCounter++;
                }
            });
            const activeFilter = Game.inventoryFilter || 'all';
            const sortMode = Game.inventorySort || 'acquired';
            const filteredItems = p.inventory
                .map((item, index) => ({ item, index }))
                .filter(({ item }) => activeFilter === 'all' || item.type === activeFilter);
            const getAffixScore = (item) => (item.prefix?.rank || 0) + (item.suffix?.rank || 0);
            const sortedItems = [...filteredItems].sort((a, b) => {
                const rarityA = RaritySortOrder[a.item.rarity] ?? 0;
                const rarityB = RaritySortOrder[b.item.rarity] ?? 0;
                const acquiredA = a.item.acquiredAt ?? a.index;
                const acquiredB = b.item.acquiredAt ?? b.index;
                if (sortMode === 'rarity') {
                    if (rarityA !== rarityB) return rarityB - rarityA;
                    return acquiredB - acquiredA;
                }
                if (sortMode === 'affix') {
                    const affixA = getAffixScore(a.item);
                    const affixB = getAffixScore(b.item);
                    if (affixA !== affixB) return affixB - affixA;
                    if (rarityA !== rarityB) return rarityB - rarityA;
                    return acquiredA - acquiredB;
                }
                return acquiredB - acquiredA;
            });
            sortedItems.forEach(({ item, index }) => {
                if (isEnhanceableItem(item)) {
                    normalizeWeaponEnhancement(item);
                }
                const sellPrice = getSellPrice(item);
                const sellPriceDisplay = formatGold(sellPrice);
                const div = document.createElement('div');
                div.className = "bg-white p-4 rounded-2xl border flex items-center justify-between shadow-sm";
                const equipped = isItemEquipped(item);
                const equipMarker = equipped
                    ? '<span class="text-emerald-500 font-black mr-1">[E]</span>'
                    : '';
                const favorite = Boolean(item.favorite);
                const favoriteMarker = favorite
                    ? '<i class="fas fa-star text-amber-400 mx-1"></i>'
                    : '';
                const isLongName = item.name.length >= 16;
                const deleteLabel = equipped ? 'è£…å‚™ä¸­' : 'å£²å´';
                const deleteDisabled = equipped || favorite;
                const deleteClasses = deleteDisabled
                    ? 'bg-slate-100 text-slate-300 cursor-not-allowed'
                    : 'bg-slate-100 text-slate-500';
                const deletePriceClass = deleteDisabled ? 'text-slate-300' : 'text-slate-400';
                const favoriteLabel = favorite ? 'ãŠæ°—ã«å…¥ã‚Šè§£é™¤' : 'ãŠæ°—ã«å…¥ã‚Š';
                const favoriteIcon = favorite ? 'fas fa-star' : 'far fa-star';
                const favoriteClasses = favorite
                    ? 'bg-amber-400 text-white'
                    : 'bg-slate-100 text-slate-500';
                const enhancementLabelHtml = getWeaponEnhancementLabelHtml(item);
                const brokenLabelHtml = getWeaponBrokenLabelHtml(item);
                const enhancementDisplay = [enhancementLabelHtml, brokenLabelHtml].filter(Boolean).join(' ');
                const isEnhanceable = isEnhanceableItem(item);
                const isAccessory = item.type === 'accessory';
                const isPotion = item.type === 'potion';
                const compareTargetExists = isAccessory
                    ? Boolean(Game.player.accessory1 || Game.player.accessory2)
                    : isPotion
                        ? Boolean(Game.player.potion1 || Game.player.potion2)
                        : Boolean(Game.player[item.type]);
                const compareDisabled = !compareTargetExists;
                const compareClasses = compareDisabled
                    ? 'bg-slate-100 text-slate-300 cursor-not-allowed'
                    : 'bg-white border border-slate-200 text-slate-600';
                const compareAction = (isAccessory || isPotion)
                    ? `openEquipSlotModal(Game.player.inventory[${index}], ${index})`
                    : `openCompareModal(${index})`;
                let enhancementButtonHtml = '';
                if (isEnhanceable) {
                    const level = getWeaponEnhancementLevel(item);
                    const isBroken = Boolean(item.isBroken);
                    const cost = getWeaponEnhancementCost(item);
                    if (isBroken) {
                        const repairCost = cost * 2;
                        const canRepair = Game.player.gold >= repairCost;
                        const repairClasses = canRepair
                            ? 'bg-rose-500 text-white'
                            : 'bg-slate-100 text-slate-300 cursor-not-allowed';
                        enhancementButtonHtml = `
                            <button onclick="repairWeapon(${index})" class="px-4 py-2 ${repairClasses} text-[10px] font-black rounded-xl flex items-center justify-center gap-1 leading-none" ${canRepair ? '' : 'disabled'}>
                                <i class="fas fa-screwdriver-wrench"></i>
                                <span>ä¿®ç†</span>
                                <span class="text-[9px] font-bold opacity-80">${formatGold(repairCost)}G</span>
                            </button>
                        `;
                    } else {
                        enhancementButtonHtml = `
                            <button onclick="openEnhanceModal(${index})" class="px-4 py-2 bg-slate-800 text-white text-[10px] font-black rounded-xl flex items-center justify-center gap-1 leading-none">
                                <span>å¼·åŒ–</span>
                            </button>
                        `;
                    }
                }
                div.innerHTML = `
                    <div class="min-w-0 flex-1">
                        <div class="text-[9px] text-slate-400 font-black uppercase tracking-widest mb-1">${getEquipmentTypeLabel(item)}</div>
                        <div class="font-black text-[11px] leading-tight whitespace-normal break-words rarity-${item.rarity} ${isLongName ? "text-[10px]" : ""}">${equipMarker}${favoriteMarker}${item.name}${enhancementDisplay ? ` ${enhancementDisplay}` : ""}</div>
                        <div class="mt-1">${renderItemStatsGroupedHtml(item)}</div>
                    </div>
                    <div class="ml-4 flex flex-col gap-2">
                        <button onclick="equip(${index})" class="px-5 py-2.5 bg-slate-800 text-white text-[11px] font-black rounded-xl">è£…å‚™</button>
                        <button onclick="deleteItem(${index})" class="px-5 py-2.5 ${deleteClasses} text-[11px] font-black rounded-xl flex items-center justify-center gap-1 leading-none" ${deleteDisabled ? 'disabled' : ''}>
                            <i class="fas fa-coins"></i>
                            <span>${deleteLabel}</span>
                            <span class="text-[9px] font-bold ${deletePriceClass}">${sellPriceDisplay}G</span>
                        </button>
                        <button onclick="toggleFavorite(${index})" class="px-4 py-2 ${favoriteClasses} text-[10px] font-black rounded-xl flex items-center justify-center gap-1">
                            <i class="${favoriteIcon}"></i>
                            <span>${favoriteLabel}</span>
                        </button>
                        ${enhancementButtonHtml}
                        <button onclick="${compareDisabled ? '' : compareAction}" class="px-4 py-2 ${compareClasses} text-[10px] font-black rounded-xl flex items-center justify-center gap-1 leading-none" ${compareDisabled ? 'disabled' : ''}>
                            <i class="fas fa-scale-balanced"></i>
                            <span>æ¯”è¼ƒ</span>
                        </button>
                    </div>
                `;
                invList.appendChild(div);
            });

            document.querySelectorAll('.inv-filter-btn').forEach((button) => {
                const type = button.getAttribute('data-inv-filter');
                const active = type === activeFilter;
                button.className = `inv-filter-btn py-2 rounded-xl border ${
                    active ? 'border-slate-800 bg-slate-800 text-white' : 'border-slate-200 bg-slate-50 text-slate-500'
                }`;
            });

            const sortDef = InventorySortDefs[sortMode] || InventorySortDefs.acquired;
            const sortLabel = document.getElementById('inv-sort-label');
            if (sortLabel) {
                sortLabel.innerText = sortDef.label;
            }
            const sortButton = document.getElementById('inv-sort-toggle');
            if (sortButton) {
                const icon = sortButton.querySelector('i');
                if (icon) {
                    icon.className = `fas ${sortDef.icon}`;
                }
            }
            updateWarpButtonState();
            const warpModal = document.getElementById('warp-modal');
            if (warpModal && warpModal.style.display === 'flex') {
                syncWarpModal();
            }
        }

        function openDonateModal() {
          const m = document.getElementById('donate-modal');
          if (m) { m.classList.remove('hidden'); m.classList.add('flex'); }
        }
        
        function openXShare(event) {
          if (event) event.preventDefault();
          const text = "#ã™ãã¾ã§ãƒã‚¯ã‚¹ãƒ©";
          const encoded = encodeURIComponent(text);
          const appUrl = `twitter://post?message=${encoded}`;
          const webUrl = `https://x.com/intent/tweet?text=${encoded}`;
        
          // ã¾ãšã‚¢ãƒ—ãƒªã€ãƒ€ãƒ¡ãªã‚‰Webï¼ˆiOSå´ãŒå¤–éƒ¨ã«é£›ã°ã—ã¦ãã‚Œã‚‹ï¼‰
          location.href = appUrl;
          setTimeout(() => { location.href = webUrl; }, 600);
          return false;
        }


        const bottomMenuState = { open: false };

        function setBottomMenuOpen(isOpen) {
            bottomMenuState.open = isOpen;
            const panel = document.getElementById('bottom-menu-panel');
            const backdrop = document.getElementById('bottom-menu-backdrop');
            const toggleButton = document.getElementById('nav-help');
            if (panel) panel.classList.toggle('hidden', !isOpen);
            if (backdrop) backdrop.classList.toggle('hidden', !isOpen);
            if (toggleButton) toggleButton.setAttribute('aria-expanded', String(isOpen));
        }

        function toggleBottomMenu() {
            setBottomMenuOpen(!bottomMenuState.open);
        }

        function closeBottomMenu() {
            setBottomMenuOpen(false);
        }

        function openBottomMenuHelp() {
            closeBottomMenu();
            switchPage('help');
        }

        function openBottomMenuSave() {
            closeBottomMenu();
            switchPage('save');
        }

        function openBottomMenuDonate() {
            closeBottomMenu();
            openDonateModal();
        }

        function openBottomMenuTweet(event) {
            closeBottomMenu();
            openXShare(event);
        }

        function openBottomMenuFeedback() {
            closeBottomMenu();
            switchPage('feedback');
        }

        const bottomMenuBackdrop = document.getElementById('bottom-menu-backdrop');
        if (bottomMenuBackdrop) {
            bottomMenuBackdrop.addEventListener('click', closeBottomMenu);
        }
        
        function closeDonateModal() {
          const m = document.getElementById('donate-modal');
          if (m) {
            m.classList.add('hidden');
            m.classList.remove('flex');
          }
          // â† ã“ã‚ŒãŒå¤§äº‹ï¼šé–‰ã˜ãŸã‚‰å¿…ãšæ®‹éª¸ã‚’æ¶ˆã™
          hideDonateToast();
        }
        
        // donate UI state
        window.__donateUI = window.__donateUI || {
          toastTimer: null,
          lastToastText: "",
        };
        
        // ãƒˆãƒ¼ã‚¹ãƒˆè¡¨ç¤ºï¼ˆå¿…ãšè‡ªå‹•ã§æ¶ˆãˆã‚‹ï¼‰
        function showDonateToast(text, ms = 2300) {
          const wrap = document.getElementById('donate-toast');
          const label = document.getElementById('donate-toast-text');
          if (!wrap || !label) return;
        
          // è¡¨ç¤º
          label.textContent = text;
          wrap.classList.remove('hidden');
        
          // ã‚¿ã‚¤ãƒãƒ¼ã‚’å¿…ãšãƒªã‚»ãƒƒãƒˆ
          if (window.__donateUI.toastTimer) {
            clearTimeout(window.__donateUI.toastTimer);
            window.__donateUI.toastTimer = null;
          }
        
          // è‡ªå‹•ã§æ¶ˆã™
          window.__donateUI.toastTimer = setTimeout(() => {
            wrap.classList.add('hidden');
            window.__donateUI.toastTimer = null;
          }, ms);
        }
        
        // ãƒˆãƒ¼ã‚¹ãƒˆã‚’å³æ¶ˆã—ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«é–‰ã˜ãƒ»ç”»é¢åˆ‡æ›¿æ™‚ã«ä½¿ã†ï¼‰
        function hideDonateToast() {
          const wrap = document.getElementById('donate-toast');
          if (!wrap) return;
        
          if (window.__donateUI.toastTimer) {
            clearTimeout(window.__donateUI.toastTimer);
            window.__donateUI.toastTimer = null;
          }
          wrap.classList.add('hidden');
        
          const label = document.getElementById('donate-toast-text');
          if (label) label.textContent = "";
        }
        
        // HTMLâ†’Swiftã¸ productId ã‚’é€ã‚‹ï¼ˆSwiftå´ã¯ã“ã‚Œã ã‘å—ã‘ã‚Œã°OKï¼‰      
          // Webã§ã®ã¿ä½¿ã† Stripe Payment Linksï¼ˆã‚ãªãŸã®URLã«å·®ã—æ›¿ãˆï¼‰
          const STRIPE_LINKS = {
            tip_100: "https://buy.stripe.com/28EbIT40th203T12lngMw01",
            tip_300: "https://buy.stripe.com/aFa28jdB3h2075de45gMw00",
          };
        
          // iOSã‚¢ãƒ—ãƒªå†…ï¼ˆWKWebViewï¼‰ã®åˆ¤å®šï¼štip handler ãŒã‚ã‚‹ã‹ã©ã†ã‹
          function isIOSAppWebView() {
            try {
              return !!(window?.webkit?.messageHandlers?.tip?.postMessage);
            } catch (e) {
              return false;
            }
          }
        
          // Webã§Stripeã‚’é–‹ã
          function openStripeForWeb(productId) {
            const url = STRIPE_LINKS[productId];
        
            if (!url) {
              showDonateToast?.('Stripeãƒªãƒ³ã‚¯ãŒæœªè¨­å®šã§ã™', 1800);
              console.warn("Stripeãƒªãƒ³ã‚¯æœªè¨­å®š:", productId);
              return;
            }
        
            // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ç¶­æŒã—ãŸã„ã®ã§ã€Œæ–°è¦ã‚¿ãƒ–ã€æ¨å¥¨
            const opened = window.open(url, "_blank", "noopener,noreferrer");
        
            // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯å¯¾ç­–ï¼šé–‹ã‘ãªã‹ã£ãŸã‚‰åŒä¸€ã‚¿ãƒ–é·ç§»
            if (!opened) {
              location.href = url;
            }
        
            showDonateToast?.('æ±ºæ¸ˆãƒšãƒ¼ã‚¸ã‚’é–‹ãã¾ã—ãŸ', 1400);
          }
        
          // æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä¿ã¡ã¤ã¤ã€Webã§ã¯Stripeã¸
            function purchaseTip(productId, event) {
              // â˜… ã“ã‚Œã§ã€Œå…ƒãƒšãƒ¼ã‚¸å´ã®é·ç§»/è¦ªã‚¯ãƒªãƒƒã‚¯ã€ãªã©ã‚’ç¢ºå®Ÿã«æ­¢ã‚ã‚‹
              if (event) {
                event.preventDefault();
                event.stopPropagation();
              }
            
              hideDonateToast();
            
              // iOSã‚¢ãƒ—ãƒªå†…ãªã‚‰ä»Šã¾ã§é€šã‚Š
              try {
                const handler = window?.webkit?.messageHandlers?.tip;
                if (handler?.postMessage) {
                  handler.postMessage({ productId });
                  showDonateToast('è³¼å…¥ç”»é¢ã‚’é–‹ã„ã¦ã„ã¾ã™â€¦', 1200);
                  return;
                }
              } catch (e) {}
            
              // Webã¯Stripeã‚’ã€Œåˆ¥ã‚¿ãƒ–ã®ã¿ã€ã§é–‹ãï¼ˆåŒä¸€ã‚¿ãƒ–é·ç§»ã¯ã—ãªã„ï¼‰
              const url = STRIPE_LINKS?.[productId];
              if (!url) {
                showDonateToast('æ±ºæ¸ˆãƒªãƒ³ã‚¯ãŒæœªè¨­å®šã§ã™', 1800);
                return;
              }
            
              window.open(url, "_blank", "noopener,noreferrer");
              showDonateToast('æ±ºæ¸ˆãƒšãƒ¼ã‚¸ã‚’é–‹ãã¾ã—ãŸ', 1400);
            }



    </script>
    </div>
</body>
</html>
